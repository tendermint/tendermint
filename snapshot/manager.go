package snapshot

import (
	"crypto/sha256"
	"fmt"
	"sync/atomic"

	"github.com/golang/snappy"

	abci "github.com/tendermint/tendermint/abci/types"
	"github.com/tendermint/tendermint/blockchain"
	dbm "github.com/tendermint/tendermint/libs/db"
	"github.com/tendermint/tendermint/libs/log"
	sm "github.com/tendermint/tendermint/state"
	"github.com/tendermint/tendermint/types"
)

var manager atomic.Value // the global manager maintain tracking current snapshot height

func InitSnapshotManager(
	stateDB dbm.DB,
	txIndexDB dbm.DB,
	blockStore *blockchain.BlockStore,
	dbDir string,
	logger log.Logger) {

	reader := abci.SnapshotReader{DbDir: dbDir}
	height := reader.LatestSnapshotHeight()

	mgr := &SnapshotManager{
		stateDB:    stateDB,
		txIndexDB:  txIndexDB,
		blockStore: blockStore,
		logger:     logger,
		height:     height,

		Reader: reader,
		Writer: abci.SnapshotWriter{Height: height, DbDir: dbDir},
	}
	manager.Store(mgr)
}

func Manager() *SnapshotManager {
	if mgr, ok := manager.Load().(*SnapshotManager); ok {
		return mgr
	} else {
		return nil
	}
}

func ManagerAt(height int64) *SnapshotManager {
	if mgr, ok := manager.Load().(*SnapshotManager); ok {
		newMgr := &SnapshotManager{
			stateDB:    mgr.stateDB,
			txIndexDB:  mgr.txIndexDB,
			blockStore: mgr.blockStore,
			logger:     mgr.logger,
			height:     height,

			RestorationManifest: &abci.Manifest{Version: abci.ManifestVersion, Height: height},
			Reader:              abci.SnapshotReader{Height: height, DbDir: mgr.Reader.DbDir},
			Writer:              abci.SnapshotWriter{Height: height, DbDir: mgr.Writer.DbDir},
		}
		return newMgr
	} else {
		return nil
	}
}

// application should only interact with this manager (not internal Reader/Writer)
// but we have to expose reader/writer to make tendermint state sync reactor manipulate low level data
type SnapshotManager struct {
	stateDB    dbm.DB
	txIndexDB  dbm.DB
	blockStore *blockchain.BlockStore
	logger     log.Logger
	height     int64

	RestorationManifest *abci.Manifest
	Reader              abci.SnapshotReader
	Writer              abci.SnapshotWriter
}

func (mgr *SnapshotManager) WriteManifest(hash abci.SHA256Sum, manifest *abci.Manifest) error {
	mgr.setHeight(manifest.Height)
	mgr.RestorationManifest = manifest

	marshaled := cdc.MustMarshalBinaryBare(manifest)
	compressed := snappy.Encode(nil, marshaled)

	return mgr.Writer.WriteManifest(compressed)
}

func (mgr *SnapshotManager) WriteAppStateChunk(chunk *abci.AppStateChunk) error {
	marshaled := cdc.MustMarshalBinaryBare(chunk)
	compressed := snappy.Encode(nil, marshaled)
	hash := sha256.Sum256(compressed)
	if err := mgr.Writer.Write(hash, compressed); err == nil {
		mgr.RestorationManifest.AppStateHashes = append(mgr.RestorationManifest.AppStateHashes, hash)
		return nil
	} else {
		return err
	}
}

func (mgr *SnapshotManager) IsFinalized() bool {
	return mgr.Reader.IsFinalized()
}

// finalize snapshot we synced from peer
func (mgr *SnapshotManager) Finalize() error {
	err := mgr.Writer.Finalize()
	if err == nil {
		mgr.Reader.Height = mgr.height
	}
	return err
}

// finalize snapshot we generated by ourselves
func (mgr *SnapshotManager) SelfFinalize(numKeys []int64) error {
	if err := mgr.snapshotTMState(); err != nil {
		return err
	}
	if err := mgr.snapshotBlock(); err != nil {
		return err
	}

	mgr.RestorationManifest.NumKeys = numKeys
	marshaled := cdc.MustMarshalBinaryBare(mgr.RestorationManifest)
	compressed := snappy.Encode(nil, marshaled)
	if err := mgr.Writer.WriteManifest(compressed); err != nil {
		return err
	}
	if err := mgr.Writer.Finalize(); err != nil {
		return err
	}

	manager.Store(mgr)
	return nil
}

func (mgr *SnapshotManager) Delete() error {
	return mgr.Writer.Delete()
}

func (mgr *SnapshotManager) GetStateDB() dbm.DB {
	return mgr.stateDB
}

func (mgr *SnapshotManager) GetBlockStore() *blockchain.BlockStore {
	return mgr.blockStore
}

func (mgr *SnapshotManager) GetTxDB() dbm.DB {
	return mgr.txIndexDB
}

func (mgr *SnapshotManager) setHeight(height int64) {
	mgr.Writer.Height = height
	mgr.height = height
}

func (mgr *SnapshotManager) snapshotTMState() error {
	if state := sm.LoadStateForHeight(mgr.stateDB, mgr.height); state != nil {
		stateChunk := &abci.StateChunk{
			cdc.MustMarshalBinaryBare(state),
		}
		marshaled := cdc.MustMarshalBinaryBare(stateChunk)
		compressed := snappy.Encode(nil, marshaled)
		hash := sha256.Sum256(compressed)
		if err := mgr.Writer.Write(hash, compressed); err == nil {
			mgr.RestorationManifest.StateHashes = append(mgr.RestorationManifest.StateHashes, hash)
			return nil
		} else {
			return err
		}
	} else {
		return fmt.Errorf("cannot load state for height: %d", mgr.height)
	}
}

func (mgr *SnapshotManager) snapshotBlock() error {
	if block := mgr.blockStore.LoadBlock(mgr.height); block != nil {
		if block.Height != mgr.height {
			return fmt.Errorf("block %d to be snapshoted is not expected %d", block.Height, mgr.height)
		}
		seenCommit := mgr.blockStore.LoadSeenCommit(mgr.height)
		blockChunk := &abci.BlockChunk{
			cdc.MustMarshalBinaryBare(block),
			cdc.MustMarshalBinaryBare(*seenCommit),
		}
		marshaled := cdc.MustMarshalBinaryBare(blockChunk)
		compressed := snappy.Encode(nil, marshaled)
		hash := sha256.Sum256(compressed)
		if err := mgr.Writer.Write(hash, compressed); err == nil {
			mgr.RestorationManifest.BlockHashes = append(mgr.RestorationManifest.BlockHashes, hash)
			return nil
		} else {
			return err
		}
	} else {
		return fmt.Errorf("cannot load block for height: %d", mgr.height)
	}
}

func (mgr *SnapshotManager) restoreBlock(block *types.Block, seenCommit *types.Commit) {
	mgr.blockStore.SetHeight(block.Height - 1)
	mgr.blockStore.SaveBlock(block, block.MakePartSet(types.BlockPartSizeBytes), seenCommit)
}
