(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{712:function(e,t,a){"use strict";a.r(t);var s=a(1),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"adr-080-reversesync-fetching-historical-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#adr-080-reversesync-fetching-historical-data"}},[e._v("#")]),e._v(" ADR 080: ReverseSync - fetching historical data")]),e._v(" "),a("h2",{attrs:{id:"changelog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#changelog"}},[e._v("#")]),e._v(" Changelog")]),e._v(" "),a("ul",[a("li",[e._v("2021-02-11: Migrate to tendermint repo (Originally "),a("a",{attrs:{href:"https://github.com/tendermint/spec/pull/224",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 005"),a("OutboundLink")],1),e._v(")")]),e._v(" "),a("li",[e._v("2021-04-19: Use P2P to gossip necessary data for reverse sync.")]),e._v(" "),a("li",[e._v("2021-03-03: Simplify proposal to the state sync case.")]),e._v(" "),a("li",[e._v("2021-02-17: Add notes on asynchronicity of processes.")]),e._v(" "),a("li",[e._v("2020-12-10: Rename backfill blocks to reverse sync.")]),e._v(" "),a("li",[e._v("2020-11-25: Initial draft.")])]),e._v(" "),a("h2",{attrs:{id:"author-s"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#author-s"}},[e._v("#")]),e._v(" Author(s)")]),e._v(" "),a("ul",[a("li",[e._v("Callum Waters (@cmwaters)")])]),e._v(" "),a("h2",{attrs:{id:"context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[e._v("#")]),e._v(" Context")]),e._v(" "),a("p",[e._v("Two new features: "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/3652",target:"_blank",rel:"noopener noreferrer"}},[e._v("Block pruning"),a("OutboundLink")],1),e._v("\nand "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-042-state-sync.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("State sync"),a("OutboundLink")],1),e._v("\nmeant nodes no longer needed a complete history of the blockchain. This\nintroduced some challenges of its own which were covered and subsequently\ntackled with "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-077-block-retention.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC-001"),a("OutboundLink")],1),e._v(".\nThe RFC allowed applications to set a block retention height; an upper bound on\nwhat blocks would be pruned. However nodes who state sync past this upper bound\n(which is necessary as snapshots must be saved within the trusting period for\nthe assisting light client to verify) have no means of backfilling the blocks\nto meet the retention limit. This could be a problem as nodes who state sync and\nthen eventually switch to consensus (or fast sync) may not have the block and\nvalidator history to verify evidence causing them to panic if they see 2/3\ncommit on what the node believes to be an invalid block.")]),e._v(" "),a("p",[e._v("Thus, this RFC sets out to instil a minimum block history invariant amongst\nhonest nodes.")]),e._v(" "),a("h2",{attrs:{id:"proposal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proposal"}},[e._v("#")]),e._v(" Proposal")]),e._v(" "),a("p",[e._v("A backfill mechanism can simply be defined as an algorithm for fetching,\nverifying and storing, headers and validator sets of a height prior to the\ncurrent base of the node's blockchain. In matching the terminology used for\nother data retrieving protocols (i.e. fast sync and state sync), we\ncall this method "),a("strong",[e._v("ReverseSync")]),e._v(".")]),e._v(" "),a("p",[e._v("We will define the mechanism in four sections:")]),e._v(" "),a("ul",[a("li",[e._v("Usage")]),e._v(" "),a("li",[e._v("Design")]),e._v(" "),a("li",[e._v("Verification")]),e._v(" "),a("li",[e._v("Termination")])]),e._v(" "),a("h3",{attrs:{id:"usage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usage"}},[e._v("#")]),e._v(" Usage")]),e._v(" "),a("p",[e._v("For now, we focus purely on the case of a state syncing node, whom after\nsyncing to a height will need to verify historical data in order to be capable\nof processing new blocks. We can denote the earliest height that the node will\nneed to verify and store in order to be able to verify any evidence that might\narise as the "),a("code",[e._v("max_historical_height")]),e._v("/"),a("code",[e._v("time")]),e._v(". Both height and time are necessary\nas this maps to the BFT time used for evidence expiration. After acquiring\n"),a("code",[e._v("State")]),e._v(", we calculate these parameters as:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"bWF4X2hpc3RvcmljYWxfaGVpZ2h0ID0gbWF4KHN0YXRlLkluaXRpYWxIZWlnaHQsIHN0YXRlLkxhc3RCbG9ja0hlaWdodCAtIHN0YXRlLkNvbnNlbnN1c1BhcmFtcy5FdmlkZW5jZUFnZUhlaWdodCkKbWF4X2hpc3RvcmljYWxfdGltZSA9IG1heChHZW5lc2lzVGltZSwgc3RhdGUuTGFzdEJsb2NrVGltZS5TdWIoc3RhdGUuQ29uc2Vuc3VzUGFyYW1zLkV2aWRlbmNlQWdlVGltZSkpCg=="}}),e._v(" "),a("p",[e._v("Before starting either fast sync or consensus, we then run the following\nsynchronous process:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBSZXZlcnNlU3luYyhtYXhfaGlzdG9yaWNhbF9oZWlnaHQgaW50NjQsIG1heF9oaXN0b3JpY2FsX3RpbWUgdGltZS5UaW1lKSBlcnJvcgo="}}),e._v(" "),a("p",[e._v("Where we fetch and verify blocks until a block "),a("code",[e._v("A")]),e._v(" where\n"),a("code",[e._v("A.Height <= max_historical_height")]),e._v(" and "),a("code",[e._v("A.Time <= max_historical_time")]),e._v(".")]),e._v(" "),a("p",[e._v("Upon successfully reverse syncing, a node can now safely continue. As this\nfeature is only used as part of state sync, one can think of this as merely an\nextension to it.")]),e._v(" "),a("p",[e._v("In the future we may want to extend this functionality to allow nodes to fetch\nhistorical blocks for reasons of accountability or data accessibility.")]),e._v(" "),a("h3",{attrs:{id:"design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#design"}},[e._v("#")]),e._v(" Design")]),e._v(" "),a("p",[e._v("This section will provide a high level overview of some of the more important\ncharacteristics of the design, saving the more tedious details as an ADR.")]),e._v(" "),a("h4",{attrs:{id:"p2p"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p2p"}},[e._v("#")]),e._v(" P2P")]),e._v(" "),a("p",[e._v("Implementation of this RFC will require the addition of a new channel and two\nnew messages.")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"proto",base64:"bWVzc2FnZSBMaWdodEJsb2NrUmVxdWVzdCB7CiAgdWludDY0IGhlaWdodCA9IDE7Cn0K"}}),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"proto",base64:"bWVzc2FnZSBMaWdodEJsb2NrUmVzcG9uc2UgewogIEhlYWRlciBoZWFkZXIgPSAxOwogIENvbW1pdCBjb21taXQgPSAyOwogIFZhbGlkYXRvclNldCB2YWxpZGF0b3Jfc2V0ID0gMzsKfQo="}}),e._v(" "),a("p",[e._v("The P2P path may also enable P2P networked light clients and a state sync that\nalso doesn't need to rely on RPC.")]),e._v(" "),a("h3",{attrs:{id:"verification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#verification"}},[e._v("#")]),e._v(" Verification")]),e._v(" "),a("p",[e._v("ReverseSync is used to fetch the following data structures:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("Header")])]),e._v(" "),a("li",[a("code",[e._v("Commit")])]),e._v(" "),a("li",[a("code",[e._v("ValidatorSet")])])]),e._v(" "),a("p",[e._v("Nodes will also need to be able to verify these. This can be achieved by first\nretrieving the header at the base height from the block store. From this trusted\nheader, the node hashes each of the three data structures and checks that they are correct.")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("The trusted header's last block ID matches the hash of the new header")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"aGVhZGVyW2hlaWdodF0uTGFzdEJsb2NrSUQgPT0gaGFzaChoZWFkZXJbaGVpZ2h0LTFdKQo="}})],1),e._v(" "),a("li",[a("p",[e._v("The trusted header's last commit hash matches the hash of the new commit")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"aGVhZGVyW2hlaWdodF0uTGFzdENvbW1pdEhhc2ggPT0gaGFzaChjb21taXRbaGVpZ2h0LTFdKQo="}})],1),e._v(" "),a("li",[a("p",[e._v("Given that the node now trusts the new header, check that the header's validator set\nhash matches the hash of the validator set")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"aGVhZGVyW2hlaWdodC0xXS5WYWxpZGF0b3JzSGFzaCA9PSBoYXNoKHZhbGlkYXRvclNldFtoZWlnaHQtMV0pCg=="}})],1)]),e._v(" "),a("h3",{attrs:{id:"termination"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#termination"}},[e._v("#")]),e._v(" Termination")]),e._v(" "),a("p",[e._v("ReverseSync draws a lot of parallels with fast sync. An important consideration\nfor fast sync that also extends to ReverseSync is termination. ReverseSync will\nfinish it's task when one of the following conditions have been met:")]),e._v(" "),a("ol",[a("li",[e._v("It reaches a block "),a("code",[e._v("A")]),e._v(" where "),a("code",[e._v("A.Height <= max_historical_height")]),e._v(" and\n"),a("code",[e._v("A.Time <= max_historical_time")]),e._v(".")]),e._v(" "),a("li",[e._v("None of it's peers reports to have the block at the height below the\nprocesses current block.")]),e._v(" "),a("li",[e._v("A global timeout.")])]),e._v(" "),a("p",[e._v("This implies that we can't guarantee adequate history and thus the term\n\"invariant\" can't be used in the strictest sense. In the case that the first\ncondition isn't met, the node will log an error and optimistically attempt\nto continue with either fast sync or consensus.")]),e._v(" "),a("h2",{attrs:{id:"alternative-solutions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alternative-solutions"}},[e._v("#")]),e._v(" Alternative Solutions")]),e._v(" "),a("p",[e._v("The need for a minimum block history invariant stems purely from the need to\nvalidate evidence (although there may be some application relevant needs as\nwell). Because of this, an alternative, could be to simply trust whatever the\n2/3+ majority has agreed upon and in the case where a node is at the head of the\nblockchain, you simply abstain from voting.")]),e._v(" "),a("p",[e._v("As it stands, if 2/3+ vote on evidence you can't verify, in the same manner if\n2/3+ vote on a header that a node sees as invalid (perhaps due to a different\napp hash), the node will halt.")]),e._v(" "),a("p",[e._v("Another alternative is the method with which the relevant data is retrieved.\nInstead of introducing new messages to the P2P layer, RPC could have been used\ninstead.")]),e._v(" "),a("p",[e._v("The aforementioned data is already available via the following RPC endpoints:\n"),a("code",[e._v("/commit")]),e._v(" for "),a("code",[e._v("Header")]),e._v("'s' and "),a("code",[e._v("/validators")]),e._v(" for "),a("code",[e._v("ValidatorSet")]),e._v("'s'. It was\ndecided predominantly due to the instability of the current RPC infrastructure\nthat P2P be used instead.")]),e._v(" "),a("h2",{attrs:{id:"status"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#status"}},[e._v("#")]),e._v(" Status")]),e._v(" "),a("p",[e._v("Proposed")]),e._v(" "),a("h2",{attrs:{id:"consequences"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consequences"}},[e._v("#")]),e._v(" Consequences")]),e._v(" "),a("h3",{attrs:{id:"positive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#positive"}},[e._v("#")]),e._v(" Positive")]),e._v(" "),a("ul",[a("li",[e._v("Ensures a minimum block history invariant for honest nodes. This will allow\nnodes to verify evidence.")])]),e._v(" "),a("h3",{attrs:{id:"negative"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#negative"}},[e._v("#")]),e._v(" Negative")]),e._v(" "),a("ul",[a("li",[e._v("Statesync will be slower as more processing is required.")])]),e._v(" "),a("h3",{attrs:{id:"neutral"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#neutral"}},[e._v("#")]),e._v(" Neutral")]),e._v(" "),a("ul",[a("li",[e._v("By having validator sets served through p2p, this would make it easier to\nextend p2p support to light clients and state sync.")]),e._v(" "),a("li",[e._v("In the future, it may also be possible to extend this feature to allow for\nnodes to freely fetch and verify prior blocks")])]),e._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-077-block-retention.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC-001: Block retention"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/4629",target:"_blank",rel:"noopener noreferrer"}},[e._v("Original issue"),a("OutboundLink")],1)])])],1)}),[],!1,null,null,null);t.default=n.exports}}]);