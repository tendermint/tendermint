(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{743:function(e,t,n){"use strict";n.r(t);var o=n(1),s=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"rfc-017-abci-vote-extension-propagation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rfc-017-abci-vote-extension-propagation"}},[e._v("#")]),e._v(" RFC 017: ABCI++ Vote Extension Propagation")]),e._v(" "),n("h2",{attrs:{id:"changelog"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#changelog"}},[e._v("#")]),e._v(" Changelog")]),e._v(" "),n("ul",[n("li",[e._v("11-Apr-2022: Initial draft (@sergio-mena).")]),e._v(" "),n("li",[e._v("15-Apr-2022: Addressed initial comments. First complete version (@sergio-mena).")]),e._v(" "),n("li",[e._v("09-May-2022: Addressed all outstanding comments.")])]),e._v(" "),n("h2",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("According to the\n"),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/4743a7ad0/spec/abci%2B%2B/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ABCI++ specification"),n("OutboundLink")],1),e._v("\n(as of 11-Apr-2022), a validator MUST provide a signed vote extension for each non-"),n("code",[e._v("nil")]),e._v(" precommit vote\nof height "),n("em",[e._v("h")]),e._v(" that it uses to propose a block in height "),n("em",[e._v("h+1")]),e._v(". When a validator is up to\ndate, this is easy to do, but when a validator needs to catch up this is far from trivial as this data\ncannot be retrieved from the blockchain.")]),e._v(" "),n("p",[e._v("This RFC presents and compares the different options to address this problem, which have been proposed\nin several discussions by the Tendermint Core team.")]),e._v(" "),n("h2",{attrs:{id:"document-structure"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#document-structure"}},[e._v("#")]),e._v(" Document Structure")]),e._v(" "),n("p",[e._v("The RFC is structured as follows. In the "),n("a",{attrs:{href:"#background"}},[e._v("Background")]),e._v(" section,\nsubsections "),n("a",{attrs:{href:"#problem-description"}},[e._v("Problem Description")]),e._v(" and "),n("a",{attrs:{href:"#cases-to-address"}},[e._v("Cases to Address")]),e._v("\nexplain the problem at hand from a high level perspective, i.e., abstracting away from the current\nTendermint implementation. In contrast, subsection\n"),n("a",{attrs:{href:"#current-catch-up-mechanisms"}},[e._v("Current Catch-up Mechanisms")]),e._v(" delves into the details of the current\nTendermint code.")]),e._v(" "),n("p",[e._v("In the "),n("a",{attrs:{href:"#discussion"}},[e._v("Discussion")]),e._v(" section, subsection "),n("a",{attrs:{href:"#solutions-proposed"}},[e._v("Solutions Proposed")]),e._v(" is also\nworded abstracting away from implementation details, whilst subsections\n"),n("a",{attrs:{href:"#feasibility-of-the-proposed-solutions"}},[e._v("Feasibility of the Proposed Solutions")]),e._v(" and\n"),n("a",{attrs:{href:"#current-limitations-and-possible-implementations"}},[e._v("Current Limitations and Possible Implementations")]),e._v("\nanalize the viability of one of the proposed solutions in the context of Tendermint's architecture\nbased on reactors. Finally, "),n("a",{attrs:{href:"#formalization-work"}},[e._v("Formalization Work")]),e._v(" briefly discusses the work\nstill needed demonstrate the correctness of the chosen solution.")]),e._v(" "),n("p",[e._v("The high level subsections are aimed at readers who are familiar with consensus algorithms, in\nparticular with the one described in the Tendermint (white paper), but who are not necessarily\nacquainted with the details of the Tendermint codebase. The other subsections, which go into\nimplementation details, are best understood by engineers with deep knowledge of the implementation of\nTendermint's blocksync and consensus reactors.")]),e._v(" "),n("h2",{attrs:{id:"background"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),n("h3",{attrs:{id:"basic-definitions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#basic-definitions"}},[e._v("#")]),e._v(" Basic Definitions")]),e._v(" "),n("p",[e._v("This document assumes that all validators have equal voting power for the sake of simplicity. This is done\nwithout loss of generality.")]),e._v(" "),n("p",[e._v("There are two types of votes in Tendermint: "),n("em",[e._v("prevotes")]),e._v(" and "),n("em",[e._v("precommits")]),e._v(". Votes can be "),n("code",[e._v("nil")]),e._v(" or refer to\na proposed block. This RFC focuses on precommits,\nalso known as "),n("em",[e._v("precommit votes")]),e._v(". In this document we sometimes call them simply "),n("em",[e._v("votes")]),e._v(".")]),e._v(" "),n("p",[e._v("Validators send precommit votes to their peer nodes in "),n("em",[e._v("precommit messages")]),e._v(". According to the\n"),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/4743a7ad0/spec/abci%2B%2B/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ABCI++ specification"),n("OutboundLink")],1),e._v(",\na precommit message MUST also contain a "),n("em",[e._v("vote extension")]),e._v(".\nThis mandatory vote extension can be empty, but MUST be signed with the same key as the precommit\nvote (i.e., the sending validator's).\nNevertheless, the vote extension is signed independently from the vote, so a vote can be separated from\nits extension.\nThe reason for vote extensions to be mandatory in precommit messages is that, otherwise, a (malicious)\nnode can omit a vote extension while still providing/forwarding/sending the corresponding precommit vote.")]),e._v(" "),n("p",[e._v("The validator set at height "),n("em",[e._v("h")]),e._v(" is denoted "),n("em",[e._v("valset"),n("sub",[e._v("h")])]),e._v(". A "),n("em",[e._v("commit")]),e._v(" for height "),n("em",[e._v("h")]),e._v(" consists of more\nthan "),n("em",[e._v("2n"),n("sub",[e._v("h")]),e._v("/3")]),e._v(" precommit votes voting for a block "),n("em",[e._v("b")]),e._v(", where "),n("em",[e._v("n"),n("sub",[e._v("h")])]),e._v(" denotes the size of\n"),n("em",[e._v("valset"),n("sub",[e._v("h")])]),e._v(". A commit does not contain "),n("code",[e._v("nil")]),e._v(" precommit votes, and all votes in it refer to the\nsame block. An "),n("em",[e._v("extended commit")]),e._v(" is a "),n("em",[e._v("commit")]),e._v(" where every precommit vote has its respective vote extension\nattached.")]),e._v(" "),n("h3",{attrs:{id:"problem-description"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#problem-description"}},[e._v("#")]),e._v(" Problem Description")]),e._v(" "),n("p",[e._v("In the version of "),n("a",{attrs:{href:"https://github.com/tendermint/spec/blob/4fb99af/spec/abci/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ABCI"),n("OutboundLink")],1),e._v(" present up to\nTendermint v0.35, for any height "),n("em",[e._v("h")]),e._v(", a validator "),n("em",[e._v("v")]),e._v(" MUST have the decided block "),n("em",[e._v("b")]),e._v(" and a commit for\nheight "),n("em",[e._v("h")]),e._v(" in order to decide at height "),n("em",[e._v("h")]),e._v(". Then, "),n("em",[e._v("v")]),e._v(" just needs a commit for height "),n("em",[e._v("h")]),e._v(" to propose at\nheight "),n("em",[e._v("h+1")]),e._v(", in the rounds of "),n("em",[e._v("h+1")]),e._v(" where "),n("em",[e._v("v")]),e._v(" is a proposer.")]),e._v(" "),n("p",[e._v("In "),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/4743a7ad0/spec/abci%2B%2B/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ABCI++"),n("OutboundLink")],1),e._v(",\nthe information that a validator "),n("em",[e._v("v")]),e._v(" MUST have to be able to decide in "),n("em",[e._v("h")]),e._v(" does not change with\nrespect to pre-existing ABCI: the decided block "),n("em",[e._v("b")]),e._v(" and a commit for "),n("em",[e._v("h")]),e._v(".\nIn contrast, for proposing in "),n("em",[e._v("h+1")]),e._v(", a commit for "),n("em",[e._v("h")]),e._v(" is not enough: "),n("em",[e._v("v")]),e._v(" MUST now have an extended\ncommit.")]),e._v(" "),n("p",[e._v("When a validator takes an active part in consensus at height "),n("em",[e._v("h")]),e._v(", it has all the data it needs in memory,\nin its consensus state, to decide on "),n("em",[e._v("h")]),e._v(" and propose in "),n("em",[e._v("h+1")]),e._v(". Things are not so easy in the cases when\n"),n("em",[e._v("v")]),e._v(" cannot take part in consensus because it is late (e.g., it falls behind, it crashes\nand recovers, or it just starts after the others). If "),n("em",[e._v("v")]),e._v(" does not take part, it cannot actively\ngather precommit messages (which include vote extensions) in order to decide.\nBefore ABCI++, this was not a problem: full nodes are supposed to persist past blocks in the block store,\nso other nodes would realise that "),n("em",[e._v("v")]),e._v(" is late and send it the missing decided block at height "),n("em",[e._v("h")]),e._v(" and\nthe corresponding commit (kept in block "),n("em",[e._v("h+1")]),e._v(") so that "),n("em",[e._v("v")]),e._v(" can catch up.\nHowever, we cannot apply this catch-up technique for ABCI++, as the vote extensions, which are part\nof the needed "),n("em",[e._v("extended commit")]),e._v(" are not part of the blockchain.")]),e._v(" "),n("h3",{attrs:{id:"cases-to-address"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cases-to-address"}},[e._v("#")]),e._v(" Cases to Address")]),e._v(" "),n("p",[e._v("Before we tackle the description of the possible cases we need to address, let us describe the following\nincremental improvement to the ABCI++ logic. Upon decision, a full node persists (e.g., in the block\nstore) the extended commit that allowed the node to decide. For the moment, let us assume the node only\nneeds to keep its "),n("em",[e._v("most recent")]),e._v(" extended commit, and MAY remove any older extended commits from persistent\nstorage.\nThis improvement is so obvious that all solutions described in the "),n("a",{attrs:{href:"#discussion"}},[e._v("Discussion")]),e._v(" section use\nit as a building block. Moreover, it completely addresses by itself some of the cases described in this\nsubsection.")]),e._v(" "),n("p",[e._v("We now describe the cases (i.e. possible "),n("em",[e._v("runs")]),e._v(" of the system) that have been raised in different\ndiscussions and need to be addressed. They are (roughly) ordered from easiest to hardest to deal with.")]),e._v(" "),n("ul",[n("li",[n("p",[n("strong",[e._v("(a)")]),e._v(" "),n("em",[e._v("Happy path: all validators advance together, no crash")]),e._v(".")]),e._v(" "),n("p",[e._v("This case is included for completeness. All validators have taken part in height "),n("em",[e._v("h")]),e._v(".\nEven if some of them did not manage to send a precommit message for the decided block, they all\nreceive enough precommit messages to be able to decide. As vote extensions are mandatory in\nprecommit messages, every validator "),n("em",[e._v("v")]),e._v(" trivially has all the information, namely the decided block\nand the extended commit, needed to propose in height "),n("em",[e._v("h+1")]),e._v(" for the rounds in which "),n("em",[e._v("v")]),e._v(" is the\nproposer.")]),e._v(" "),n("p",[e._v("No problem to solve here.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("(b)")]),e._v(" "),n("em",[e._v("All validators advance together, then all crash at the same height")]),e._v(".")]),e._v(" "),n("p",[e._v("This case has been raised in some discussions, the main concern being whether the vote extensions\nfor the previous height would be lost across the network. With the improvement described above,\nnamely persisting the latest extended commit at decision time, this case is solved.\nWhen a crashed validator recovers, it recovers the last extended commit from persistent storage\nand handshakes with the Application.\nIf need be, it also reconstructs messages for the unfinished height\n(including all precommits received) from the WAL.\nThen, the validator can resume where it was at the time of the crash. Thus, as extensions are\npersisted, either in the WAL (in the form of received precommit messages), or in the latest\nextended commit, the only way that vote extensions needed to start the next height could be lost\nforever would be if all validators crashed and never recovered (e.g. disk corruption).\nSince a "),n("em",[e._v("correct")]),e._v(" node MUST eventually recover, this violates Tendermint's assumption of more than\n"),n("em",[e._v("2n"),n("sub",[e._v("h")]),e._v("/3")]),e._v(" correct validators for every height "),n("em",[e._v("h")]),e._v(".")]),e._v(" "),n("p",[e._v("No problem to solve here.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("(c)")]),e._v(" "),n("em",[e._v("Lagging majority")]),e._v(".")]),e._v(" "),n("p",[e._v("Let us assume the validator set does not change between "),n("em",[e._v("h")]),e._v(" and "),n("em",[e._v("h+1")]),e._v(".\nIt is not possible by the nature of the Tendermint algorithm, which requires more\nthan "),n("em",[e._v("2n"),n("sub",[e._v("h")]),e._v("/3")]),e._v(" precommit votes for some round of height "),n("em",[e._v("h")]),e._v(" in order to make progress.\nSo, only up to "),n("em",[e._v("n"),n("sub",[e._v("h")]),e._v("/3")]),e._v(" validators can lag behind.")]),e._v(" "),n("p",[e._v("On the other hand, for the case where there are changes to the validator set between "),n("em",[e._v("h")]),e._v(" and\n"),n("em",[e._v("h+1")]),e._v(" please see case (d) below, where the extreme case is discussed.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("(d)")]),e._v(" "),n("em",[e._v("Validator set changes completely between")]),e._v(" h "),n("em",[e._v("and")]),e._v(" h+1.")]),e._v(" "),n("p",[e._v("If sets "),n("em",[e._v("valset"),n("sub",[e._v("h")])]),e._v(" and "),n("em",[e._v("valset"),n("sub",[e._v("h+1")])]),e._v(" are disjoint,\nmore than "),n("em",[e._v("2n"),n("sub",[e._v("h")]),e._v("/3")]),e._v(" of validators in height "),n("em",[e._v("h")]),e._v(" should\nhave actively participated in conensus in "),n("em",[e._v("h")]),e._v(". So, as of height "),n("em",[e._v("h")]),e._v(", only a minority of validators\nin "),n("em",[e._v("h")]),e._v(" can be lagging behind, although they could all lag behind from "),n("em",[e._v("h+1")]),e._v(" on, as they are no\nlonger validators, only full nodes. This situation falls under the assumptions of case (h) below.")]),e._v(" "),n("p",[e._v("As for validators in "),n("em",[e._v("valset"),n("sub",[e._v("h+1")])]),e._v(", as they were not validators as of height "),n("em",[e._v("h")]),e._v(", they\ncould all be lagging behind by that time. However, by the time "),n("em",[e._v("h")]),e._v(" finishes and "),n("em",[e._v("h+1")]),e._v(" begins, the\nchain will halt until more than "),n("em",[e._v("2n"),n("sub",[e._v("h+1")]),e._v("/3")]),e._v(" of them have caught up and started consensus\nat height "),n("em",[e._v("h+1")]),e._v(". If set "),n("em",[e._v("valset"),n("sub",[e._v("h+1")])]),e._v(" does not change in "),n("em",[e._v("h+2")]),e._v(" and subsequent\nheights, only up to "),n("em",[e._v("n"),n("sub",[e._v("h+1")]),e._v("/3")]),e._v(" validators will be able to lag behind. Thus, we have\nconverted this case into case (h) below.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("(e)")]),e._v(" "),n("em",[e._v("Enough validators crash to block the rest")]),e._v(".")]),e._v(" "),n("p",[e._v("In this case, blockchain progress halts, i.e. surviving full nodes keep increasing rounds\nindefinitely, until some of the crashed validators are able to recover.\nThose validators that recover first will handshake with the Application and recover at the height\nthey crashed, which is still the same the nodes that did not crash are stuck in, so they don't need\nto catch up.\nFurther, they had persisted the extended commit for the previous height. Nothing to solve.")]),e._v(" "),n("p",[e._v("For those validators recovering later, we are in case (h) below.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("(f)")]),e._v(" "),n("em",[e._v("Some validators crash, but not enough to block progress")]),e._v(".")]),e._v(" "),n("p",[e._v("When the correct processes that crashed recover, they handshake with the Application and resume at\nthe height they were at when they crashed. As the blockchain did not stop making progress, the\nrecovered processes are likely to have fallen behind with respect to the progressing majority.")]),e._v(" "),n("p",[e._v("At this point, the recovered processes are in case (h) below.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("(g)")]),e._v(" "),n("em",[e._v("A new full node starts")]),e._v(".")]),e._v(" "),n("p",[e._v("The reasoning here also applies to the case when more than one full node are starting.\nWhen the full node starts from scratch, it has no state (its current height is 0). Ignoring\nstatesync for the time being, the node just needs to catch up by applying past blocks one by one\n(after verifying them).")]),e._v(" "),n("p",[e._v("Thus, the node is in case (h) below.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("(h)")]),e._v(" "),n("em",[e._v("Advancing majority, lagging minority")])]),e._v(" "),n("p",[e._v("In this case, some nodes are late. More precisely, at the present time, a set of full nodes,\ndenoted "),n("em",[e._v("L"),n("sub",[e._v("h"),n("sub",[e._v("p")])])]),e._v(", are falling behind\n(e.g., temporary disconnection or network partition, memory thrashing, crashes, new nodes)\nan arbitrary\nnumber of heights:\nbetween "),n("em",[e._v("h"),n("sub",[e._v("s")])]),e._v(" and "),n("em",[e._v("h"),n("sub",[e._v("p")])]),e._v(", where "),n("em",[e._v("h"),n("sub",[e._v("s")]),e._v(" < h"),n("sub",[e._v("p")])]),e._v(", and\n"),n("em",[e._v("h"),n("sub",[e._v("p")])]),e._v(" is the highest height\nany correct full node has reached so far.")]),e._v(" "),n("p",[e._v("The correct full nodes that reached "),n("em",[e._v("h"),n("sub",[e._v("p")])]),e._v(" were able to decide for "),n("em",[e._v("h"),n("sub",[e._v("p")]),e._v("-1")]),e._v(".\nTherefore, less than "),n("em",[e._v("n"),n("sub",[e._v("h"),n("sub",[e._v("p")]),e._v("-1")]),e._v("/3")]),e._v(" validators of "),n("em",[e._v("h"),n("sub",[e._v("p")]),e._v("-1")]),e._v(" can be part\nof "),n("em",[e._v("L"),n("sub",[e._v("h"),n("sub",[e._v("p")])])]),e._v(", since enough up-to-date validators needed to actively participate\nin consensus for "),n("em",[e._v("h"),n("sub",[e._v("p")]),e._v("-1")]),e._v(".")]),e._v(" "),n("p",[e._v("Since, at the present time,\nno node in "),n("em",[e._v("L"),n("sub",[e._v("h"),n("sub",[e._v("p")])])]),e._v(" took part in any consensus between\n"),n("em",[e._v("h"),n("sub",[e._v("s")])]),e._v(" and "),n("em",[e._v("h"),n("sub",[e._v("p")]),e._v("-1")]),e._v(",\nthe reasoning above can be extended to validator set changes between "),n("em",[e._v("h"),n("sub",[e._v("s")])]),e._v(" and\n"),n("em",[e._v("h"),n("sub",[e._v("p")]),e._v("-1")]),e._v(". This results in the following restriction on the full nodes that can be part of "),n("em",[e._v("L"),n("sub",[e._v("h"),n("sub",[e._v("p")])])]),e._v(".")]),e._v(" "),n("ul",[n("li",[e._v("∀ "),n("em",[e._v("h")]),e._v(", where "),n("em",[e._v("h"),n("sub",[e._v("s")]),e._v(" ≤ h < h"),n("sub",[e._v("p")])]),e._v(",\n| "),n("em",[e._v("valset"),n("sub",[e._v("h")])]),e._v(" ∩ "),n("em",[e._v("L"),n("sub",[e._v("h"),n("sub",[e._v("p")])])]),e._v("  | "),n("em",[e._v("< n"),n("sub",[e._v("h")]),e._v("/3")])])]),e._v(" "),n("p",[e._v("If this property does not hold for a particular height "),n("em",[e._v("h")]),e._v(", where\n"),n("em",[e._v("h"),n("sub",[e._v("s")]),e._v(" ≤ h < h"),n("sub",[e._v("p")])]),e._v(", Tendermint could not have progressed beyond "),n("em",[e._v("h")]),e._v(" and\ntherefore no full node could have reached "),n("em",[e._v("h"),n("sub",[e._v("p")])]),e._v(" (a contradiction).")]),e._v(" "),n("p",[e._v("These lagging nodes in "),n("em",[e._v("L"),n("sub",[e._v("h"),n("sub",[e._v("p")])])]),e._v(" need to catch up. They have to obtain the\ninformation needed to make\nprogress from other nodes. For each height "),n("em",[e._v("h")]),e._v(" between "),n("em",[e._v("h"),n("sub",[e._v("s")])]),e._v(" and "),n("em",[e._v("h"),n("sub",[e._v("p")]),e._v("-2")]),e._v(",\nthis includes the decided block for "),n("em",[e._v("h")]),e._v(", and the\nprecommit votes also for "),n("em",[e._v("deciding h")]),e._v(" (which can be extracted from the block at height "),n("em",[e._v("h+1")]),e._v(").")]),e._v(" "),n("p",[e._v("At a given height  "),n("em",[e._v("h"),n("sub",[e._v("c")])]),e._v(" (where possibly "),n("em",[e._v("h"),n("sub",[e._v("c")]),e._v(" << h"),n("sub",[e._v("p")])]),e._v("),\na full node in "),n("em",[e._v("L"),n("sub",[e._v("h"),n("sub",[e._v("p")])])]),e._v(" will consider itself "),n("em",[e._v("caught up")]),e._v(", based on the\n(maybe out of date) information it is getting from its peers. Then, the node needs to be ready to\npropose at height "),n("em",[e._v("h"),n("sub",[e._v("c")]),e._v("+1")]),e._v(", which requires having received the vote extensions for\n"),n("em",[e._v("h"),n("sub",[e._v("c")])]),e._v(".\nAs the vote extensions are "),n("em",[e._v("not")]),e._v(" stored in the blocks, and it is difficult to have strong\nguarantees on "),n("em",[e._v("when")]),e._v(" a late node considers itself caught up, providing the late node with the right\nvote extensions for the right height poses a problem.")])])]),e._v(" "),n("p",[e._v("At this point, we have described and compared all cases raised in discussions leading up to this\nRFC. The list above aims at being exhaustive. The analysis of each case included above makes all of\nthem converge into case (h).")]),e._v(" "),n("h3",{attrs:{id:"current-catch-up-mechanisms"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#current-catch-up-mechanisms"}},[e._v("#")]),e._v(" Current Catch-up Mechanisms")]),e._v(" "),n("p",[e._v("We now briefly describe the current catch-up mechanisms in the reactors concerned in Tendermint.")]),e._v(" "),n("h4",{attrs:{id:"statesync"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#statesync"}},[e._v("#")]),e._v(" Statesync")]),e._v(" "),n("p",[e._v('Full nodes optionally run statesync just after starting, when they start from scratch.\nIf statesync succeeds, an Application snapshot is installed, and Tendermint jumps from height 0 directly\nto the height the Application snapshop represents, without applying the block of any previous height.\nSome light blocks are received and stored in the block store for running light-client verification of\nall the skipped blocks. Light blocks are incomplete blocks, typically containing the header and the\ncanonical commit but, e.g., no transactions. They are stored in the block store as "signed headers".')]),e._v(" "),n("p",[e._v("The statesync reactor is not really relevant for solving the problem discussed in this RFC. We will\nnevertheless mention it when needed; in particular, to understand some corner cases.")]),e._v(" "),n("h4",{attrs:{id:"blocksync"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#blocksync"}},[e._v("#")]),e._v(" Blocksync")]),e._v(" "),n("p",[e._v("The blocksync reactor kicks in after start up or recovery (and, optionally, after statesync is done)\nand sends the following messages to its peers:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("StatusRequest")]),e._v(" to query the height its peers are currently at, and")]),e._v(" "),n("li",[n("code",[e._v("BlockRequest")]),e._v(", asking for blocks of heights the local node is missing.")])]),e._v(" "),n("p",[e._v("Using "),n("code",[e._v("BlockResponse")]),e._v(" messages received from peers, the blocksync reactor validates each received\nblock using the block of the following height, saves the block in the block store, and sends the\nblock to the Application for execution.")]),e._v(" "),n("p",[e._v("If blocksync has validated and applied the block for the height "),n("em",[e._v("previous")]),e._v(" to the highest seen in\na "),n("code",[e._v("StatusResponse")]),e._v(" message, or if no progress has been made after a timeout, the node considers\nitself as caught up and switches to the consensus reactor.")]),e._v(" "),n("h4",{attrs:{id:"consensus-reactor"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#consensus-reactor"}},[e._v("#")]),e._v(" Consensus Reactor")]),e._v(" "),n("p",[e._v("The consensus reactor runs the full Tendermint algorithm. For a validator this means it has to\npropose blocks, and send/receive prevote/precommit messages, as mandated by Tendermint, before it can\ndecide and move on to the next height.")]),e._v(" "),n("p",[e._v("If a full node that is running the consensus reactor falls behind at height "),n("em",[e._v("h")]),e._v(", when a peer node\nrealises this it will retrieve the canonical commit of "),n("em",[e._v("h+1")]),e._v(" from the block store, and "),n("em",[e._v("convert")]),e._v("\nit into a set of precommit votes and will send those to the late node.")]),e._v(" "),n("h2",{attrs:{id:"discussion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#discussion"}},[e._v("#")]),e._v(" Discussion")]),e._v(" "),n("h3",{attrs:{id:"solutions-proposed"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#solutions-proposed"}},[e._v("#")]),e._v(" Solutions Proposed")]),e._v(" "),n("p",[e._v("These are the solutions proposed in discussions leading up to this RFC.")]),e._v(" "),n("ul",[n("li",[n("p",[n("strong",[e._v("Solution 0.")]),e._v(" "),n("em",[e._v("Vote extensions are made "),n("strong",[e._v("best effort")]),e._v(" in the specification")]),e._v(".")]),e._v(" "),n("p",[e._v("This is the simplest solution, considered as a way to provide vote extensions in a simple enough\nway so that it can be part of v0.36.\nIt consists in changing the specification so as to not "),n("em",[e._v("require")]),e._v(" that precommit votes used upon\n"),n("code",[e._v("PrepareProposal")]),e._v(" contain their corresponding vote extensions. In other words, we render vote\nextensions optional.\nThere are strong implications stemming from such a relaxation of the original specification.")]),e._v(" "),n("ul",[n("li",[e._v("As a vote extension is signed "),n("em",[e._v("separately")]),e._v(" from the vote it is extending, an intermediate node\ncan now remove (i.e., censor) vote extensions from precommit messages at will.")]),e._v(" "),n("li",[e._v("Further, there is no point anymore in the spec requiring the Application to accept a vote extension\npassed via "),n("code",[e._v("VerifyVoteExtension")]),e._v(" to consider a precommit message valid in its entirety. Remember\nthis behavior of "),n("code",[e._v("VerifyVoteExtension")]),e._v(" is adding a constraint to Tendermint's conditions for\nliveness.\nIn this situation, it is better and simpler to just drop the vote extension rejected by the\nApplication via "),n("code",[e._v("VerifyVoteExtension")]),e._v(", but still consider the precommit vote itself valid as long\nas its signature verifies.")])])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Solution 1.")]),e._v(" "),n("em",[e._v("Include vote extensions in the blockchain")]),e._v(".")]),e._v(" "),n("p",[e._v("Another obvious solution, which has somehow been considered in the past, is to include the vote\nextensions and their signatures in the blockchain.\nThe blockchain would thus include the extended commit, rather than a regular commit, as the structure\nto be canonicalized in the next block.\nWith this solution, the current mechanisms implemented both in the blocksync and consensus reactors\nwould still be correct, as all the information a node needs to catch up, and to start proposing when\nit considers itself as caught-up, can now be recovered from past blocks saved in the block store.")]),e._v(" "),n("p",[e._v("This solution has two main drawbacks.")]),e._v(" "),n("ul",[n("li",[e._v("As the block format must change, upgrading a chain requires a hard fork. Furthermore,\nall existing light client implementations will stop working until they are upgraded to deal with\nthe new format (e.g., how certain hashes calculated and/or how certain signatures are checked).\nFor instance, let us consider IBC, which relies on light clients. An IBC connection between\ntwo chains will be broken if only one chain upgrades.")]),e._v(" "),n("li",[e._v("The extra information (i.e., the vote extensions) that is now kept in the blockchain is not really\nneeded "),n("em",[e._v("at every height")]),e._v(" for a late node to catch up.\n"),n("ul",[n("li",[e._v("This information is only needed to be able to "),n("em",[e._v("propose")]),e._v(" at the height the validator considers\nitself as caught-up. If a validator is indeed late for height "),n("em",[e._v("h")]),e._v(", it is useless (although\ncorrect) for it to call "),n("code",[e._v("PrepareProposal")]),e._v(", or "),n("code",[e._v("ExtendVote")]),e._v(", since the block is already decided.")]),e._v(" "),n("li",[e._v("Moreover, some use cases require pretty sizeable vote extensions, which would result in an\nimportant waste of space in the blockchain.")])])])])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Solution 2.")]),e._v(" "),n("em",[e._v("Skip")]),e._v(" propose "),n("em",[e._v("step in Tendermint algorithm")]),e._v(".")]),e._v(" "),n("p",[e._v("This solution consists in modifying the Tendermint algorithm to skip the "),n("em",[e._v("send proposal")]),e._v(" step in\nheights where the node does not have the required vote extensions to populate the call to\n"),n("code",[e._v("PrepareProposal")]),e._v(". The main idea behind this is that it should only happen when the validator is late\nand, therefore, up-to-date validators have already proposed (and decided) for that height.\nA small variation of this solution is, rather than skipping the "),n("em",[e._v("send proposal")]),e._v(" step, the validator\nsends a special "),n("em",[e._v("empty")]),e._v(" or "),n("em",[e._v("bottom")]),e._v(" (⊥) proposal to signal other nodes that it is not ready to propose\nat (any round of) the current height.")]),e._v(" "),n("p",[e._v("The appeal of this solution is its simplicity. A possible implementation does not need to extend\nthe data structures, or change the current catch-up mechanisms implemented in the blocksync or\nin the consensus reactor. When we lack the needed information (vote extensions), we simply rely\non another correct validator to propose a valid block in other rounds of the current height.")]),e._v(" "),n("p",[e._v("However, this solution can be attacked by a byzantine node in the network in the following way.\nLet us consider the following scenario:")]),e._v(" "),n("ul",[n("li",[e._v("all validators in "),n("em",[e._v("valset"),n("sub",[e._v("h")])]),e._v(" send out precommit messages, with vote extensions,\nfor height "),n("em",[e._v("h")]),e._v(", round 0, roughly at the same time,")]),e._v(" "),n("li",[e._v("all those precommit messages contain non-"),n("code",[e._v("nil")]),e._v(" precommit votes, which vote for block "),n("em",[e._v("b")])]),e._v(" "),n("li",[e._v("all those precommit messages sent in height "),n("em",[e._v("h")]),e._v(", round 0, and all messages sent in\nheight "),n("em",[e._v("h")]),e._v(", round "),n("em",[e._v("r > 0")]),e._v(" get delayed indefinitely, so,")]),e._v(" "),n("li",[e._v("all validators in "),n("em",[e._v("valset"),n("sub",[e._v("h")])]),e._v(" keep waiting for enough precommit\nmessages for height "),n("em",[e._v("h")]),e._v(", round 0, needed for deciding in height "),n("em",[e._v("h")])]),e._v(" "),n("li",[e._v("an intermediate (malicious) full node "),n("em",[e._v("m")]),e._v(" manages to receive block "),n("em",[e._v("b")]),e._v(", and gather more than\n"),n("em",[e._v("2n"),n("sub",[e._v("h")]),e._v("/3")]),e._v(" precommit messages for height "),n("em",[e._v("h")]),e._v(", round 0,")]),e._v(" "),n("li",[e._v("one way or another, the solution should have either (a) a mechanism for a full node to "),n("em",[e._v("tell")]),e._v("\nanother full node it is late, or (b) a mechanism for a full node to conclude it is late based\non other full nodes' messages; any of these mechanisms should, at the very least,\nrequire the late node receiving the decided block and a commit (not necessarily an extended\ncommit) for "),n("em",[e._v("h")]),e._v(",")]),e._v(" "),n("li",[e._v("node "),n("em",[e._v("m")]),e._v(" uses the gathered precommit messages to build a commit for height "),n("em",[e._v("h")]),e._v(", round 0,")]),e._v(" "),n("li",[e._v("in order to convince full nodes that they are late, node "),n("em",[e._v("m")]),e._v(" either (a) "),n("em",[e._v("tells")]),e._v(" them they\nare late, or (b) shows them it (i.e. "),n("em",[e._v("m")]),e._v(") is ahead, by sending them block "),n("em",[e._v("b")]),e._v(", along with the\ncommit for height "),n("em",[e._v("h")]),e._v(", round 0,")]),e._v(" "),n("li",[e._v("all full nodes conclude they are late from "),n("em",[e._v("m")]),e._v("'s behavior, and use block "),n("em",[e._v("b")]),e._v(" and the commit for\nheight "),n("em",[e._v("h")]),e._v(", round 0, to decide on height "),n("em",[e._v("h")]),e._v(", and proceed to height "),n("em",[e._v("h+1")]),e._v(".")])]),e._v(" "),n("p",[e._v("At this point, "),n("em",[e._v("all")]),e._v(" full nodes, including all validators in "),n("em",[e._v("valset"),n("sub",[e._v("h+1")])]),e._v(", have advanced\nto height "),n("em",[e._v("h+1")]),e._v(" believing they are late, and so, expecting the "),n("em",[e._v("hypothetical")]),e._v(" leading majority of\nvalidators in "),n("em",[e._v("valset"),n("sub",[e._v("h+1")])]),e._v(" to propose for "),n("em",[e._v("h+1")]),e._v(". As a result, the blockhain\ngrinds to a halt.\nA (rather complex) ad-hoc mechanism would need to be carried out by node operators to roll\nback all validators to the precommit step of height "),n("em",[e._v("h")]),e._v(", round "),n("em",[e._v("r")]),e._v(", so that they can regenerate\nvote extensions (remember vote extensions are non-deterministic) and continue execution.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Solution 3.")]),e._v(" "),n("em",[e._v("Require extended commits to be available at switching time")]),e._v(".")]),e._v(" "),n("p",[e._v("This one is more involved than all previous solutions, and builds on an idea present in Solution 2:\nvote extensions are actually not needed for Tendermint to make progress as long as the\nvalidator is "),n("em",[e._v("certain")]),e._v(" it is late.")]),e._v(" "),n("p",[e._v("We define two modes. The first is denoted "),n("em",[e._v("catch-up mode")]),e._v(", and Tendermint only calls\n"),n("code",[e._v("FinalizeBlock")]),e._v(" for each height when in this mode. The second is denoted "),n("em",[e._v("consensus mode")]),e._v(", in\nwhich the validator considers itself up to date and fully participates in consensus and calls\n"),n("code",[e._v("PrepareProposal")]),e._v("/"),n("code",[e._v("ProcessProposal")]),e._v(", "),n("code",[e._v("ExtendVote")]),e._v(", and "),n("code",[e._v("VerifyVoteExtension")]),e._v(", before calling\n"),n("code",[e._v("FinalizeBlock")]),e._v(".")]),e._v(" "),n("p",[e._v("The catch-up mode does not need vote extension information to make progress, as all it needs is the\ndecided block at each height to call "),n("code",[e._v("FinalizeBlock")]),e._v(" and keep the state-machine replication making\nprogress. The consensus mode, on the other hand, does need vote extension information when\nstarting every height.")]),e._v(" "),n("p",[e._v("Validators are in consensus mode by default. When a validator in consensus mode falls behind\nfor whatever reason, e.g. cases (b), (d), (e), (f), (g), or (h) above, we introduce the following\nkey safety property:")]),e._v(" "),n("ul",[n("li",[e._v("for every height "),n("em",[e._v("h"),n("sub",[e._v("p")])]),e._v(", a full node "),n("em",[e._v("f")]),e._v(" in "),n("em",[e._v("h"),n("sub",[e._v("p")])]),e._v(" refuses to switch to catch-up\nmode "),n("strong",[e._v("until")]),e._v(" there exists a height "),n("em",[e._v("h'")]),e._v(" such that:\n"),n("ul",[n("li",[n("em",[e._v("p")]),e._v(" has received and (light-client) verified the blocks of\nall heights "),n("em",[e._v("h")]),e._v(", where "),n("em",[e._v("h"),n("sub",[e._v("p")]),e._v(" ≤ h ≤ h'")])]),e._v(" "),n("li",[e._v("it has received an extended commit for "),n("em",[e._v("h'")]),e._v(" and has verified:\n"),n("ul",[n("li",[e._v("the precommit vote signatures in the extended commit")]),e._v(" "),n("li",[e._v("the vote extension signatures in the extended commit: each is signed with the same\nkey as the precommit vote it extends")])])])])])]),e._v(" "),n("p",[e._v("If the condition above holds for "),n("em",[e._v("h"),n("sub",[e._v("p")])]),e._v(", namely receiving a valid sequence of blocks in\nthe "),n("em",[e._v("f")]),e._v("'s future, and an extended commit corresponding to the last block in the sequence, then\nnode "),n("em",[e._v("f")]),e._v(":")]),e._v(" "),n("ul",[n("li",[e._v("switches to catch-up mode,")]),e._v(" "),n("li",[e._v("applies all blocks between "),n("em",[e._v("h"),n("sub",[e._v("p")])]),e._v(" and "),n("em",[e._v("h'")]),e._v(" (calling "),n("code",[e._v("FinalizeBlock")]),e._v(" only), and")]),e._v(" "),n("li",[e._v("switches back to consensus mode using the extended commit for "),n("em",[e._v("h'")]),e._v(" to propose in the rounds of\n"),n("em",[e._v("h' + 1")]),e._v(" where it is the proposer.")])]),e._v(" "),n("p",[e._v("This mechanism, together with the invariant it uses, ensures that the node cannot be attacked by\nbeing fed a block without extensions to make it believe it is late, in a similar way as explained\nfor Solution 2.")])])]),e._v(" "),n("h3",{attrs:{id:"feasibility-of-the-proposed-solutions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#feasibility-of-the-proposed-solutions"}},[e._v("#")]),e._v(" Feasibility of the Proposed Solutions")]),e._v(" "),n("p",[e._v("Solution 0, besides the drawbacks described in the previous section, provides guarantees that are\nweaker than the rest. The Application does not have the assurance that more than "),n("em",[e._v("2n"),n("sub",[e._v("h")]),e._v("/3")]),e._v(" vote\nextensions will "),n("em",[e._v("always")]),e._v(" be available when calling "),n("code",[e._v("PrepareProposal")]),e._v(" at height "),n("em",[e._v("h+1")]),e._v(".\nThis level of guarantees is probably not strong enough for vote extensions to be useful for some\nimportant use cases that motivated them in the first place, e.g., encrypted mempool transactions.")]),e._v(" "),n("p",[e._v("Solution 1, while being simple in that the changes needed in the current Tendermint codebase would\nbe rather small, is changing the block format, and would therefore require all blockchains using\nTendermint v0.35 or earlier to hard-fork when upgrading to v0.36.")]),e._v(" "),n("p",[e._v("Since Solution 2 can be attacked, one might prefer Solution 3, even if it is more involved\nto implement. Further, we must elaborate on how we can turn Solution 3, described in abstract\nterms in the previous section, into a concrete implementation compatible with the current\nTendermint codebase.")]),e._v(" "),n("h3",{attrs:{id:"current-limitations-and-possible-implementations"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#current-limitations-and-possible-implementations"}},[e._v("#")]),e._v(" Current Limitations and Possible Implementations")]),e._v(" "),n("p",[e._v("The main limitations affecting the current version of Tendermint are the following.")]),e._v(" "),n("ul",[n("li",[e._v("The current version of the blocksync reactor does not use the full\n"),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/4743a7ad0/spec/light-client/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("light client verification"),n("OutboundLink")],1),e._v("\nalgorithm to validate blocks coming from other peers.")]),e._v(" "),n("li",[e._v("The code being structured into the blocksync and consensus reactors, only switching from the\nblocksync reactor to the consensus reactor is supported; switching in the opposite direction is\nnot supported. Alternatively, the consensus reactor could have a mechanism allowing a late node\nto catch up by skipping calls to "),n("code",[e._v("PrepareProposal")]),e._v("/"),n("code",[e._v("ProcessProposal")]),e._v(", and\n"),n("code",[e._v("ExtendVote")]),e._v("/"),n("code",[e._v("VerifyVoteExtension")]),e._v(" and only calling "),n("code",[e._v("FinalizeBlock")]),e._v(" for each height.\nSuch a mechanism does not exist at the time of writing this RFC.")])]),e._v(" "),n("p",[e._v("The blocksync reactor featuring light client verification is being actively worked on (tentatively\nfor v0.37). So it is best if this RFC does not try to delve into that problem, but just makes sure\nits outcomes are compatible with that effort.")]),e._v(" "),n("p",[e._v("In subsection "),n("a",{attrs:{href:"#cases-to-address"}},[e._v("Cases to Address")]),e._v(", we concluded that we can focus on\nsolving case (h) in theoretical terms.\nHowever, as the current Tendermint version does not yet support switching back to blocksync once a\nnode has switched to consensus, we need to split case (h) into two cases. When a full node needs to\ncatch up...")]),e._v(" "),n("ul",[n("li",[n("p",[n("strong",[e._v("(h.1)")]),e._v(" ... it has not switched yet from the blocksync reactor to the consensus reactor, or")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("(h.2)")]),e._v(" ... it has already switched to the consensus reactor.")])])]),e._v(" "),n("p",[e._v("This is important in order to discuss the different possible implementations.")]),e._v(" "),n("h4",{attrs:{id:"base-implementation-persist-and-propagate-extended-commit-history"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#base-implementation-persist-and-propagate-extended-commit-history"}},[e._v("#")]),e._v(" Base Implementation: Persist and Propagate Extended Commit History")]),e._v(" "),n("p",[e._v("In order to circumvent the fact that we cannot switch from the consensus reactor back to blocksync,\nrather than just keeping the few most recent extended commits, nodes will need to keep\nand gossip a backlog of extended commits so that the consensus reactor can still propose and decide\nin out-of-date heights (even if those proposals will be useless).")]),e._v(" "),n("p",[e._v("The base implementation － for which an experimental patch exists － consists in the conservative\napproach of persisting in the block store "),n("em",[e._v("all")]),e._v(" extended commits for which we have also stored\nthe full block. Currently, when statesync is run at startup, it saves light blocks.\nThis base implementation does not seek\nto receive or persist extended commits for those light blocks as they would not be of any use.")]),e._v(" "),n("p",[e._v("Then, we modify the blocksync reactor so that peers "),n("em",[e._v("always")]),e._v(" send requested full blocks together\nwith the corresponding extended commit in the "),n("code",[e._v("BlockResponse")]),e._v(" messages. This guarantees that the\nblock store being reconstructed by blocksync has the same information as that of peers that are\nup to date (at least starting from the latest snapshot applied by statesync before starting blocksync).\nThus, blocksync has all the data it requires to switch to the consensus reactor, as long as one of\nthe following exit conditions are met:")]),e._v(" "),n("ul",[n("li",[e._v("The node is still at height 0 (where no commit or extended commit is needed)")]),e._v(" "),n("li",[e._v("The node has processed at least 1 block in blocksync")])]),e._v(" "),n("p",[e._v("The second condition is needed in case the node has installed an Application snapshot during statesync.\nIf that is the case, at the time blocksync starts, the block store only has the data statesync has saved:\nlight blocks, and no extended commits.\nHence we need to blocksync at least one block from another node, which will be sent with its corresponding extended commit, before we can switch to consensus.")]),e._v(" "),n("p",[e._v("As a side note, a chain might be started at a height "),n("em",[e._v("h"),n("sub",[e._v("i")]),e._v(" > 0")]),e._v(", all other heights\n"),n("em",[e._v("h < h"),n("sub",[e._v("i")])]),e._v(" being non-existent. In this case, the chain is still considered to be at height 0 before\nblock "),n("em",[e._v("h"),n("sub",[e._v("i")])]),e._v(" is applied, so the first condition above allows the node to switch to consensus even\nif blocksync has not processed any block (which is always the case if all nodes are starting from scratch).")]),e._v(" "),n("p",[e._v("When a validator falls behind while having already switched to the consensus reactor, a peer node can\nsimply retrieve the extended commit for the required height from the block store and reconstruct a set of\nprecommit votes together with their extensions and send them in the form of precommit messages to the\nvalidator falling behind, regardless of whether the peer node holds the extended commit because it\nactually participated in that consensus and thus received the precommit messages, or it received the extended commit via a "),n("code",[e._v("BlockResponse")]),e._v(" message while running blocksync.")]),e._v(" "),n("p",[e._v("This solution requires a few changes to the consensus reactor:")]),e._v(" "),n("ul",[n("li",[e._v("upon saving the block for a given height in the block store at decision time, save the\ncorresponding extended commit as well")]),e._v(" "),n("li",[e._v("in the catch-up mechanism, when a node realizes that another peer is more than 2 heights\nbehind, it uses the extended commit (rather than the canoncial commit as done previously) to\nreconstruct the precommit votes with their corresponding extensions")])]),e._v(" "),n("p",[e._v("The changes to the blocksync reactor are more substantial:")]),e._v(" "),n("ul",[n("li",[e._v("the "),n("code",[e._v("BlockResponse")]),e._v(" message is extended to include the extended commit of the same height as\nthe block included in the response (just as they are stored in the block store)")]),e._v(" "),n("li",[e._v("structure "),n("code",[e._v("bpRequester")]),e._v(" is likewise extended to hold the received extended commits coming in\n"),n("code",[e._v("BlockResponse")]),e._v(" messages")]),e._v(" "),n("li",[e._v("method "),n("code",[e._v("PeekTwoBlocks")]),e._v(" is modified to also return the extended commit corresponding to the first block")]),e._v(" "),n("li",[e._v("when successfully verifying a received block, the reactor saves its corresponding extended commit in\nthe block store")])]),e._v(" "),n("p",[e._v("The two main drawbacks of this base implementation are:")]),e._v(" "),n("ul",[n("li",[e._v("the increased size taken by the block store, in particular with big extensions")]),e._v(" "),n("li",[e._v("the increased bandwith taken by the new format of "),n("code",[e._v("BlockResponse")])])]),e._v(" "),n("h4",{attrs:{id:"possible-optimization-pruning-the-extended-commit-history"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#possible-optimization-pruning-the-extended-commit-history"}},[e._v("#")]),e._v(" Possible Optimization: Pruning the Extended Commit History")]),e._v(" "),n("p",[e._v("If we cannot switch from the consensus reactor back to the blocksync reactor we cannot prune the extended commit backlog in the block store without sacrificing the implementation's correctness. The asynchronous\nnature of our distributed system model allows a process to fall behing an arbitrary number of\nheights, and thus all extended commits need to be kept "),n("em",[e._v("just in case")]),e._v(" a node that late had\npreviously switched to the consensus reactor.")]),e._v(" "),n("p",[e._v("However, there is a possibility to optimize the base implementation. Every time we enter a new height,\nwe could prune from the block store all extended commits that are more than "),n("em",[e._v("d")]),e._v(" heights in the past.\nThen, we need to handle two new situations, roughly equivalent to cases (h.1) and (h.2) described above.")]),e._v(" "),n("ul",[n("li",[e._v("(h.1) A node starts from scratch or recovers after a crash. In thisy case, we need to modify the\nblocksync reactor's base implementation.\n"),n("ul",[n("li",[e._v("when receiving a "),n("code",[e._v("BlockResponse")]),e._v(" message, it MUST accept that the extended commit set to "),n("code",[e._v("nil")]),e._v(",")]),e._v(" "),n("li",[e._v("when sending a "),n("code",[e._v("BlockResponse")]),e._v(" message, if the block store contains the extended commit for that\nheight, it MUST set it in the message, otherwise it sets it to "),n("code",[e._v("nil")]),e._v(",")]),e._v(" "),n("li",[e._v("the exit conditions used for the base implementation are no longer valid; the only reliable exit\ncondition now consists in making sure that the last block processed by blocksync was received with\nthe corresponding commit, and not "),n("code",[e._v("nil")]),e._v("; this extended commit will allow the node to switch from\nthe blocksync reactor to the consensus reactor and immediately act as a proposer if required.")])])]),e._v(" "),n("li",[e._v("(h.2) A node already running the consensus reactor falls behind beyond "),n("em",[e._v("d")]),e._v(" heights. In principle,\nthe node will be stuck forever as no other node can provide the vote extensions it needs to make\nprogress (they all have pruned the corresponding extended commit).\nHowever we can manually have the node crash and recover as a workaround. This effectively converts\nthis case into (h.1).")])]),e._v(" "),n("h3",{attrs:{id:"formalization-work"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#formalization-work"}},[e._v("#")]),e._v(" Formalization Work")]),e._v(" "),n("p",[e._v("A formalization work to show or prove the correctness of the different use cases and solutions\npresented here (and any other that may be found) needs to be carried out.\nA question that needs a precise answer is how many extended commits (one?, two?) a node needs\nto keep in persistent memory when implementing Solution 3 described above without Tendermint's\ncurrent limitations.\nAnother important invariant we need to prove formally is that the set of vote extensions\nrequired to make progress will always be held somewhere in the network.")]),e._v(" "),n("h2",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/4743a7ad0/spec/abci%2B%2B/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ABCI++ specification"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/tendermint/spec/blob/4fb99af/spec/abci/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ABCI as of v0.35"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/8174",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vote extensions issue"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/4743a7ad0/spec/light-client/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Light client verification"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=s.exports}}]);