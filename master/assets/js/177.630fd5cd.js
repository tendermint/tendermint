(window.webpackJsonp=window.webpackJsonp||[]).push([[177],{753:function(e,t,o){"use strict";o.r(t);var a=o(1),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"requirements-for-the-application"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#requirements-for-the-application"}},[e._v("#")]),e._v(" Requirements for the Application")]),e._v(" "),o("h2",{attrs:{id:"formal-requirements"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#formal-requirements"}},[e._v("#")]),e._v(" Formal Requirements")]),e._v(" "),o("p",[e._v("This section specifies what Tendermint expects from the Application. It is structured as a set\nof formal requirements that can be used for testing and verification of the Application's logic.")]),e._v(" "),o("p",[e._v("Let "),o("em",[e._v("p")]),e._v(" and "),o("em",[e._v("q")]),e._v(" be two correct processes.\nLet "),o("em",[e._v("r"),o("sub",[e._v("p")])]),e._v(" (resp. "),o("em",[e._v("r"),o("sub",[e._v("q")])]),e._v(") be a round of height "),o("em",[e._v("h")]),e._v(" where "),o("em",[e._v("p")]),e._v(" (resp. "),o("em",[e._v("q")]),e._v(") is the\nproposer.\nLet "),o("em",[e._v("s"),o("sub",[e._v("p,h-1")])]),e._v(" be "),o("em",[e._v("p")]),e._v("'s Application's state committed for height "),o("em",[e._v("h-1")]),e._v(".\nLet "),o("em",[e._v("v"),o("sub",[e._v("p")])]),e._v(" (resp. "),o("em",[e._v("v"),o("sub",[e._v("q")])]),e._v(") be the block that "),o("em",[e._v("p")]),e._v("'s (resp. "),o("em",[e._v("q")]),e._v("'s) Tendermint passes\non to the Application\nvia "),o("code",[e._v("RequestPrepareProposal")]),e._v(" as proposer of round "),o("em",[e._v("r"),o("sub",[e._v("p")])]),e._v(" (resp "),o("em",[e._v("r"),o("sub",[e._v("q")])]),e._v("), height "),o("em",[e._v("h")]),e._v(",\nalso known as the raw proposal.\nLet "),o("em",[e._v("u"),o("sub",[e._v("p")])]),e._v(" (resp. "),o("em",[e._v("u"),o("sub",[e._v("q")])]),e._v(") the possibly modified block "),o("em",[e._v("p")]),e._v("'s (resp. "),o("em",[e._v("q")]),e._v("'s) Application\nreturns via "),o("code",[e._v("ResponsePrepareProposal")]),e._v(" to Tendermint, also known as the prepared proposal.")]),e._v(" "),o("p",[e._v("Process "),o("em",[e._v("p")]),e._v("'s prepared proposal can differ in two different rounds where "),o("em",[e._v("p")]),e._v(" is the proposer.")]),e._v(" "),o("ul",[o("li",[e._v("Requirement 1 ["),o("code",[e._v("PrepareProposal")]),e._v(", header-changes]: When the blockchain is in same-block execution mode,\n"),o("em",[e._v("p")]),e._v("'s Application provides values for the following parameters in "),o("code",[e._v("ResponsePrepareProposal")]),e._v(":\n"),o("code",[e._v("AppHash")]),e._v(", "),o("code",[e._v("TxResults")]),e._v(", "),o("code",[e._v("ConsensusParams")]),e._v(", "),o("code",[e._v("ValidatorUpdates")]),e._v(". Provided values for\n"),o("code",[e._v("ConsensusParams")]),e._v(" and "),o("code",[e._v("ValidatorUpdates")]),e._v(" MAY be empty to denote that the Application\nwishes to keep the current values.")])]),e._v(" "),o("p",[e._v("Parameters "),o("code",[e._v("AppHash")]),e._v(", "),o("code",[e._v("TxResults")]),e._v(", "),o("code",[e._v("ConsensusParams")]),e._v(", and "),o("code",[e._v("ValidatorUpdates")]),e._v(" are used by Tendermint to\ncompute various hashes in the block header that will finally be part of the proposal.")]),e._v(" "),o("ul",[o("li",[e._v("Requirement 2 ["),o("code",[e._v("PrepareProposal")]),e._v(", no-header-changes]: When the blockchain is in next-block execution\nmode, "),o("em",[e._v("p")]),e._v("'s Application does not provide values for the following parameters in "),o("code",[e._v("ResponsePrepareProposal")]),e._v(":\n"),o("code",[e._v("AppHash")]),e._v(", "),o("code",[e._v("TxResults")]),e._v(", "),o("code",[e._v("ConsensusParams")]),e._v(", "),o("code",[e._v("ValidatorUpdates")]),e._v(".")])]),e._v(" "),o("p",[e._v("In practical terms, Requirements 1 and 2 imply that Tendermint will (a) panic if the Application is in\nsame-block execution mode and "),o("em",[e._v("does not")]),e._v(" provide values for\n"),o("code",[e._v("AppHash")]),e._v(", "),o("code",[e._v("TxResults")]),e._v(", "),o("code",[e._v("ConsensusParams")]),e._v(", and "),o("code",[e._v("ValidatorUpdates")]),e._v(", or\n(b) log an error if the Application is in next-block execution mode and "),o("em",[e._v("does")]),e._v(" provide values for\n"),o("code",[e._v("AppHash")]),e._v(", "),o("code",[e._v("TxResults")]),e._v(", "),o("code",[e._v("ConsensusParams")]),e._v(", or "),o("code",[e._v("ValidatorUpdates")]),e._v(" (the values provided will be ignored).")]),e._v(" "),o("ul",[o("li",[e._v("Requirement 3 ["),o("code",[e._v("PrepareProposal")]),e._v(", timeliness]: If "),o("em",[e._v("p")]),e._v("'s Application fully executes prepared blocks in\n"),o("code",[e._v("PrepareProposal")]),e._v(" and the network is in a synchronous period while processes "),o("em",[e._v("p")]),e._v(" and "),o("em",[e._v("q")]),e._v(" are in "),o("em",[e._v("r"),o("sub",[e._v("p")])]),e._v(",\nthen the value of "),o("em",[e._v("TimeoutPropose")]),e._v(" at "),o("em",[e._v("q")]),e._v(" must be such that "),o("em",[e._v("q")]),e._v("'s propose timer does not time out\n(which would result in "),o("em",[e._v("q")]),e._v(" prevoting "),o("code",[e._v("nil")]),e._v(" in "),o("em",[e._v("r"),o("sub",[e._v("p")])]),e._v(").")])]),e._v(" "),o("p",[e._v("Full execution of blocks at "),o("code",[e._v("PrepareProposal")]),e._v(" time stands on Tendermint's critical path. Thus,\nRequirement 3 ensures the Application will set a value for "),o("code",[e._v("TimeoutPropose")]),e._v(" such that the time it takes\nto fully execute blocks in "),o("code",[e._v("PrepareProposal")]),e._v(" does not interfere with Tendermint's propose timer.\nNote that violation of Requirement 3 may just lead to further rounds, but will not compromise liveness.")]),e._v(" "),o("ul",[o("li",[e._v("Requirement 4 ["),o("code",[e._v("PrepareProposal")]),e._v(", tx-size]: When "),o("em",[e._v("p")]),e._v("'s Application calls "),o("code",[e._v("ResponsePrepareProposal")]),e._v(", the\ntotal size in bytes of the transactions returned does not exceed "),o("code",[e._v("RequestPrepareProposal.max_tx_bytes")]),e._v(".")])]),e._v(" "),o("p",[e._v("Busy blockchains might seek to maximize the amount of transactions included in each block. Under those conditions,\nTendermint might choose to increase the transactions passed to the Application via "),o("code",[e._v("RequestPrepareProposal.txs")]),e._v("\nbeyond the "),o("code",[e._v("RequestPrepareProposal.max_tx_bytes")]),e._v(" limit. The idea is that, if the Application drops some of\nthose transactions, it can still return a transaction list whose byte size is as close to\n"),o("code",[e._v("RequestPrepareProposal.max_tx_bytes")]),e._v(" as possible. Thus, Requirement 4 ensures that the size in bytes of the\ntransaction list returned by the application will never cause the resulting block to go beyond its byte size\nlimit.")]),e._v(" "),o("ul",[o("li",[e._v("Requirement 5 ["),o("code",[e._v("PrepareProposal")]),e._v(", "),o("code",[e._v("ProcessProposal")]),e._v(", coherence]: For any two correct processes "),o("em",[e._v("p")]),e._v(" and "),o("em",[e._v("q")]),e._v(",\nif "),o("em",[e._v("q")]),e._v("'s Tendermint calls "),o("code",[e._v("RequestProcessProposal")]),e._v(" on "),o("em",[e._v("u"),o("sub",[e._v("p")])]),e._v(",\n"),o("em",[e._v("q")]),e._v("'s Application returns Accept in "),o("code",[e._v("ResponseProcessProposal")]),e._v(".")])]),e._v(" "),o("p",[e._v("Requirement 5 makes sure that blocks proposed by correct processes "),o("em",[e._v("always")]),e._v(" pass the correct receiving process's\n"),o("code",[e._v("ProcessProposal")]),e._v(" check.\nOn the other hand, if there is a deterministic bug in "),o("code",[e._v("PrepareProposal")]),e._v(" or "),o("code",[e._v("ProcessProposal")]),e._v(" (or in both),\nstrictly speaking, this makes all processes that hit the bug byzantine. This is a problem in practice,\nas very often validators are running the Application from the same codebase, so potentially "),o("em",[e._v("all")]),e._v(" would\nlikely hit the bug at the same time. This would result in most (or all) processes prevoting "),o("code",[e._v("nil")]),e._v(", with the\nserious consequences on Tendermint's liveness that this entails. Due to its criticality, Requirement 5 is a\ntarget for extensive testing and automated verification.")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("Requirement 6 ["),o("code",[e._v("ProcessProposal")]),e._v(", determinism-1]: "),o("code",[e._v("ProcessProposal")]),e._v(" is a (deterministic) function of the current\nstate and the block that is about to be applied. In other words, for any correct process "),o("em",[e._v("p")]),e._v(", and any arbitrary block "),o("em",[e._v("u")]),e._v(",\nif "),o("em",[e._v("p")]),e._v("'s Tendermint calls "),o("code",[e._v("RequestProcessProposal")]),e._v(" on "),o("em",[e._v("u")]),e._v(" at height "),o("em",[e._v("h")]),e._v(",\nthen "),o("em",[e._v("p")]),e._v("'s Application's acceptance or rejection "),o("strong",[e._v("exclusively")]),e._v(" depends on "),o("em",[e._v("u")]),e._v(" and "),o("em",[e._v("s"),o("sub",[e._v("p,h-1")])]),e._v(".")])]),e._v(" "),o("li",[o("p",[e._v("Requirement 7 ["),o("code",[e._v("ProcessProposal")]),e._v(", determinism-2]: For any two correct processes "),o("em",[e._v("p")]),e._v(" and "),o("em",[e._v("q")]),e._v(", and any arbitrary\nblock "),o("em",[e._v("u")]),e._v(",\nif "),o("em",[e._v("p")]),e._v("'s (resp. "),o("em",[e._v("q")]),e._v("'s) Tendermint calls "),o("code",[e._v("RequestProcessProposal")]),e._v(" on "),o("em",[e._v("u")]),e._v(" at height "),o("em",[e._v("h")]),e._v(",\nthen "),o("em",[e._v("p")]),e._v("'s Application accepts "),o("em",[e._v("u")]),e._v(" if and only if "),o("em",[e._v("q")]),e._v("'s Application accepts "),o("em",[e._v("u")]),e._v(".\nNote that this requirement follows from Requirement 6 and the Agreement property of consensus.")])])]),e._v(" "),o("p",[e._v("Requirements 6 and 7 ensure that all correct processes will react in the same way to a proposed block, even\nif the proposer is Byzantine. However, "),o("code",[e._v("ProcessProposal")]),e._v(" may contain a bug that renders the\nacceptance or rejection of the block non-deterministic, and therefore prevents processes hitting\nthe bug from fulfilling Requirements 6 or 7 (effectively making those processes Byzantine).\nIn such a scenario, Tendermint's liveness cannot be guaranteed.\nAgain, this is a problem in practice if most validators are running the same software, as they are likely\nto hit the bug at the same point. There is currently no clear solution to help with this situation, so\nthe Application designers/implementors must proceed very carefully with the logic/implementation\nof "),o("code",[e._v("ProcessProposal")]),e._v(". As a general rule "),o("code",[e._v("ProcessProposal")]),e._v(" SHOULD always accept the block.")]),e._v(" "),o("p",[e._v("According to the Tendermint algorithm, a correct process can broadcast at most one precommit\nmessage in round "),o("em",[e._v("r")]),e._v(", height "),o("em",[e._v("h")]),e._v(".\nSince, as stated in the "),o("RouterLink",{attrs:{to:"/spec/abci++/abci++_methods.html#extendvote"}},[e._v("Methods")]),e._v(" section, "),o("code",[e._v("ResponseExtendVote")]),e._v("\nis only called when Tendermint\nis about to broadcast a non-"),o("code",[e._v("nil")]),e._v(" precommit message, a correct process can only produce one vote extension\nin round "),o("em",[e._v("r")]),e._v(", height "),o("em",[e._v("h")]),e._v(".\nLet "),o("em",[e._v("e"),o("sup",[e._v("r")]),o("sub",[e._v("p")])]),e._v(" be the vote extension that the Application of a correct process "),o("em",[e._v("p")]),e._v(" returns via\n"),o("code",[e._v("ResponseExtendVote")]),e._v(" in round "),o("em",[e._v("r")]),e._v(", height "),o("em",[e._v("h")]),e._v(".\nLet "),o("em",[e._v("w"),o("sup",[e._v("r")]),o("sub",[e._v("p")])]),e._v(" be the proposed block that "),o("em",[e._v("p")]),e._v("'s Tendermint passes to the Application via "),o("code",[e._v("RequestExtendVote")]),e._v("\nin round "),o("em",[e._v("r")]),e._v(", height "),o("em",[e._v("h")]),e._v(".")],1),e._v(" "),o("ul",[o("li",[e._v("Requirement 8 ["),o("code",[e._v("ExtendVote")]),e._v(", "),o("code",[e._v("VerifyVoteExtension")]),e._v(", coherence]: For any two different correct\nprocesses "),o("em",[e._v("p")]),e._v(" and "),o("em",[e._v("q")]),e._v(", if "),o("em",[e._v("q")]),e._v(" receives "),o("em",[e._v("e"),o("sup",[e._v("r")]),o("sub",[e._v("p")])]),e._v(" from "),o("em",[e._v("p")]),e._v(" in height "),o("em",[e._v("h")]),e._v(", "),o("em",[e._v("q")]),e._v("'s\nApplication returns Accept in "),o("code",[e._v("ResponseVerifyVoteExtension")]),e._v(".")])]),e._v(" "),o("p",[e._v("Requirement 8 constrains the creation and handling of vote extensions in a similar way as Requirement 5\nconstrains the creation and handling of proposed blocks.\nRequirement 8 ensures that extensions created by correct processes "),o("em",[e._v("always")]),e._v(" pass the "),o("code",[e._v("VerifyVoteExtension")]),e._v("\nchecks performed by correct processes receiving those extensions.\nHowever, if there is a (deterministic) bug in "),o("code",[e._v("ExtendVote")]),e._v(" or "),o("code",[e._v("VerifyVoteExtension")]),e._v(" (or in both),\nwe will face the same liveness issues as described for Requirement 5, as Precommit messages with invalid vote\nextensions will be discarded.")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("Requirement 9 ["),o("code",[e._v("VerifyVoteExtension")]),e._v(", determinism-1]: "),o("code",[e._v("VerifyVoteExtension")]),e._v(" is a (deterministic) function of\nthe current state, the vote extension received, and the prepared proposal that the extension refers to.\nIn other words, for any correct process "),o("em",[e._v("p")]),e._v(", and any arbitrary vote extension "),o("em",[e._v("e")]),e._v(", and any arbitrary\nblock "),o("em",[e._v("w")]),e._v(", if "),o("em",[e._v("p")]),e._v("'s (resp. "),o("em",[e._v("q")]),e._v("'s) Tendermint calls "),o("code",[e._v("RequestVerifyVoteExtension")]),e._v(" on "),o("em",[e._v("e")]),e._v(" and "),o("em",[e._v("w")]),e._v(" at height "),o("em",[e._v("h")]),e._v(",\nthen "),o("em",[e._v("p")]),e._v("'s Application's acceptance or rejection "),o("strong",[e._v("exclusively")]),e._v(" depends on "),o("em",[e._v("e")]),e._v(", "),o("em",[e._v("w")]),e._v(" and "),o("em",[e._v("s"),o("sub",[e._v("p,h-1")])]),e._v(".")])]),e._v(" "),o("li",[o("p",[e._v("Requirement 10 ["),o("code",[e._v("VerifyVoteExtension")]),e._v(", determinism-2]: For any two correct processes "),o("em",[e._v("p")]),e._v(" and "),o("em",[e._v("q")]),e._v(",\nand any arbitrary vote extension "),o("em",[e._v("e")]),e._v(", and any arbitrary block "),o("em",[e._v("w")]),e._v(",\nif "),o("em",[e._v("p")]),e._v("'s (resp. "),o("em",[e._v("q")]),e._v("'s) Tendermint calls "),o("code",[e._v("RequestVerifyVoteExtension")]),e._v(" on "),o("em",[e._v("e")]),e._v(" and "),o("em",[e._v("w")]),e._v(" at height "),o("em",[e._v("h")]),e._v(",\nthen "),o("em",[e._v("p")]),e._v("'s Application accepts "),o("em",[e._v("e")]),e._v(" if and only if "),o("em",[e._v("q")]),e._v("'s Application accepts "),o("em",[e._v("e")]),e._v(".\nNote that this requirement follows from Requirement 9 and the Agreement property of consensus.")])])]),e._v(" "),o("p",[e._v("Requirements 9 and 10 ensure that the validation of vote extensions will be deterministic at all\ncorrect processes.\nRequirements 9 and 10 protect against arbitrary vote extension data from Byzantine processes,\nin a similar way as Requirements 6 and 7 protect against arbitrary proposed blocks.\nRequirements 9 and 10 can be violated by a bug inducing non-determinism in\n"),o("code",[e._v("VerifyVoteExtension")]),e._v(". In this case liveness can be compromised.\nExtra care should be put in the implementation of "),o("code",[e._v("ExtendVote")]),e._v(" and "),o("code",[e._v("VerifyVoteExtension")]),e._v(".\nAs a general rule, "),o("code",[e._v("VerifyVoteExtension")]),e._v(" SHOULD always accept the vote extension.")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("Requirement 11 ["),o("em",[e._v("all")]),e._v(", no-side-effects]: "),o("em",[e._v("p")]),e._v("'s calls to "),o("code",[e._v("RequestPrepareProposal")]),e._v(",\n"),o("code",[e._v("RequestProcessProposal")]),e._v(", "),o("code",[e._v("RequestExtendVote")]),e._v(", and "),o("code",[e._v("RequestVerifyVoteExtension")]),e._v(" at height "),o("em",[e._v("h")]),e._v(" do\nnot modify "),o("em",[e._v("s"),o("sub",[e._v("p,h-1")])]),e._v(".")])]),e._v(" "),o("li",[o("p",[e._v("Requirement 12 ["),o("code",[e._v("ExtendVote")]),e._v(", "),o("code",[e._v("FinalizeBlock")]),e._v(", non-dependency]: for any correct process "),o("em",[e._v("p")]),e._v(",\nand any vote extension "),o("em",[e._v("e")]),e._v(" that "),o("em",[e._v("p")]),e._v(" received at height "),o("em",[e._v("h")]),e._v(", the computation of\n"),o("em",[e._v("s"),o("sub",[e._v("p,h")])]),e._v(" does not depend on "),o("em",[e._v("e")]),e._v(".")])])]),e._v(" "),o("p",[e._v("The call to correct process "),o("em",[e._v("p")]),e._v("'s "),o("code",[e._v("RequestFinalizeBlock")]),e._v(" at height "),o("em",[e._v("h")]),e._v(", with block "),o("em",[e._v("v"),o("sub",[e._v("p,h")])]),e._v("\npassed as parameter, creates state "),o("em",[e._v("s"),o("sub",[e._v("p,h")])]),e._v(".\nAdditionally,")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("in next-block execution mode, "),o("em",[e._v("p")]),e._v("'s "),o("code",[e._v("FinalizeBlock")]),e._v(" creates a set of transaction results "),o("em",[e._v("T"),o("sub",[e._v("p,h")])]),e._v(",")])]),e._v(" "),o("li",[o("p",[e._v("in same-block execution mode, "),o("em",[e._v("p")]),e._v("'s "),o("code",[e._v("PrepareProposal")]),e._v(" creates a set of transaction results "),o("em",[e._v("T"),o("sub",[e._v("p,h")])]),e._v("\nif "),o("em",[e._v("p")]),e._v(" was the proposer of "),o("em",[e._v("v"),o("sub",[e._v("p,h")])]),e._v(". If "),o("em",[e._v("p")]),e._v(" was not the proposer of "),o("em",[e._v("v"),o("sub",[e._v("p,h")])]),e._v(",\n"),o("code",[e._v("ProcessProposal")]),e._v(" creates "),o("em",[e._v("T"),o("sub",[e._v("p,h")])]),e._v(". "),o("code",[e._v("FinalizeBlock")]),e._v(" MAY re-create "),o("em",[e._v("T"),o("sub",[e._v("p,h")])]),e._v(" if it was\nremoved from memory during the execution of height "),o("em",[e._v("h")]),e._v(".")])]),e._v(" "),o("li",[o("p",[e._v("Requirement 13 ["),o("code",[e._v("FinalizeBlock")]),e._v(", determinism-1]: For any correct process "),o("em",[e._v("p")]),e._v(",\n"),o("em",[e._v("s"),o("sub",[e._v("p,h")])]),e._v(" exclusively depends on "),o("em",[e._v("s"),o("sub",[e._v("p,h-1")])]),e._v(" and "),o("em",[e._v("v"),o("sub",[e._v("p,h")])]),e._v(".")])]),e._v(" "),o("li",[o("p",[e._v("Requirement 14 ["),o("code",[e._v("FinalizeBlock")]),e._v(", determinism-2]: For any correct process "),o("em",[e._v("p")]),e._v(",\nthe contents of "),o("em",[e._v("T"),o("sub",[e._v("p,h")])]),e._v(" exclusively depend on "),o("em",[e._v("s"),o("sub",[e._v("p,h-1")])]),e._v(" and "),o("em",[e._v("v"),o("sub",[e._v("p,h")])]),e._v(".")])])]),e._v(" "),o("p",[e._v("Note that Requirements 13 and 14, combined with Agreement property of consensus ensure\nstate machine replication, i.e., the Application state evolves consistently at all correct processes.")]),e._v(" "),o("p",[e._v("Finally, notice that neither "),o("code",[e._v("PrepareProposal")]),e._v(" nor "),o("code",[e._v("ExtendVote")]),e._v(" have determinism-related\nrequirements associated.\nIndeed, "),o("code",[e._v("PrepareProposal")]),e._v(" is not required to be deterministic:")]),e._v(" "),o("ul",[o("li",[o("em",[e._v("u"),o("sub",[e._v("p")])]),e._v(" may depend on "),o("em",[e._v("v"),o("sub",[e._v("p")])]),e._v(" and "),o("em",[e._v("s"),o("sub",[e._v("p,h-1")])]),e._v(", but may also depend on other values or operations.")]),e._v(" "),o("li",[o("em",[e._v("v"),o("sub",[e._v("p")]),e._v(" = v"),o("sub",[e._v("q")]),e._v(" ⇏ u"),o("sub",[e._v("p")]),e._v(" = u"),o("sub",[e._v("q")])]),e._v(".")])]),e._v(" "),o("p",[e._v("Likewise, "),o("code",[e._v("ExtendVote")]),e._v(" can also be non-deterministic:")]),e._v(" "),o("ul",[o("li",[o("em",[e._v("e"),o("sup",[e._v("r")]),o("sub",[e._v("p")])]),e._v(" may depend on "),o("em",[e._v("w"),o("sup",[e._v("r")]),o("sub",[e._v("p")])]),e._v(" and "),o("em",[e._v("s"),o("sub",[e._v("p,h-1")])]),e._v(",\nbut may also depend on other values or operations.")]),e._v(" "),o("li",[o("em",[e._v("w"),o("sup",[e._v("r")]),o("sub",[e._v("p")]),e._v(" = w"),o("sup",[e._v("r")]),o("sub",[e._v("q")]),e._v(" ⇏\ne"),o("sup",[e._v("r")]),o("sub",[e._v("p")]),e._v(" = e"),o("sup",[e._v("r")]),o("sub",[e._v("q")])])])]),e._v(" "),o("h2",{attrs:{id:"managing-the-application-state-and-related-topics"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#managing-the-application-state-and-related-topics"}},[e._v("#")]),e._v(" Managing the Application state and related topics")]),e._v(" "),o("h3",{attrs:{id:"connection-state"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#connection-state"}},[e._v("#")]),e._v(" Connection State")]),e._v(" "),o("p",[e._v("Tendermint maintains four concurrent ABCI++ connections, namely\n"),o("a",{attrs:{href:"#consensus-connection"}},[e._v("Consensus Connection")]),e._v(",\n"),o("a",{attrs:{href:"#mempool-connection"}},[e._v("Mempool Connection")]),e._v(",\n"),o("a",{attrs:{href:"#infoquery-connection"}},[e._v("Info/Query Connection")]),e._v(", and\n"),o("a",{attrs:{href:"#snapshot-connection"}},[e._v("Snapshot Connection")]),e._v(".\nIt is common for an application to maintain a distinct copy of\nthe state for each connection, which are synchronized upon "),o("code",[e._v("Commit")]),e._v(" calls.")]),e._v(" "),o("h4",{attrs:{id:"concurrency"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#concurrency"}},[e._v("#")]),e._v(" Concurrency")]),e._v(" "),o("p",[e._v("In principle, each of the four ABCI++ connections operates concurrently with one\nanother. This means applications need to ensure access to state is\nthread safe. Up to v0.35.x, both the\n"),o("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/v0.35.x/abci/client/local_client.go#L18",target:"_blank",rel:"noopener noreferrer"}},[e._v("default in-process ABCI client"),o("OutboundLink")],1),e._v("\nand the\n"),o("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/v0.35.x/abci/server/socket_server.go#L32",target:"_blank",rel:"noopener noreferrer"}},[e._v("default Go ABCI server"),o("OutboundLink")],1),e._v("\nused a global lock to guard the handling of events across all connections, so they were not\nconcurrent at all. This meant whether your app was compiled in-process with\nTendermint using the "),o("code",[e._v("NewLocalClient")]),e._v(", or run out-of-process using the "),o("code",[e._v("SocketServer")]),e._v(",\nABCI messages from all connections were received in sequence, one at a\ntime.\nThis is no longer the case starting from v0.36.0: the global locks have been removed and it is\nup to the Application to synchronize access to its state when handling\nABCI++ methods on all connections.\nNevertheless, as all ABCI calls are now synchronous, ABCI messages using the same connection are\nstill received in sequence.")]),e._v(" "),o("h4",{attrs:{id:"finalizeblock"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#finalizeblock"}},[e._v("#")]),e._v(" FinalizeBlock")]),e._v(" "),o("p",[e._v("When the consensus algorithm decides on a block, Tendermint uses "),o("code",[e._v("FinalizeBlock")]),e._v(" to send the\ndecided block's data to the Application, which uses it to transition its state.")]),e._v(" "),o("p",[e._v("The Application must remember the latest height from which it\nhas run a successful "),o("code",[e._v("Commit")]),e._v(" so that it can tell Tendermint where to\npick up from when it recovers from a crash. See information on the Handshake\n"),o("a",{attrs:{href:"#crash-recovery"}},[e._v("here")]),e._v(".")]),e._v(" "),o("h4",{attrs:{id:"commit"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#commit"}},[e._v("#")]),e._v(" Commit")]),e._v(" "),o("p",[e._v("The Application should persist its state during "),o("code",[e._v("Commit")]),e._v(", before returning from it.")]),e._v(" "),o("p",[e._v("Before invoking "),o("code",[e._v("Commit")]),e._v(", Tendermint locks the mempool and flushes the mempool connection. This ensures that\nno new messages\nwill be received on the mempool connection during this processing step, providing an opportunity to safely\nupdate all four\nconnection states to the latest committed state at the same time.")]),e._v(" "),o("p",[e._v("When "),o("code",[e._v("Commit")]),e._v(" returns, Tendermint unlocks the mempool.")]),e._v(" "),o("p",[e._v("WARNING: if the ABCI app logic processing the "),o("code",[e._v("Commit")]),e._v(" message sends a\n"),o("code",[e._v("/broadcast_tx_sync")]),e._v(" or "),o("code",[e._v("/broadcast_tx")]),e._v(" and waits for the response\nbefore proceeding, it will deadlock. Executing "),o("code",[e._v("broadcast_tx")]),e._v(" calls\ninvolves acquiring the mempool lock that Tendermint holds during the "),o("code",[e._v("Commit")]),e._v(" call.\nSynchronous mempool-related calls must be avoided as part of the sequential logic of the\n"),o("code",[e._v("Commit")]),e._v(" function.")]),e._v(" "),o("h4",{attrs:{id:"candidate-states"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#candidate-states"}},[e._v("#")]),e._v(" Candidate States")]),e._v(" "),o("p",[e._v("Tendermint calls "),o("code",[e._v("PrepareProposal")]),e._v(" when it is about to send a proposed block to the network.\nLikewise, Tendermint calls "),o("code",[e._v("ProcessProposal")]),e._v(" upon reception of a proposed block from the\nnetwork. In both cases, the proposed block's data\nis disclosed to the Application, in the same conditions as is done in "),o("code",[e._v("FinalizeBlock")]),e._v(".\nThe block data disclosed the to Application by these three methods are the following:")]),e._v(" "),o("ul",[o("li",[e._v("the transaction list")]),e._v(" "),o("li",[e._v("the "),o("code",[e._v("LastCommit")]),e._v(" referring to the previous block")]),e._v(" "),o("li",[e._v("the block header's hash (except in "),o("code",[e._v("PrepareProposal")]),e._v(", where it is not known yet)")]),e._v(" "),o("li",[e._v("list of validators that misbehaved")]),e._v(" "),o("li",[e._v("the block's timestamp")]),e._v(" "),o("li",[o("code",[e._v("NextValidatorsHash")])]),e._v(" "),o("li",[e._v("Proposer address")])]),e._v(" "),o("p",[e._v("The Application may decide to "),o("em",[e._v("immediately")]),e._v(" execute the given block (i.e., upon "),o("code",[e._v("PrepareProposal")]),e._v("\nor "),o("code",[e._v("ProcessProposal")]),e._v("). There are two main reasons why the Application may want to do this:")]),e._v(" "),o("ul",[o("li",[o("em",[e._v("Avoiding invalid transactions in blocks")]),e._v(".\nIn order to be sure that the block does not contain "),o("em",[e._v("any")]),e._v(" invalid transaction, there may be\nno way other than fully executing the transactions in the block as though it was the "),o("em",[e._v("decided")]),e._v("\nblock.")]),e._v(" "),o("li",[o("em",[e._v("Quick "),o("code",[e._v("FinalizeBlock")]),e._v(" execution")]),e._v(".\nUpon reception of the decided block via "),o("code",[e._v("FinalizeBlock")]),e._v(", if that same block was executed\nupon "),o("code",[e._v("PrepareProposal")]),e._v(" or "),o("code",[e._v("ProcessProposal")]),e._v(" and the resulting state was kept in memory, the\nApplication can simply apply that state (faster) to the main state, rather than reexecuting\nthe decided block (slower).")])]),e._v(" "),o("p",[o("code",[e._v("PrepareProposal")]),e._v("/"),o("code",[e._v("ProcessProposal")]),e._v(" can be called many times for a given height. Moreover,\nit is not possible to accurately predict which of the blocks proposed in a height will be decided,\nbeing delivered to the Application in that height's "),o("code",[e._v("FinalizeBlock")]),e._v(".\nTherefore, the state resulting from executing a proposed block, denoted a "),o("em",[e._v("candidate state")]),e._v(", should\nbe kept in memory as a possible final state for that height. When "),o("code",[e._v("FinalizeBlock")]),e._v(" is called, the Application should\ncheck if the decided block corresponds to one of its candidate states; if so, it will apply it as\nits "),o("em",[e._v("ExecuteTxState")]),e._v(" (see "),o("a",{attrs:{href:"#consensus-connection"}},[e._v("Consensus Connection")]),e._v(" below),\nwhich will be persisted during the upcoming "),o("code",[e._v("Commit")]),e._v(" call.")]),e._v(" "),o("p",[e._v("Under adverse conditions (e.g., network instability), Tendermint might take many rounds.\nIn this case, potentially many proposed blocks will be disclosed to the Application for a given height.\nBy the nature of Tendermint's consensus algorithm, the number of proposed blocks received by the Application\nfor a particular height cannot be bound, so Application developers must act with care and use mechanisms\nto bound memory usage. As a general rule, the Application should be ready to discard candidate states\nbefore "),o("code",[e._v("FinalizeBlock")]),e._v(", even if one of them might end up corresponding to the\ndecided block and thus have to be reexecuted upon "),o("code",[e._v("FinalizeBlock")]),e._v(".")]),e._v(" "),o("h3",{attrs:{id:"states-and-abci-connections"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#states-and-abci-connections"}},[e._v("#")]),e._v(" States and ABCI++ Connections")]),e._v(" "),o("h4",{attrs:{id:"consensus-connection"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#consensus-connection"}},[e._v("#")]),e._v(" Consensus Connection")]),e._v(" "),o("p",[e._v("The Consensus Connection should maintain an "),o("em",[e._v("ExecuteTxState")]),e._v(" — the working state\nfor block execution. It should be updated by the call to "),o("code",[e._v("FinalizeBlock")]),e._v('\nduring block execution and committed to disk as the "latest\ncommitted state" during '),o("code",[e._v("Commit")]),e._v(". Execution of a proposed block (via "),o("code",[e._v("PrepareProposal")]),e._v("/"),o("code",[e._v("ProcessProposal")]),e._v(")\n"),o("strong",[e._v("must not")]),e._v(" update the "),o("em",[e._v("ExecuteTxState")]),e._v(", but rather be kept as a separate candidate state until "),o("code",[e._v("FinalizeBlock")]),e._v("\nconfirms which of the candidate states (if any) can be used to update "),o("em",[e._v("ExecuteTxState")]),e._v(".")]),e._v(" "),o("h4",{attrs:{id:"mempool-connection"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mempool-connection"}},[e._v("#")]),e._v(" Mempool Connection")]),e._v(" "),o("p",[e._v("The mempool Connection maintains "),o("em",[e._v("CheckTxState")]),e._v(". Tendermint sequentially processes an incoming\ntransaction (via RPC from client or P2P from the gossip layer) against "),o("em",[e._v("CheckTxState")]),e._v(".\nIf the processing does not return any error, the transaction is accepted into the mempool\nand Tendermint starts gossipping it.\n"),o("em",[e._v("CheckTxState")]),e._v(" should be reset to the latest committed state\nat the end of every "),o("code",[e._v("Commit")]),e._v(".")]),e._v(" "),o("p",[e._v("During the execution of a consensus instance, the "),o("em",[e._v("CheckTxState")]),e._v(" may be updated concurrently with the\n"),o("em",[e._v("ExecuteTxState")]),e._v(", as messages may be sent concurrently on the Consensus and Mempool connections.\nAt the end of the consensus instance, as described above, Tendermint locks the mempool and flushes\nthe mempool connection before calling "),o("code",[e._v("Commit")]),e._v(". This ensures that all pending "),o("code",[e._v("CheckTx")]),e._v(" calls are\nresponded to and no new ones can begin.")]),e._v(" "),o("p",[e._v("After the "),o("code",[e._v("Commit")]),e._v(" call returns, while still holding the mempool lock, "),o("code",[e._v("CheckTx")]),e._v(" is run again on all\ntransactions that remain in the node's local mempool after filtering those included in the block.\nParameter "),o("code",[e._v("Type")]),e._v(" in "),o("code",[e._v("RequestCheckTx")]),e._v("\nindicates whether an incoming transaction is new ("),o("code",[e._v("CheckTxType_New")]),e._v("), or a\nrecheck ("),o("code",[e._v("CheckTxType_Recheck")]),e._v(").")]),e._v(" "),o("p",[e._v("Finally, after re-checking transactions in the mempool, Tendermint will unlock\nthe mempool connection. New transactions are once again able to be processed through "),o("code",[e._v("CheckTx")]),e._v(".")]),e._v(" "),o("p",[e._v("Note that "),o("code",[e._v("CheckTx")]),e._v(" is just a weak filter to keep invalid transactions out of the mempool and,\nutimately, ouf of the blockchain.\nSince the transaction cannot be guaranteed to be checked against the exact same state as it\nwill be executed as part of a (potential) decided block, "),o("code",[e._v("CheckTx")]),e._v(" shouldn't check "),o("em",[e._v("everything")]),e._v("\nthat affects the transaction's validity, in particular those checks whose validity may depend on\ntransaction ordering. "),o("code",[e._v("CheckTx")]),e._v(" is weak because a Byzantine node need not care about "),o("code",[e._v("CheckTx")]),e._v(";\nit can propose a block full of invalid transactions if it wants. The mechanism ABCI++ has\nin place for dealing with such behavior is "),o("code",[e._v("ProcessProposal")]),e._v(".")]),e._v(" "),o("h5",{attrs:{id:"replay-protection"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#replay-protection"}},[e._v("#")]),e._v(" Replay Protection")]),e._v(" "),o("p",[e._v("It is possible for old transactions to be sent again to the Application. This is typically\nundesirable for all transactions, except for a generally small subset of them which are idempotent.")]),e._v(" "),o("p",[e._v("The mempool has a mechanism to prevent duplicated transactions from being processed.\nThis mechanism is nevertheless best-effort (currently based on the indexer)\nand does not provide any guarantee of non duplication.\nIt is thus up to the Application to implement an application-specific\nreplay protection mechanism with strong guarantees as part of the logic in "),o("code",[e._v("CheckTx")]),e._v(".")]),e._v(" "),o("h4",{attrs:{id:"info-query-connection"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#info-query-connection"}},[e._v("#")]),e._v(" Info/Query Connection")]),e._v(" "),o("p",[e._v("The Info (or Query) Connection should maintain a "),o("code",[e._v("QueryState")]),e._v(". This connection has two\npurposes: 1) having the application answer the queries Tenderissued receives from users\n(see section "),o("a",{attrs:{href:"#query"}},[e._v("Query")]),e._v("),\nand 2) synchronizing Tendermint and the Application at start up time (see\n"),o("a",{attrs:{href:"#crash-recovery"}},[e._v("Crash Recovery")]),e._v(")\nor after state sync (see "),o("a",{attrs:{href:"#state-sync"}},[e._v("State Sync")]),e._v(").")]),e._v(" "),o("p",[o("code",[e._v("QueryState")]),e._v(" is a read-only copy of "),o("em",[e._v("ExecuteTxState")]),e._v(" as it was after the last\n"),o("code",[e._v("Commit")]),e._v(", i.e.\nafter the full block has been processed and the state committed to disk.")]),e._v(" "),o("h4",{attrs:{id:"snapshot-connection"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#snapshot-connection"}},[e._v("#")]),e._v(" Snapshot Connection")]),e._v(" "),o("p",[e._v("The Snapshot Connection is used to serve state sync snapshots for other nodes\nand/or restore state sync snapshots to a local node being bootstrapped.\nSnapshop management is optional: an Application may choose not to implement it.")]),e._v(" "),o("p",[e._v("For more information, see Section "),o("a",{attrs:{href:"#state-sync"}},[e._v("State Sync")]),e._v(".")]),e._v(" "),o("h3",{attrs:{id:"transaction-results"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#transaction-results"}},[e._v("#")]),e._v(" Transaction Results")]),e._v(" "),o("p",[e._v("The Application is expected to return a list of\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#exectxresult"}},[o("code",[e._v("ExecTxResult")])]),e._v(" in\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#finalizeblock"}},[o("code",[e._v("ResponseFinalizeBlock")])]),e._v(". The list of transaction\nresults must respect the same order as the list of transactions delivered via\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#finalizeblock"}},[o("code",[e._v("RequestFinalizeBlock")])]),e._v(".\nThis section discusses the fields inside this structure, along with the fields in\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#checktx"}},[o("code",[e._v("ResponseCheckTx")])]),e._v(",\nwhose semantics are similar.")],1),e._v(" "),o("p",[e._v("The "),o("code",[e._v("Info")]),e._v(" and "),o("code",[e._v("Log")]),e._v(" fields are\nnon-deterministic values for debugging/convenience purposes. Tendermint logs them but they\nare otherwise ignored.")]),e._v(" "),o("h4",{attrs:{id:"gas"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#gas"}},[e._v("#")]),e._v(" Gas")]),e._v(" "),o("p",[e._v("Ethereum introduced the notion of "),o("em",[e._v("gas")]),e._v(" as an abstract representation of the\ncost of the resources consumed by nodes when processing a transaction. Every operation in the\nEthereum Virtual Machine uses some amount of gas.\nGas has a market-variable price based on which miners can accept or reject to execute a\nparticular operation.")]),e._v(" "),o("p",[e._v("Users propose a maximum amount of gas for their transaction; if the transaction uses less, they get\nthe difference credited back. Tendermint adopts a similar abstraction,\nthough uses it only optionally and weakly, allowing applications to define\ntheir own sense of the cost of execution.")]),e._v(" "),o("p",[e._v("In Tendermint, the "),o("a",{attrs:{href:"#consensus-parameters"}},[e._v("ConsensusParams.Block.MaxGas")]),e._v(" limits the amount of\ntotal gas that can be used by all transactions in a block.\nThe default value is "),o("code",[e._v("-1")]),e._v(", which means the block gas limit is not enforced, or that the concept of\ngas is meaningless.")]),e._v(" "),o("p",[e._v("Responses contain a "),o("code",[e._v("GasWanted")]),e._v(" and "),o("code",[e._v("GasUsed")]),e._v(" field. The former is the maximum\namount of gas the sender of a transaction is willing to use, and the latter is how much it actually\nused. Applications should enforce that "),o("code",[e._v("GasUsed <= GasWanted")]),e._v(" — i.e. transaction execution\nor validation should fail before it can use more resources than it requested.")]),e._v(" "),o("p",[e._v("When "),o("code",[e._v("MaxGas > -1")]),e._v(", Tendermint enforces the following rules:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("GasWanted <= MaxGas")]),e._v(" for every transaction in the mempool")]),e._v(" "),o("li",[o("code",[e._v("(sum of GasWanted in a block) <= MaxGas")]),e._v(" when proposing a block")])]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("MaxGas == -1")]),e._v(", no rules about gas are enforced.")]),e._v(" "),o("p",[e._v("In v0.35.x and earlier versions, Tendermint does not enforce anything about Gas in consensus,\nonly in the mempool.\nThis means it does not guarantee that committed blocks satisfy these rules.\nIt is the application's responsibility to return non-zero response codes when gas limits are exceeded\nwhen executing the transactions of a block.\nSince the introduction of "),o("code",[e._v("PrepareProposal")]),e._v(" and "),o("code",[e._v("ProcessProposal")]),e._v(" in v.0.36.x, it is now possible\nfor the Application to enforce that all blocks proposed (and voted for) in consensus — and thus all\nblocks decided — respect the "),o("code",[e._v("MaxGas")]),e._v(" limits described above.")]),e._v(" "),o("p",[e._v("Since the Application should enforce that "),o("code",[e._v("GasUsed <= GasWanted")]),e._v(" when executing a transaction, and\nit can use "),o("code",[e._v("PrepareProposal")]),e._v(" and "),o("code",[e._v("ProcessProposal")]),e._v(" to enforce that "),o("code",[e._v("(sum of GasWanted in a block) <= MaxGas")]),e._v("\nin all proposed or prevoted blocks,\nwe have:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("(sum of GasUsed in a block) <= MaxGas")]),e._v(" for every block")])]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("GasUsed")]),e._v(" field is ignored by Tendermint.")]),e._v(" "),o("h4",{attrs:{id:"specifics-of-responsechecktx"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#specifics-of-responsechecktx"}},[e._v("#")]),e._v(" Specifics of "),o("code",[e._v("ResponseCheckTx")])]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("Code != 0")]),e._v(", it will be rejected from the mempool and hence\nnot broadcasted to other peers and not included in a proposal block.")]),e._v(" "),o("p",[o("code",[e._v("Data")]),e._v(" contains the result of the "),o("code",[e._v("CheckTx")]),e._v(" transaction execution, if any. It does not need to be\ndeterministic since, given a transaction, nodes' Applications\nmight have a different "),o("em",[e._v("CheckTxState")]),e._v(" values when they receive it and check their validity\nvia "),o("code",[e._v("CheckTx")]),e._v(".\nTendermint ignores this value in "),o("code",[e._v("ResponseCheckTx")]),e._v(".")]),e._v(" "),o("p",[e._v("From v0.35.x on, there is a "),o("code",[e._v("Priority")]),e._v(" field in "),o("code",[e._v("ResponseCheckTx")]),e._v(" that can be\nused to explicitly prioritize transactions in the mempool for inclusion in a block\nproposal.")]),e._v(" "),o("h4",{attrs:{id:"specifics-of-exectxresult"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#specifics-of-exectxresult"}},[e._v("#")]),e._v(" Specifics of "),o("code",[e._v("ExecTxResult")])]),e._v(" "),o("p",[o("code",[e._v("FinalizeBlock")]),e._v(" is the workhorse of the blockchain. Tendermint delivers the decided block,\nincluding the list of all its transactions synchronously to the Application.\nThe block delivered (and thus the transaction order) is the same at all correct nodes as guaranteed\nby the Agreement property of Tendermint consensus.")]),e._v(" "),o("p",[e._v("In same block execution mode, field "),o("code",[e._v("LastResultsHash")]),e._v(" in the block header refers to the results\nof all transactions stored in that block. Therefore,\n"),o("code",[e._v("PrepareProposal")]),e._v(" must return "),o("code",[e._v("ExecTxResult")]),e._v(" so that it can\nbe used to build the block to be proposed in the current height.")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("Data")]),e._v(" field in "),o("code",[e._v("ExecTxResult")]),e._v(" contains an array of bytes with the transaction result.\nIt must be deterministic (i.e., the same value must be returned at all nodes), but it can contain arbitrary\ndata. Likewise, the value of "),o("code",[e._v("Code")]),e._v(" must be deterministic.\nIf "),o("code",[e._v("Code != 0")]),e._v(", the transaction will be marked invalid,\nthough it is still included in the block. Invalid transaction are not indexed, as they are\nconsidered analogous to those that failed "),o("code",[e._v("CheckTx")]),e._v(".")]),e._v(" "),o("p",[e._v("Both the "),o("code",[e._v("Code")]),e._v(" and "),o("code",[e._v("Data")]),e._v(" are included in a structure that is hashed into the\n"),o("code",[e._v("LastResultsHash")]),e._v(" of the block header in the next height (next block execution mode), or the\nheader of the block to propose in the current height (same block execution mode, "),o("code",[e._v("ExecTxResult")]),e._v(" as\npart of "),o("code",[e._v("PrepareProposal")]),e._v(").")]),e._v(" "),o("p",[o("code",[e._v("Events")]),e._v(" include any events for the execution, which Tendermint will use to index\nthe transaction by. This allows transactions to be queried according to what\nevents took place during their execution.")]),e._v(" "),o("h3",{attrs:{id:"updating-the-validator-set"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#updating-the-validator-set"}},[e._v("#")]),e._v(" Updating the Validator Set")]),e._v(" "),o("p",[e._v("The application may set the validator set during\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#initchain"}},[o("code",[e._v("InitChain")])]),e._v(", and may update it during\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#finalizeblock"}},[o("code",[e._v("FinalizeBlock")])]),e._v("\n(next block execution mode) or\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#prepareproposal"}},[o("code",[e._v("PrepareProposal")])]),e._v("/"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#processproposal"}},[o("code",[e._v("ProcessProposal")])]),e._v("\n(same block execution mode). In all cases, a structure of type\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#validatorupdate"}},[o("code",[e._v("ValidatorUpdate")])]),e._v(" is returned.")],1),e._v(" "),o("p",[e._v("The "),o("code",[e._v("InitChain")]),e._v(" method, used to initialize the Application, can return a list of validators.\nIf the list is empty, Tendermint will use the validators loaded from the genesis\nfile.\nIf the list returned by "),o("code",[e._v("InitChain")]),e._v(" is not empty, Tendermint will use its contents as the validator set.\nThis way the application can set the initial validator set for the\nblockchain.")]),e._v(" "),o("p",[e._v("Applications must ensure that a single set of validator updates does not contain duplicates, i.e.\na given public key can only appear once within a given update. If an update includes\nduplicates, the block execution will fail irrecoverably.")]),e._v(" "),o("p",[e._v("Structure "),o("code",[e._v("ValidatorUpdate")]),e._v(" contains a public key, which is used to identify the validator:\nThe public key currently supports three types:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("ed25519")])]),e._v(" "),o("li",[o("code",[e._v("secp256k1")])]),e._v(" "),o("li",[o("code",[e._v("sr25519")])])]),e._v(" "),o("p",[e._v("Structure "),o("code",[e._v("ValidatorUpdate")]),e._v(" also contains an "),o("code",[e._v("ìnt64")]),e._v(" field denoting the validator's new power.\nApplications must ensure that\n"),o("code",[e._v("ValidatorUpdate")]),e._v(" structures abide by the following rules:")]),e._v(" "),o("ul",[o("li",[e._v("power must be non-negative")]),e._v(" "),o("li",[e._v("if power is set to 0, the validator must be in the validator set; it will be removed from the set")]),e._v(" "),o("li",[e._v("if power is greater than 0:\n"),o("ul",[o("li",[e._v("if the validator is not in the validator set, it will be added to the\nset with the given power")]),e._v(" "),o("li",[e._v("if the validator is in the validator set, its power will be adjusted to the given power")])])]),e._v(" "),o("li",[e._v("the total power of the new validator set must not exceed "),o("code",[e._v("MaxTotalVotingPower")]),e._v(", where\n"),o("code",[e._v("MaxTotalVotingPower = MaxInt64 / 8")])])]),e._v(" "),o("p",[e._v("Note the updates returned after processing the block at height "),o("code",[e._v("H")]),e._v(" will only take effect\nat block "),o("code",[e._v("H+2")]),e._v(" (see Section "),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html"}},[e._v("Methods")]),e._v(").")],1),e._v(" "),o("h3",{attrs:{id:"consensus-parameters"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#consensus-parameters"}},[e._v("#")]),e._v(" Consensus Parameters")]),e._v(" "),o("p",[o("code",[e._v("ConsensusParams")]),e._v(" are global parameters that apply to all validators in a blockchain.\nThey enforce certain limits in the blockchain, like the maximum size\nof blocks, amount of gas used in a block, and the maximum acceptable age of\nevidence. They can be set in\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#initchain"}},[o("code",[e._v("InitChain")])]),e._v(", and updated in\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#finalizeblock"}},[o("code",[e._v("FinalizeBlock")])]),e._v("\n(next block execution mode) or\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#prepareproposal"}},[o("code",[e._v("PrepareProposal")])]),e._v("/"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#processproposal"}},[o("code",[e._v("ProcessProposal")])]),e._v("\n(same block execution model).\nThese parameters are deterministically set and/or updated by the Application, so\nall full nodes have the same value at a given height.")],1),e._v(" "),o("h4",{attrs:{id:"list-of-parameters"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#list-of-parameters"}},[e._v("#")]),e._v(" List of Parameters")]),e._v(" "),o("p",[e._v("These are the current consensus parameters (as of v0.36.x):")]),e._v(" "),o("ol",[o("li",[o("a",{attrs:{href:"#blockparamsmaxbytes"}},[e._v("BlockParams.MaxBytes")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#blockparamsmaxgas"}},[e._v("BlockParams.MaxGas")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#evidenceparamsmaxageduration"}},[e._v("EvidenceParams.MaxAgeDuration")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#evidenceparamsmaxagenumblocks"}},[e._v("EvidenceParams.MaxAgeNumBlocks")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#evidenceparamsmaxbytes"}},[e._v("EvidenceParams.MaxBytes")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#synchronyparamsmessagedelay"}},[e._v("SynchronyParams.MessageDelay")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#synchronyparamsprecision"}},[e._v("SynchronyParams.Precision")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#timeoutparamspropose"}},[e._v("TimeoutParams.Propose")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#timeoutparamsproposedelta"}},[e._v("TimeoutParams.ProposeDelta")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#timeoutparamsvote"}},[e._v("TimeoutParams.Vote")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#timeoutparamsvotedelta"}},[e._v("TimeoutParams.VoteDelta")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#timeoutparamscommit"}},[e._v("TimeoutParams.Commit")])]),e._v(" "),o("li",[o("a",{attrs:{href:"#timeoutparamsbypasscommittimeout"}},[e._v("TimeoutParams.BypassCommitTimeout")])])]),e._v(" "),o("h5",{attrs:{id:"blockparams-maxbytes"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#blockparams-maxbytes"}},[e._v("#")]),e._v(" BlockParams.MaxBytes")]),e._v(" "),o("p",[e._v("The maximum size of a complete Protobuf encoded block.\nThis is enforced by Tendermint consensus.")]),e._v(" "),o("p",[e._v("This implies a maximum transaction size that is this "),o("code",[e._v("MaxBytes")]),e._v(", less the expected size of\nthe header, the validator set, and any included evidence in the block.")]),e._v(" "),o("p",[e._v("Must have "),o("code",[e._v("0 < MaxBytes < 100 MB")]),e._v(".")]),e._v(" "),o("h5",{attrs:{id:"blockparams-maxgas"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#blockparams-maxgas"}},[e._v("#")]),e._v(" BlockParams.MaxGas")]),e._v(" "),o("p",[e._v("The maximum of the sum of "),o("code",[e._v("GasWanted")]),e._v(" that will be allowed in a proposed block.\nThis is "),o("em",[e._v("not")]),e._v(" enforced by Tendermint consensus.\nIt is left to the Application to enforce (ie. if transactions are included past the\nlimit, they should return non-zero codes). It is used by Tendermint to limit the\ntransactions included in a proposed block.")]),e._v(" "),o("p",[e._v("Must have "),o("code",[e._v("MaxGas >= -1")]),e._v(".\nIf "),o("code",[e._v("MaxGas == -1")]),e._v(", no limit is enforced.")]),e._v(" "),o("h5",{attrs:{id:"evidenceparams-maxageduration"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#evidenceparams-maxageduration"}},[e._v("#")]),e._v(" EvidenceParams.MaxAgeDuration")]),e._v(" "),o("p",[e._v("This is the maximum age of evidence in time units.\nThis is enforced by Tendermint consensus.")]),e._v(" "),o("p",[e._v("If a block includes evidence older than this (AND the evidence was created more\nthan "),o("code",[e._v("MaxAgeNumBlocks")]),e._v(" ago), the block will be rejected (validators won't vote\nfor it).")]),e._v(" "),o("p",[e._v("Must have "),o("code",[e._v("MaxAgeDuration > 0")]),e._v(".")]),e._v(" "),o("h5",{attrs:{id:"evidenceparams-maxagenumblocks"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#evidenceparams-maxagenumblocks"}},[e._v("#")]),e._v(" EvidenceParams.MaxAgeNumBlocks")]),e._v(" "),o("p",[e._v("This is the maximum age of evidence in blocks.\nThis is enforced by Tendermint consensus.")]),e._v(" "),o("p",[e._v("If a block includes evidence older than this (AND the evidence was created more\nthan "),o("code",[e._v("MaxAgeDuration")]),e._v(" ago), the block will be rejected (validators won't vote\nfor it).")]),e._v(" "),o("p",[e._v("Must have "),o("code",[e._v("MaxAgeNumBlocks > 0")]),e._v(".")]),e._v(" "),o("h5",{attrs:{id:"evidenceparams-maxbytes"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#evidenceparams-maxbytes"}},[e._v("#")]),e._v(" EvidenceParams.MaxBytes")]),e._v(" "),o("p",[e._v("This is the maximum size of total evidence in bytes that can be committed to a\nsingle block. It should fall comfortably under the max block bytes.")]),e._v(" "),o("p",[e._v("Its value must not exceed the size of\na block minus its overhead ( ~ "),o("code",[e._v("BlockParams.MaxBytes")]),e._v(").")]),e._v(" "),o("p",[e._v("Must have "),o("code",[e._v("MaxBytes > 0")]),e._v(".")]),e._v(" "),o("h5",{attrs:{id:"synchronyparams-messagedelay"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#synchronyparams-messagedelay"}},[e._v("#")]),e._v(" SynchronyParams.MessageDelay")]),e._v(" "),o("p",[e._v("This sets a bound on how long a proposal message may take to reach all\nvalidators on a network and still be considered valid.")]),e._v(" "),o("p",[e._v("This parameter is part of the\n"),o("a",{attrs:{href:"../consensus/proposer-based-timestamp"}},[e._v("proposer-based timestamps")]),e._v("\n(PBTS) algorithm.")]),e._v(" "),o("h5",{attrs:{id:"synchronyparams-precision"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#synchronyparams-precision"}},[e._v("#")]),e._v(" SynchronyParams.Precision")]),e._v(" "),o("p",[e._v("This sets a bound on how skewed a proposer's clock may be from any validator\non the network while still producing valid proposals.")]),e._v(" "),o("p",[e._v("This parameter is part of the\n"),o("a",{attrs:{href:"../consensus/proposer-based-timestamp"}},[e._v("proposer-based timestamps")]),e._v("\n(PBTS) algorithm.")]),e._v(" "),o("h5",{attrs:{id:"timeoutparams-propose"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#timeoutparams-propose"}},[e._v("#")]),e._v(" TimeoutParams.Propose")]),e._v(" "),o("p",[e._v("Timeout in ms of the propose step of the Tendermint consensus algorithm.\nThis value is the initial timeout at every height (round 0).")]),e._v(" "),o("p",[e._v("The value in subsequent rounds is modified by parameter "),o("code",[e._v("ProposeDelta")]),e._v(".\nWhen a new height is started, the "),o("code",[e._v("Propose")]),e._v(" timeout value is reset to this\nparameter.")]),e._v(" "),o("p",[e._v("If a node waiting for a proposal message does not receive one matching its\ncurrent height and round before this timeout, the node will issue a\n"),o("code",[e._v("nil")]),e._v(" prevote for the round and advance to the next step.")]),e._v(" "),o("h5",{attrs:{id:"timeoutparams-proposedelta"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#timeoutparams-proposedelta"}},[e._v("#")]),e._v(" TimeoutParams.ProposeDelta")]),e._v(" "),o("p",[e._v("Increment in ms to be added to the "),o("code",[e._v("Propose")]),e._v(" timeout every time the Tendermint\nconsensus algorithm advances one round in a given height.")]),e._v(" "),o("p",[e._v("When a new height is started, the "),o("code",[e._v("Propose")]),e._v(" timeout value is reset.")]),e._v(" "),o("h5",{attrs:{id:"timeoutparams-vote"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#timeoutparams-vote"}},[e._v("#")]),e._v(" TimeoutParams.Vote")]),e._v(" "),o("p",[e._v("Timeout in ms of the prevote and precommit steps of the Tendermint consensus\nalgorithm.\nThis value is the initial timeout at every height (round 0).")]),e._v(" "),o("p",[e._v("The value in subsequent rounds is modified by parameter "),o("code",[e._v("VoteDelta")]),e._v(".\nWhen a new height is started, the "),o("code",[e._v("Vote")]),e._v(" timeout value is reset to this\nparameter.")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("Vote")]),e._v(" timeout does not begin until a quorum of votes has been received.\nOnce a quorum of votes has been seen and this timeout elapses, Tendermint will\nprocced to the next step of the consensus algorithm. If Tendermint receives\nall of the remaining votes before the end of the timeout, it will proceed\nto the next step immediately.")]),e._v(" "),o("h5",{attrs:{id:"timeoutparams-votedelta"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#timeoutparams-votedelta"}},[e._v("#")]),e._v(" TimeoutParams.VoteDelta")]),e._v(" "),o("p",[e._v("Increment in ms to be added to the "),o("code",[e._v("Vote")]),e._v(" timeout every time the Tendermint\nconsensus algorithm advances one round in a given height.")]),e._v(" "),o("p",[e._v("When a new height is started, the "),o("code",[e._v("Vote")]),e._v(" timeout value is reset.")]),e._v(" "),o("h5",{attrs:{id:"timeoutparams-commit"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#timeoutparams-commit"}},[e._v("#")]),e._v(" TimeoutParams.Commit")]),e._v(" "),o("p",[e._v("This configures how long Tendermint will wait after receiving a quorum of\nprecommits before beginning consensus for the next height. This can be\nused to allow slow precommits to arrive for inclusion in the next height\nbefore progressing.")]),e._v(" "),o("h5",{attrs:{id:"timeoutparams-bypasscommittimeout"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#timeoutparams-bypasscommittimeout"}},[e._v("#")]),e._v(" TimeoutParams.BypassCommitTimeout")]),e._v(" "),o("p",[e._v("This configures the node to proceed immediately to the next height once the\nnode has received all precommits for a block, forgoing the remaining commit timeout.\nSetting this parameter to "),o("code",[e._v("false")]),e._v(" (the default) causes Tendermint to wait\nfor the full commit timeout configured in "),o("code",[e._v("TimeoutParams.Commit")]),e._v(".")]),e._v(" "),o("h5",{attrs:{id:"abciparams-voteextensionsenableheight"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#abciparams-voteextensionsenableheight"}},[e._v("#")]),e._v(" ABCIParams.VoteExtensionsEnableHeight")]),e._v(" "),o("p",[e._v("This parameter is either 0 or a positive height at which vote extensions\nbecome mandatory. If the value is zero (which is the default), vote\nextensions are not required. Otherwise, at all heights greater than the\nconfigured height "),o("code",[e._v("H")]),e._v(" vote extensions must be present (even if empty).\nWhen the configured height "),o("code",[e._v("H")]),e._v(" is reached, "),o("code",[e._v("PrepareProposal")]),e._v(" will not\ninclude vote extensions yet, but "),o("code",[e._v("ExtendVote")]),e._v(" and "),o("code",[e._v("VerifyVoteExtension")]),e._v(" will\nbe called. Then, when reaching height "),o("code",[e._v("H+1")]),e._v(", "),o("code",[e._v("PrepareProposal")]),e._v(" will\ninclude the vote extensions from height "),o("code",[e._v("H")]),e._v(". For all heights after "),o("code",[e._v("H")])]),e._v(" "),o("ul",[o("li",[e._v("vote extensions cannot be disabled,")]),e._v(" "),o("li",[e._v("they are mandatory: all precommit messages sent MUST have an extension\nattached. Nevetheless, the application MAY provide 0-length\nextensions.")])]),e._v(" "),o("p",[e._v("Must always be set to a future height. Once set to a value different from\n0, its value must not be changed.")]),e._v(" "),o("h4",{attrs:{id:"updating-consensus-parameters"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#updating-consensus-parameters"}},[e._v("#")]),e._v(" Updating Consensus Parameters")]),e._v(" "),o("p",[e._v("The application may set the "),o("code",[e._v("ConsensusParams")]),e._v(" during\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#initchain"}},[o("code",[e._v("InitChain")])]),e._v(",\nand update them during\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#finalizeblock"}},[o("code",[e._v("FinalizeBlock")])]),e._v("\n(next block execution mode) or\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#prepareproposal"}},[o("code",[e._v("PrepareProposal")])]),e._v("/"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html#processproposal"}},[o("code",[e._v("ProcessProposal")])]),e._v("\n(same block execution mode).\nIf the "),o("code",[e._v("ConsensusParams")]),e._v(" is empty, it will be ignored. Each field\nthat is not empty will be applied in full. For instance, if updating the\n"),o("code",[e._v("Block.MaxBytes")]),e._v(", applications must also set the other "),o("code",[e._v("Block")]),e._v(" fields (like\n"),o("code",[e._v("Block.MaxGas")]),e._v("), even if they are unchanged, as they will otherwise cause the\nvalue to be updated to the default.")],1),e._v(" "),o("h5",{attrs:{id:"initchain"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#initchain"}},[e._v("#")]),e._v(" "),o("code",[e._v("InitChain")])]),e._v(" "),o("p",[o("code",[e._v("ResponseInitChain")]),e._v(" includes a "),o("code",[e._v("ConsensusParams")]),e._v(" parameter.\nIf "),o("code",[e._v("ConsensusParams")]),e._v(" is "),o("code",[e._v("nil")]),e._v(", Tendermint will use the params loaded in the genesis\nfile. If "),o("code",[e._v("ConsensusParams")]),e._v(" is not "),o("code",[e._v("nil")]),e._v(", Tendermint will use it.\nThis way the application can determine the initial consensus parameters for the\nblockchain.")]),e._v(" "),o("h5",{attrs:{id:"finalizeblock-prepareproposal-processproposal"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#finalizeblock-prepareproposal-processproposal"}},[e._v("#")]),e._v(" "),o("code",[e._v("FinalizeBlock")]),e._v(", "),o("code",[e._v("PrepareProposal")]),e._v("/"),o("code",[e._v("ProcessProposal")])]),e._v(" "),o("p",[e._v("In next block execution mode, "),o("code",[e._v("ResponseFinalizeBlock")]),e._v(" accepts a "),o("code",[e._v("ConsensusParams")]),e._v(" parameter.\nIf "),o("code",[e._v("ConsensusParams")]),e._v(" is "),o("code",[e._v("nil")]),e._v(", Tendermint will do nothing.\nIf "),o("code",[e._v("ConsensusParams")]),e._v(" is not "),o("code",[e._v("nil")]),e._v(", Tendermint will use it.\nThis way the application can update the consensus parameters over time.")]),e._v(" "),o("p",[e._v("Likewise, in same block execution mode, "),o("code",[e._v("PrepareProposal")]),e._v(" and "),o("code",[e._v("ProcessProposal")]),e._v(" include\na "),o("code",[e._v("ConsensusParams")]),e._v(" parameter. "),o("code",[e._v("PrepareProposal")]),e._v(" may return a "),o("code",[e._v("ConsensusParams")]),e._v(" to update\nthe consensus parameters in the block that is about to be proposed. If it returns "),o("code",[e._v("nil")]),e._v("\nthe consensus parameters will not be updated. "),o("code",[e._v("ProcessProposal")]),e._v(" also accepts a\n"),o("code",[e._v("ConsensusParams")]),e._v(" parameter, which Tendermint will use it to calculate the corresponding\nhashes and sanity-check them against those of the block that triggered "),o("code",[e._v("ProcessProposal")]),e._v("\nat the first place.")]),e._v(" "),o("p",[e._v("Note the updates returned in block "),o("code",[e._v("H")]),e._v(" will take effect right away for block\n"),o("code",[e._v("H+1")]),e._v(" (both in next block and same block execution mode).")]),e._v(" "),o("h3",{attrs:{id:"query"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#query"}},[e._v("#")]),e._v(" "),o("code",[e._v("Query")])]),e._v(" "),o("p",[o("code",[e._v("Query")]),e._v(" is a generic method with lots of flexibility to enable diverse sets\nof queries on application state. Tendermint makes use of "),o("code",[e._v("Query")]),e._v(" to filter new peers\nbased on ID and IP, and exposes "),o("code",[e._v("Query")]),e._v(" to the user over RPC.")]),e._v(" "),o("p",[e._v("Note that calls to "),o("code",[e._v("Query")]),e._v(" are not replicated across nodes, but rather query the\nlocal node's state - hence they may return stale reads. For reads that require\nconsensus, use a transaction.")]),e._v(" "),o("p",[e._v("The most important use of "),o("code",[e._v("Query")]),e._v(" is to return Merkle proofs of the application state at some height\nthat can be used for efficient application-specific light-clients.")]),e._v(" "),o("p",[e._v("Note Tendermint has technically no requirements from the "),o("code",[e._v("Query")]),e._v("\nmessage for normal operation - that is, the ABCI app developer need not implement\nQuery functionality if they do not wish to.")]),e._v(" "),o("h4",{attrs:{id:"query-proofs"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#query-proofs"}},[e._v("#")]),e._v(" Query Proofs")]),e._v(" "),o("p",[e._v("The Tendermint block header includes a number of hashes, each providing an\nanchor for some type of proof about the blockchain. The "),o("code",[e._v("ValidatorsHash")]),e._v(" enables\nquick verification of the validator set, the "),o("code",[e._v("DataHash")]),e._v(" gives quick\nverification of the transactions included in the block.")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("AppHash")]),e._v(" is unique in that it is application specific, and allows for\napplication-specific Merkle proofs about the state of the application.\nWhile some applications keep all relevant state in the transactions themselves\n(like Bitcoin and its UTXOs), others maintain a separated state that is\ncomputed deterministically "),o("em",[e._v("from")]),e._v(" transactions, but is not contained directly in\nthe transactions themselves (like Ethereum contracts and accounts).\nFor such applications, the "),o("code",[e._v("AppHash")]),e._v(" provides a much more efficient way to verify light-client proofs.")]),e._v(" "),o("p",[e._v("ABCI applications can take advantage of more efficient light-client proofs for\ntheir state as follows:")]),e._v(" "),o("ul",[o("li",[e._v("in next block executon mode, return the Merkle root of the deterministic application state in\n"),o("code",[e._v("ResponseCommit.Data")]),e._v(". This Merkle root will be included as the "),o("code",[e._v("AppHash")]),e._v(" in the next block.")]),e._v(" "),o("li",[e._v("in same block execution mode, return the Merkle root of the deterministic application state\nin "),o("code",[e._v("ResponsePrepareProposal.AppHash")]),e._v(". This Merkle root will be included as the "),o("code",[e._v("AppHash")]),e._v(" in\nthe block that is about to be proposed.")]),e._v(" "),o("li",[e._v("return efficient Merkle proofs about that application state in "),o("code",[e._v("ResponseQuery.Proof")]),e._v("\nthat can be verified using the "),o("code",[e._v("AppHash")]),e._v(" of the corresponding block.")])]),e._v(" "),o("p",[e._v("For instance, this allows an application's light-client to verify proofs of\nabsence in the application state, something which is much less efficient to do using the block hash.")]),e._v(" "),o("p",[e._v('Some applications (eg. Ethereum, Cosmos-SDK) have multiple "levels" of Merkle trees,\nwhere the leaves of one tree are the root hashes of others. To support this, and\nthe general variability in Merkle proofs, the '),o("code",[e._v("ResponseQuery.Proof")]),e._v(" has some minimal structure:")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"protobuf",base64:"bWVzc2FnZSBQcm9vZk9wcyB7CiAgcmVwZWF0ZWQgUHJvb2ZPcCBvcHMgPSAxCn0KCm1lc3NhZ2UgUHJvb2ZPcCB7CiAgc3RyaW5nIHR5cGUgPSAxOwogIGJ5dGVzIGtleSAgID0gMjsKICBieXRlcyBkYXRhICA9IDM7Cn0K"}}),e._v(" "),o("p",[e._v("Each "),o("code",[e._v("ProofOp")]),e._v(" contains a proof for a single key in a single Merkle tree, of the specified "),o("code",[e._v("type")]),e._v(".\nThis allows ABCI to support many different kinds of Merkle trees, encoding\nformats, and proofs (eg. of presence and absence) just by varying the "),o("code",[e._v("type")]),e._v(".\nThe "),o("code",[e._v("data")]),e._v(" contains the actual encoded proof, encoded according to the "),o("code",[e._v("type")]),e._v(".\nWhen verifying the full proof, the root hash for one ProofOp is the value being\nverified for the next ProofOp in the list. The root hash of the final ProofOp in\nthe list should match the "),o("code",[e._v("AppHash")]),e._v(" being verified against.")]),e._v(" "),o("h4",{attrs:{id:"peer-filtering"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#peer-filtering"}},[e._v("#")]),e._v(" Peer Filtering")]),e._v(" "),o("p",[e._v("When Tendermint connects to a peer, it sends two queries to the ABCI application\nusing the following paths, with no additional data:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("/p2p/filter/addr/<IP:PORT>")]),e._v(", where "),o("code",[e._v("<IP:PORT>")]),e._v(" denote the IP address and\nthe port of the connection")]),e._v(" "),o("li",[o("code",[e._v("p2p/filter/id/<ID>")]),e._v(", where "),o("code",[e._v("<ID>")]),e._v(" is the peer node ID (ie. the\npubkey.Address() for the peer's PubKey)")])]),e._v(" "),o("p",[e._v("If either of these queries return a non-zero ABCI code, Tendermint will refuse\nto connect to the peer.")]),e._v(" "),o("h4",{attrs:{id:"paths"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#paths"}},[e._v("#")]),e._v(" Paths")]),e._v(" "),o("p",[e._v("Queries are directed at paths, and may optionally include additional data.")]),e._v(" "),o("p",[e._v("The expectation is for there to be some number of high level paths\ndifferentiating concerns, like "),o("code",[e._v("/p2p")]),e._v(", "),o("code",[e._v("/store")]),e._v(", and "),o("code",[e._v("/app")]),e._v(". Currently,\nTendermint only uses "),o("code",[e._v("/p2p")]),e._v(", for filtering peers. For more advanced use, see the\nimplementation of\n"),o("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/v0.23.1/baseapp/baseapp.go#L333",target:"_blank",rel:"noopener noreferrer"}},[e._v("Query in the Cosmos-SDK"),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("h3",{attrs:{id:"crash-recovery"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#crash-recovery"}},[e._v("#")]),e._v(" Crash Recovery")]),e._v(" "),o("p",[e._v("On startup, Tendermint calls the "),o("code",[e._v("Info")]),e._v(" method on the Info Connection to get the latest\ncommitted state of the app. The app MUST return information consistent with the\nlast block it succesfully completed Commit for.")]),e._v(" "),o("p",[e._v("If the app succesfully committed block H, then "),o("code",[e._v("last_block_height = H")]),e._v(" and "),o("code",[e._v("last_block_app_hash = <hash returned by Commit for block H>")]),e._v(". If the app\nfailed during the Commit of block H, then "),o("code",[e._v("last_block_height = H-1")]),e._v(" and\n"),o("code",[e._v("last_block_app_hash = <hash returned by Commit for block H-1, which is the hash in the header of block H>")]),e._v(".")]),e._v(" "),o("p",[e._v("We now distinguish three heights, and describe how Tendermint syncs itself with\nthe app.")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"md",base64:"c3RvcmVCbG9ja0hlaWdodCA9IGhlaWdodCBvZiB0aGUgbGFzdCBibG9jayBUZW5kZXJtaW50IHNhdyBhIGNvbW1pdCBmb3IKc3RhdGVCbG9ja0hlaWdodCA9IGhlaWdodCBvZiB0aGUgbGFzdCBibG9jayBmb3Igd2hpY2ggVGVuZGVybWludCBjb21wbGV0ZWQgYWxsCiAgICBibG9jayBwcm9jZXNzaW5nIGFuZCBzYXZlZCBhbGwgQUJDSSByZXN1bHRzIHRvIGRpc2sKYXBwQmxvY2tIZWlnaHQgPSBoZWlnaHQgb2YgdGhlIGxhc3QgYmxvY2sgZm9yIHdoaWNoIEFCQ0kgYXBwIHN1Y2Nlc2Z1bGx5CiAgICBjb21wbGV0ZWQgQ29tbWl0Cgo="}}),e._v(" "),o("p",[e._v("Note we always have "),o("code",[e._v("storeBlockHeight >= stateBlockHeight")]),e._v(" and "),o("code",[e._v("storeBlockHeight >= appBlockHeight")]),e._v("\nNote also Tendermint never calls Commit on an ABCI app twice for the same height.")]),e._v(" "),o("p",[e._v("The procedure is as follows.")]),e._v(" "),o("p",[e._v("First, some simple start conditions:")]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("appBlockHeight == 0")]),e._v(", then call InitChain.")]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("storeBlockHeight == 0")]),e._v(", we're done.")]),e._v(" "),o("p",[e._v("Now, some sanity checks:")]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("storeBlockHeight < appBlockHeight")]),e._v(", error\nIf "),o("code",[e._v("storeBlockHeight < stateBlockHeight")]),e._v(", panic\nIf "),o("code",[e._v("storeBlockHeight > stateBlockHeight+1")]),e._v(", panic")]),e._v(" "),o("p",[e._v("Now, the meat:")]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("storeBlockHeight == stateBlockHeight && appBlockHeight < storeBlockHeight")]),e._v(",\nreplay all blocks in full from "),o("code",[e._v("appBlockHeight")]),e._v(" to "),o("code",[e._v("storeBlockHeight")]),e._v(".\nThis happens if we completed processing the block, but the app forgot its height.")]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("storeBlockHeight == stateBlockHeight && appBlockHeight == storeBlockHeight")]),e._v(", we're done.\nThis happens if we crashed at an opportune spot.")]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("storeBlockHeight == stateBlockHeight+1")]),e._v("\nThis happens if we started processing the block but didn't finish.")]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("appBlockHeight < stateBlockHeight")]),e._v("\nreplay all blocks in full from "),o("code",[e._v("appBlockHeight")]),e._v(" to "),o("code",[e._v("storeBlockHeight-1")]),e._v(",\nand replay the block at "),o("code",[e._v("storeBlockHeight")]),e._v(" using the WAL.\nThis happens if the app forgot the last block it committed.")]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("appBlockHeight == stateBlockHeight")]),e._v(",\nreplay the last block (storeBlockHeight) in full.\nThis happens if we crashed before the app finished Commit")]),e._v(" "),o("p",[e._v("If "),o("code",[e._v("appBlockHeight == storeBlockHeight")]),e._v("\nupdate the state using the saved ABCI responses but dont run the block against the real app.\nThis happens if we crashed after the app finished Commit but before Tendermint saved the state.")]),e._v(" "),o("h3",{attrs:{id:"state-sync"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#state-sync"}},[e._v("#")]),e._v(" State Sync")]),e._v(" "),o("p",[e._v("A new node joining the network can simply join consensus at the genesis height and replay all\nhistorical blocks until it is caught up. However, for large chains this can take a significant\namount of time, often on the order of days or weeks.")]),e._v(" "),o("p",[e._v("State sync is an alternative mechanism for bootstrapping a new node, where it fetches a snapshot\nof the state machine at a given height and restores it. Depending on the application, this can\nbe several orders of magnitude faster than replaying blocks.")]),e._v(" "),o("p",[e._v("Note that state sync does not currently backfill historical blocks, so the node will have a\ntruncated block history - users are advised to consider the broader network implications of this in\nterms of block availability and auditability. This functionality may be added in the future.")]),e._v(" "),o("p",[e._v("For details on the specific ABCI calls and types, see the\n"),o("RouterLink",{attrs:{to:"/spec/abci++/abci%2B%2B_methods.html"}},[e._v("methods")]),e._v(" section.")],1),e._v(" "),o("h4",{attrs:{id:"taking-snapshots"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#taking-snapshots"}},[e._v("#")]),e._v(" Taking Snapshots")]),e._v(" "),o("p",[e._v("Applications that want to support state syncing must take state snapshots at regular intervals. How\nthis is accomplished is entirely up to the application. A snapshot consists of some metadata and\na set of binary chunks in an arbitrary format:")]),e._v(" "),o("ul",[o("li",[o("p",[o("code",[e._v("Height (uint64)")]),e._v(": The height at which the snapshot is taken. It must be taken after the given\nheight has been committed, and must not contain data from any later heights.")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Format (uint32)")]),e._v(": An arbitrary snapshot format identifier. This can be used to version snapshot\nformats, e.g. to switch from Protobuf to MessagePack for serialization. The application can use\nthis when restoring to choose whether to accept or reject a snapshot.")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Chunks (uint32)")]),e._v(": The number of chunks in the snapshot. Each chunk contains arbitrary binary\ndata, and should be less than 16 MB; 10 MB is a good starting point.")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Hash ([]byte)")]),e._v(": An arbitrary hash of the snapshot. This is used to check whether a snapshot is\nthe same across nodes when downloading chunks.")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Metadata ([]byte)")]),e._v(": Arbitrary snapshot metadata, e.g. chunk hashes for verification or any other\nnecessary info.")])])]),e._v(" "),o("p",[e._v("For a snapshot to be considered the same across nodes, all of these fields must be identical. When\nsent across the network, snapshot metadata messages are limited to 4 MB.")]),e._v(" "),o("p",[e._v("When a new node is running state sync and discovering snapshots, Tendermint will query an existing\napplication via the ABCI "),o("code",[e._v("ListSnapshots")]),e._v(" method to discover available snapshots, and load binary\nsnapshot chunks via "),o("code",[e._v("LoadSnapshotChunk")]),e._v(". The application is free to choose how to implement this\nand which formats to use, but must provide the following guarantees:")]),e._v(" "),o("ul",[o("li",[o("p",[o("strong",[e._v("Consistent:")]),e._v(" A snapshot must be taken at a single isolated height, unaffected by\nconcurrent writes. This can be accomplished by using a data store that supports ACID\ntransactions with snapshot isolation.")])]),e._v(" "),o("li",[o("p",[o("strong",[e._v("Asynchronous:")]),e._v(" Taking a snapshot can be time-consuming, so it must not halt chain progress,\nfor example by running in a separate thread.")])]),e._v(" "),o("li",[o("p",[o("strong",[e._v("Deterministic:")]),e._v(" A snapshot taken at the same height in the same format must be identical\n(at the byte level) across nodes, including all metadata. This ensures good availability of\nchunks, and that they fit together across nodes.")])])]),e._v(" "),o("p",[e._v("A very basic approach might be to use a datastore with MVCC transactions (such as RocksDB),\nstart a transaction immediately after block commit, and spawn a new thread which is passed the\ntransaction handle. This thread can then export all data items, serialize them using e.g.\nProtobuf, hash the byte stream, split it into chunks, and store the chunks in the file system\nalong with some metadata - all while the blockchain is applying new blocks in parallel.")]),e._v(" "),o("p",[e._v("A more advanced approach might include incremental verification of individual chunks against the\nchain app hash, parallel or batched exports, compression, and so on.")]),e._v(" "),o("p",[e._v("Old snapshots should be removed after some time - generally only the last two snapshots are needed\n(to prevent the last one from being removed while a node is restoring it).")]),e._v(" "),o("h4",{attrs:{id:"bootstrapping-a-node"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#bootstrapping-a-node"}},[e._v("#")]),e._v(" Bootstrapping a Node")]),e._v(" "),o("p",[e._v("An empty node can be state synced by setting the configuration option "),o("code",[e._v("statesync.enabled = true")]),e._v(". The node also needs the chain genesis file for basic chain info, and configuration for\nlight client verification of the restored snapshot: a set of Tendermint RPC servers, and a\ntrusted header hash and corresponding height from a trusted source, via the "),o("code",[e._v("statesync")]),e._v("\nconfiguration section.")]),e._v(" "),o("p",[e._v("Once started, the node will connect to the P2P network and begin discovering snapshots. These\nwill be offered to the local application via the "),o("code",[e._v("OfferSnapshot")]),e._v(" ABCI method. Once a snapshot\nis accepted Tendermint will fetch and apply the snapshot chunks. After all chunks have been\nsuccessfully applied, Tendermint verifies the app's "),o("code",[e._v("AppHash")]),e._v(" against the chain using the light\nclient, then switches the node to normal consensus operation.")]),e._v(" "),o("h5",{attrs:{id:"snapshot-discovery"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#snapshot-discovery"}},[e._v("#")]),e._v(" Snapshot Discovery")]),e._v(" "),o("p",[e._v("When the empty node joins the P2P network, it asks all peers to report snapshots via the\n"),o("code",[e._v("ListSnapshots")]),e._v(" ABCI call (limited to 10 per node). After some time, the node picks the most\nsuitable snapshot (generally prioritized by height, format, and number of peers), and offers it\nto the application via "),o("code",[e._v("OfferSnapshot")]),e._v(". The application can choose a number of responses,\nincluding accepting or rejecting it, rejecting the offered format, rejecting the peer who sent\nit, and so on. Tendermint will keep discovering and offering snapshots until one is accepted or\nthe application aborts.")]),e._v(" "),o("h5",{attrs:{id:"snapshot-restoration"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#snapshot-restoration"}},[e._v("#")]),e._v(" Snapshot Restoration")]),e._v(" "),o("p",[e._v("Once a snapshot has been accepted via "),o("code",[e._v("OfferSnapshot")]),e._v(", Tendermint begins downloading chunks from\nany peers that have the same snapshot (i.e. that have identical metadata fields). Chunks are\nspooled in a temporary directory, and then given to the application in sequential order via\n"),o("code",[e._v("ApplySnapshotChunk")]),e._v(" until all chunks have been accepted.")]),e._v(" "),o("p",[e._v("The method for restoring snapshot chunks is entirely up to the application.")]),e._v(" "),o("p",[e._v("During restoration, the application can respond to "),o("code",[e._v("ApplySnapshotChunk")]),e._v(" with instructions for how\nto continue. This will typically be to accept the chunk and await the next one, but it can also\nask for chunks to be refetched (either the current one or any number of previous ones), P2P peers\nto be banned, snapshots to be rejected or retried, and a number of other responses - see the ABCI\nreference for details.")]),e._v(" "),o("p",[e._v("If Tendermint fails to fetch a chunk after some time, it will reject the snapshot and try a\ndifferent one via "),o("code",[e._v("OfferSnapshot")]),e._v(" - the application can choose whether it wants to support\nrestarting restoration, or simply abort with an error.")]),e._v(" "),o("h5",{attrs:{id:"snapshot-verification"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#snapshot-verification"}},[e._v("#")]),e._v(" Snapshot Verification")]),e._v(" "),o("p",[e._v("Once all chunks have been accepted, Tendermint issues an "),o("code",[e._v("Info")]),e._v(" ABCI call to retrieve the\n"),o("code",[e._v("LastBlockAppHash")]),e._v(". This is compared with the trusted app hash from the chain, retrieved and\nverified using the light client. Tendermint also checks that "),o("code",[e._v("LastBlockHeight")]),e._v(" corresponds to the\nheight of the snapshot.")]),e._v(" "),o("p",[e._v("This verification ensures that an application is valid before joining the network. However, the\nsnapshot restoration may take a long time to complete, so applications may want to employ additional\nverification during the restore to detect failures early. This might e.g. include incremental\nverification of each chunk against the app hash (using bundled Merkle proofs), checksums to\nprotect against data corruption by the disk or network, and so on. However, it is important to\nnote that the only trusted information available is the app hash, and all other snapshot metadata\ncan be spoofed by adversaries.")]),e._v(" "),o("p",[e._v("Apps may also want to consider state sync denial-of-service vectors, where adversaries provide\ninvalid or harmful snapshots to prevent nodes from joining the network. The application can\ncounteract this by asking Tendermint to ban peers. As a last resort, node operators can use\nP2P configuration options to whitelist a set of trusted peers that can provide valid snapshots.")]),e._v(" "),o("h5",{attrs:{id:"transition-to-consensus"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#transition-to-consensus"}},[e._v("#")]),e._v(" Transition to Consensus")]),e._v(" "),o("p",[e._v("Once the snapshots have all been restored, Tendermint gathers additional information necessary for\nbootstrapping the node (e.g. chain ID, consensus parameters, validator sets, and block headers)\nfrom the genesis file and light client RPC servers. It also calls "),o("code",[e._v("Info")]),e._v(" to verify the following:")]),e._v(" "),o("ul",[o("li",[e._v("that the app hash from the snapshot it has delivered to the Application matches the apphash\nstored in the next height's block (in next block execution), or the current block's height\n(same block execution)")]),e._v(" "),o("li",[e._v("that the version that the Application returns in "),o("code",[e._v("ResponseInfo")]),e._v(" matches the version in the\ncurrent height's block header")])]),e._v(" "),o("p",[e._v("Once the state machine has been restored and Tendermint has gathered this additional\ninformation, it transitions to block sync (if enabled) to fetch any remaining blocks up the chain\nhead, and then transitions to regular consensus operation. At this point the node operates like\nany other node, apart from having a truncated block history at the height of the restored snapshot.")])],1)}),[],!1,null,null,null);t.default=n.exports}}]);