(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{576:function(e,t,n){e.exports=n.p+"assets/img/adr-075-log-before.38118405.png"},577:function(e,t,n){e.exports=n.p+"assets/img/adr-075-log-after.9391a392.png"},709:function(e,t,n){"use strict";n.r(t);var i=n(1),s=Object(i.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"adr-075-rpc-event-subscription-interface"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#adr-075-rpc-event-subscription-interface"}},[e._v("#")]),e._v(" ADR 075: RPC Event Subscription Interface")]),e._v(" "),i("h2",{attrs:{id:"changelog"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#changelog"}},[e._v("#")]),e._v(" Changelog")]),e._v(" "),i("ul",[i("li",[e._v("01-Mar-2022: Update long-polling interface (@creachadair).")]),e._v(" "),i("li",[e._v("10-Feb-2022: Updates to reflect implementation.")]),e._v(" "),i("li",[e._v("26-Jan-2022: Marked accepted.")]),e._v(" "),i("li",[e._v("22-Jan-2022: Updated and expanded (@creachadair).")]),e._v(" "),i("li",[e._v("20-Nov-2021: Initial draft (@creachadair).")])]),e._v(" "),i("hr"),e._v(" "),i("h2",{attrs:{id:"status"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#status"}},[e._v("#")]),e._v(" Status")]),e._v(" "),i("p",[e._v("Accepted")]),e._v(" "),i("hr"),e._v(" "),i("h2",{attrs:{id:"background-context"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#background-context"}},[e._v("#")]),e._v(" Background & Context")]),e._v(" "),i("p",[e._v("For context, see "),i("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/rfc/rfc-006-event-subscription.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 006: Event Subscription"),i("OutboundLink")],1),e._v(".")]),e._v(" "),i("p",[e._v("The "),i("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/rpc/openapi/openapi.yaml",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tendermint RPC service"),i("OutboundLink")],1),e._v(" permits clients to subscribe to the\nevent stream generated by a consensus node. This allows clients to observe the\nstate of the consensus network, including details of the consensus algorithm\nstate machine, proposals, transaction delivery, and block completion. The\napplication may also attach custom key-value attributes to events to expose\napplication-specific details to clients.")]),e._v(" "),i("p",[e._v("The event subscription API in the RPC service currently comprises three methods:")]),e._v(" "),i("ol",[i("li",[i("p",[i("code",[e._v("subscribe")]),e._v(": A request to subscribe to the events matching a specific\n"),i("a",{attrs:{href:"https://pkg.go.dev/github.com/tendermint/tendermint@master/internal/pubsub/query/syntax",target:"_blank",rel:"noopener noreferrer"}},[e._v("query expression"),i("OutboundLink")],1),e._v(". Events can be filtered by their key-value\nattributes, including custom attributes provided by the application.")])]),e._v(" "),i("li",[i("p",[i("code",[e._v("unsubscribe")]),e._v(": A request to cancel an existing subscription based on its\nquery expression.")])]),e._v(" "),i("li",[i("p",[i("code",[e._v("unsubscribe_all")]),e._v(": A request to cancel all existing subscriptions belonging\nto the client.")])])]),e._v(" "),i("p",[e._v("There are some important technical and UX issues with the current RPC event\nsubscription API. The rest of this ADR outlines these problems in detail, and\nproposes a new API scheme intended to address them.")]),e._v(" "),i("h3",{attrs:{id:"issue-1-persistent-connections"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#issue-1-persistent-connections"}},[e._v("#")]),e._v(" Issue 1: Persistent connections")]),e._v(" "),i("p",[e._v("To subscribe to a node's event stream, a client needs a persistent connection\nto the node.  Unlike the other methods of the service, for which each call is\nserviced by a short-lived HTTP round trip, subscription delivers a continuous\nstream of events to the client by hijacking the HTTP channel for a websocket.\nThe stream (and hence the HTTP request) persists until either the subscription\nis explicitly cancelled, or the connection is closed.")]),e._v(" "),i("p",[e._v("There are several problems with this API:")]),e._v(" "),i("ol",[i("li",[i("p",[i("strong",[e._v("Expensive per-connection state")]),e._v(": The server must maintain a substantial\namount of state per subscriber client:")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("The current implementation uses a "),i("a",{attrs:{href:"https://datatracker.ietf.org/doc/html/rfc6455",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebSocket"),i("OutboundLink")],1),e._v(" for each active\nsubscriber. The connection must be maintained even if there are no\nmatching events for a given client.")]),e._v(" "),i("p",[e._v("The server can drop idle connections to save resources, but doing so\nterminates all subscriptions on those connections and forces those clients\nto re-connect, adding additional resource churn for the server.")])]),e._v(" "),i("li",[i("p",[e._v('In addition, the server maintains a separate buffer of undelivered events\nfor each client.  This is to reduce the dual risks that a client will miss\nevents, and that a slow client could "push back" on the publisher,\nimpeding the progress of consensus.')]),e._v(" "),i("p",[e._v("Because event traffic is quite bursty, queues can potentially take up a\nlot of memory. Moreover, each subscriber may have a different filter\nquery, so the server winds up having to duplicate the same events among\nmultiple subscriber queues. Not only does this add memory pressure, but it\ndoes so most at the worst possible time, i.e., when the server is already\nunder load from high event traffic.")])])])]),e._v(" "),i("li",[i("p",[i("strong",[e._v("Operational access control is difficult")]),e._v(": The server's websocket\ninterface exposes "),i("em",[e._v("all")]),e._v(" the RPC service endpoints, not only the subscription\nmethods.  This includes methods that allow callers to inject arbitrary\ntransactions ("),i("code",[e._v("broadcast_tx_*")]),e._v(") and evidence ("),i("code",[e._v("broadcast_evidence")]),e._v(") into the\nnetwork, remove transactions ("),i("code",[e._v("remove_tx")]),e._v("), and request arbitrary amounts of\nchain state.")]),e._v(" "),i("p",[e._v("Filtering requests to the GET endpoint is straightforward: A reverse proxy\nlike "),i("a",{attrs:{href:"https://nginx.org/en/docs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("nginx"),i("OutboundLink")],1),e._v(" can easily filter methods by URL path. Filtering POST\nrequests takes a bit more work, but can be managed with a filter program\nthat speaks "),i("a",{attrs:{href:"http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("FastCGI"),i("OutboundLink")],1),e._v(" and parses JSON-RPC request bodies.")]),e._v(" "),i("p",[e._v("Filtering the websocket interface requires a dedicated proxy implementation.\nAlthough nginx can "),i("a",{attrs:{href:"https://nginx.org/en/docs/http/websocket.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("reverse-proxy websockets"),i("OutboundLink")],1),e._v(", it does not support\nfiltering websocket traffic via FastCGI. The operator would need to either\nimplement a custom "),i("a",{attrs:{href:"https://www.nginx.com/resources/wiki/extending/",target:"_blank",rel:"noopener noreferrer"}},[e._v("nginx extension module"),i("OutboundLink")],1),e._v(" or build and run a\nstandalone proxy that implements websocket and filters each session.  Apart\nfrom the work, this also makes the system even more resource intensive, as\nwell as introducing yet another connection that could potentially time out\nor stall on full buffers.")]),e._v(" "),i("p",[e._v("Even for the simple case of restricting access to only event subscription,\nthere is no easy solution currently: Once a caller has access to the\nwebsocket endpoint, it has complete access to the RPC service.")])])]),e._v(" "),i("h3",{attrs:{id:"issue-2-inconvenient-client-api"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#issue-2-inconvenient-client-api"}},[e._v("#")]),e._v(" Issue 2: Inconvenient client API")]),e._v(" "),i("p",[e._v("The subscription interface has some inconvenient features for the client as\nwell as the server. These include:")]),e._v(" "),i("ol",[i("li",[i("p",[i("strong",[e._v("Non-standard protocol:")]),e._v(" The RPC service is mostly "),i("a",{attrs:{href:"https://www.jsonrpc.org/specification",target:"_blank",rel:"noopener noreferrer"}},[e._v("JSON-RPC 2.0"),i("OutboundLink")],1),e._v(",\nbut the subscription interface diverges from the standard.")]),e._v(" "),i("p",[e._v("In a standard JSON-RPC 2.0 call, the client initiates a request to the\nserver with a unique ID, and the server concludes the call by sending a\nreply for that ID. The "),i("code",[e._v("subscribe")]),e._v(" implementation, however, sends multiple\nresponses to the client's request:")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("The client sends "),i("code",[e._v("subscribe")]),e._v(" with some ID "),i("code",[e._v("x")]),e._v(" and the desired query")])]),e._v(" "),i("li",[i("p",[e._v("The server responds with ID "),i("code",[e._v("x")]),e._v(" and an empty confirmation response.")])]),e._v(" "),i("li",[i("p",[e._v("The server then (repeatedly) sends event result responses with ID "),i("code",[e._v("x")]),e._v(", one\nfor each item with a matching event.")])])]),e._v(" "),i("p",[e._v("Standard JSON-RPC clients will reject the subsequent replies, as they\nannounce a request ID ("),i("code",[e._v("x")]),e._v(") that is already complete. This means a caller\nhas to implement Tendermint-specific handling for these responses.")]),e._v(" "),i("p",[e._v("Moreover, the result format is different between the initial confirmation\nand the subsequent responses.  This means a caller has to implement special\nlogic for decoding the first response versus the subsequent ones.")])]),e._v(" "),i("li",[i("p",[i("strong",[e._v("No way to detect data loss:")]),e._v(" The subscriber connection can be terminated\nfor many reasons. Even ignoring ordinary network issues (e.g., packet loss):")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("The server will drop messages and/or close the websocket if its write\nbuffer fills, or if the queue of undelivered matching events is not\ndrained fast enough. The client has no way to discover that messages were\ndropped even if the connection remains open.")])]),e._v(" "),i("li",[i("p",[e._v("Either the client or the server may close the websocket if the websocket\nPING and PONG exchanges are not handled correctly, or frequently enough.\nEven if correctly implemented, this may fail if the system is under high\nload and cannot service those control messages in a timely manner.")])])]),e._v(" "),i("p",[e._v("When the connection is terminated, the server drops all the subscriptions\nfor that client (as if it had called "),i("code",[e._v("unsubscribe_all")]),e._v("). Even if the client\nreconnects, any events that were published during the period between the\ndisconnect and re-connect and re-subscription will be silently lost, and the\nclient has no way to discover that it missed some relevant messages.")])]),e._v(" "),i("li",[i("p",[i("strong",[e._v("No way to replay old events:")]),e._v(' Even if a client knew it had missed some\nevents (due to a disconnection, for example), the API provides no way for\nthe client to "play back" events it may have missed.')])]),e._v(" "),i("li",[i("p",[i("strong",[e._v("Large response sizes:")]),e._v(" Some event data can be quite large, and there can\nbe substantial duplication across items. The API allows the client to select\n"),i("em",[e._v("which")]),e._v(" events are reported, but has no way to control which parts of a\nmatching event it wishes to receive.")]),e._v(" "),i("p",[e._v("This can be costly on the server (which has to marshal those data into\nJSON), the network, and the client (which has to unmarshal the result and\nthen pick through for the components that are relevant to it).")]),e._v(" "),i("p",[e._v("Besides being inefficient, this also contributes to some of the persistent\nconnection issues mentioned above, e.g., filling up the websocket write\nbuffer and forcing the server to queue potentially several copies of a large\nvalue in memory.")])]),e._v(" "),i("li",[i("p",[i("strong",[e._v("Client identity is tied to network address:")]),e._v(' The Tendermint event API\nidentifies each subscriber by a (Client ID, Query) pair. In the RPC service,\nthe query is provided by the client, but the client ID is set to the TCP\naddress of the client (typically "host:port" or "ip:port").')]),e._v(" "),i("p",[e._v("This means that even if the server did "),i("em",[e._v("not")]),e._v(" drop subscriptions immediately\nwhen the websocket connection is closed, a client may not be able to\nreattach to its existing subscription.  Dialing a new connection is likely\nto result in a different port (and, depending on their own proxy setup,\npossibly a different public IP).")]),e._v(" "),i("p",[e._v("In isolation, this problem would be easy to work around with a new\nsubscription parameter, but it would require several other changes to the\nhandling of event subscriptions for that workaround to become useful.")])])]),e._v(" "),i("hr"),e._v(" "),i("h2",{attrs:{id:"decision"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#decision"}},[e._v("#")]),e._v(" Decision")]),e._v(" "),i("p",[e._v("To address the described problems, we will:")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("Introduce a new API for event subscription to the Tendermint RPC service.\nThe proposed API is described in "),i("a",{attrs:{href:"#detailed-design"}},[e._v("Detailed Design")]),e._v(" below.")])]),e._v(" "),i("li",[i("p",[e._v('This new API will target the Tendermint v0.36 release, during which the\ncurrent ("streaming") API will remain available as-is, but deprecated.')])]),e._v(" "),i("li",[i("p",[e._v("The streaming API will be entirely removed in release v0.37, which will\nrequire all users of event subscription to switch to the new API.")])])]),e._v(" "),i("blockquote",[i("p",[i("strong",[e._v("Point for discussion:")]),e._v(" Given that ABCI++ and PBTS are the main priorities\nfor v0.36, it would be fine to slip the first phase of this work to v0.37.\nUnless there is a time problem, however, the proposed design does not disrupt\nthe work on ABCI++ or PBTS, and will not increase the scope of breaking\nchanges. Therefore the plan is to begin in v0.36 and slip only if necessary.")])]),e._v(" "),i("hr"),e._v(" "),i("h2",{attrs:{id:"detailed-design"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#detailed-design"}},[e._v("#")]),e._v(" Detailed Design")]),e._v(" "),i("h3",{attrs:{id:"design-goals"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#design-goals"}},[e._v("#")]),e._v(" Design Goals")]),e._v(" "),i("p",[e._v("Specific goals of this design include:")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("Remove the need for a persistent connection to each subscription client.\nSubscribers should use the same HTTP request flow for event subscription\nrequests as for other RPC calls.")])]),e._v(" "),i("li",[i("p",[e._v("The server retains minimal state (possibly none) per-subscriber.  In\nparticular:")]),e._v(" "),i("ul",[i("li",[e._v("The server does not buffer unconsumed writes nor queue undelivered events\non a per-client basis.")]),e._v(" "),i("li",[e._v("A client that stalls or goes idle does not cost the server any resources.")]),e._v(" "),i("li",[e._v("Any event data that is buffered or stored is shared among "),i("em",[e._v("all")]),e._v("\nsubscribers, and is not duplicated per client.")])])]),e._v(" "),i("li",[i("p",[e._v("Slow clients have no impact (or minimal impact) on the rate of progress of\nthe consensus algorithm, beyond the ambient overhead of servicing individual\nRPC requests.")])]),e._v(" "),i("li",[i("p",[e._v('Clients can tell when they have missed events matching their subscription,\nwithin some reasonable (configurable) window of time, and can "replay"\nevents within that window to catch up.')])]),e._v(" "),i("li",[i("p",[e._v("Nice to have: It should be easy to use the event subscription API from\nexisting standard tools and libraries, including command-line use for\ntesting and experimentation.")])])]),e._v(" "),i("h3",{attrs:{id:"definitions"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#definitions"}},[e._v("#")]),e._v(" Definitions")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("The "),i("strong",[e._v("event stream")]),e._v(" of a node is a single, time-ordered, heterogeneous\nstream of event items.")])]),e._v(" "),i("li",[i("p",[e._v("Each "),i("strong",[e._v("event item")]),e._v(" comprises an "),i("strong",[e._v("event datum")]),e._v(" (for example, block header\nmetadata for a new-block event), and zero or more optional "),i("strong",[e._v("events")]),e._v(".")])]),e._v(" "),i("li",[i("p",[e._v("An "),i("strong",[e._v("event")]),e._v(" means the "),i("a",{attrs:{href:"https://pkg.go.dev/github.com/tendermint/tendermint/abci/types#Event",target:"_blank",rel:"noopener noreferrer"}},[e._v("ABCI "),i("code",[e._v("Event")]),e._v(" data type"),i("OutboundLink")],1),e._v(", which comprises\na string type and zero or more string key-value "),i("strong",[e._v("event attributes")]),e._v(".")]),e._v(" "),i("p",[e._v('The use of the new terms "event item" and "event datum" is to avert confusion\nbetween the values that are published to the event bus (what we call here\n"event items") and the ABCI '),i("code",[e._v("Event")]),e._v(" data type.")])]),e._v(" "),i("li",[i("p",[e._v("The node assigns each event item a unique identifier string called a\n"),i("strong",[e._v("cursor")]),e._v(".  A cursor must be unique among all events published by a single\nnode, but it is not required to be unique globally across nodes.")]),e._v(" "),i("p",[e._v("Cursors are time-ordered so that given event items A and B, if A was\npublished before B, then cursor(A) < cursor(B) in lexicographic order.")]),e._v(" "),i("p",[e._v("A minimum viable cursor implementation is a tuple consisting of a timestamp\nand a sequence number (e.g., "),i("code",[e._v("16CCC798FB5F4670-0123")]),e._v("). However, it may also\nbe useful to append basic type information to a cursor, to allow efficient\nfiltering (e.g., "),i("code",[e._v("16CCC87E91869050-0091:BeginBlock")]),e._v(").")]),e._v(" "),i("p",[e._v("The initial implementation will use the minimum viable format.")])])]),e._v(" "),i("h3",{attrs:{id:"discussion"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#discussion"}},[e._v("#")]),e._v(" Discussion")]),e._v(" "),i("p",[e._v("The node maintains an "),i("strong",[e._v("event log")]),e._v(", a shared ordered record of the events\npublished to its event bus within an operator-configurable time window.  The\ninitial implementation will store the event log in-memory, and the operator\nwill be given two per-node configuration settings.  Note, these names are\nprovisional:")]),e._v(" "),i("ul",[i("li",[i("p",[i("code",[e._v("[rpc] event-log-window-size")]),e._v(": A duration before the latest published event,\nduring which the node will retain event items published. Setting this value\nto zero disables event subscription.")])]),e._v(" "),i("li",[i("p",[i("code",[e._v("[rpc] event-log-max-items")]),e._v(": A maximum number of event items that the node\nwill retain within the time window. If the number of items exceeds this\nvalue, the node discardes the oldest items in the window. Setting this value\nto zero means that no limit is imposed on the number of items.")])])]),e._v(" "),i("p",[e._v("The node will retain all events within the time window, provided they do not\nexceed the maximum number.  These config parameters allow the operator to\nloosely regulate how much memory and storage the node allocates to the event\nlog. The client can use the server reply to tell whether the events it wants\nare still available from the event log.")]),e._v(" "),i("p",[e._v("The event log is shared among all subscribers to the node.")]),e._v(" "),i("blockquote",[i("p",[i("strong",[e._v("Discussion point:")]),e._v(" Should events persist across node restarts?")]),e._v(" "),i("p",[e._v('The current event API does not persist events across restarts, so this new\ndesign does not either. Note, however, that we may "spill" older event data\nto disk as a way of controlling memory use. Such usage is ephemeral, however,\nand does not need to be tracked as node data (e.g., it could be temp files).')])]),e._v(" "),i("h3",{attrs:{id:"query-api"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#query-api"}},[e._v("#")]),e._v(" Query API")]),e._v(" "),i("p",[e._v("To retrieve event data, the client will call the (new) RPC method "),i("code",[e._v("events")]),e._v(".\nThe parameters of this method will correspond to the following Go types:")]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBFdmVudFBhcmFtcyBzdHJ1Y3QgewogICAgLy8gT3B0aW9uYWwgZmlsdGVyIHNwZWMuIElmIG5pbCBvciBlbXB0eSwgYWxsIGl0ZW1zIGFyZSBlbGlnaWJsZS4KICAgIEZpbHRlciAqRmlsdGVyIGBqc29uOiZxdW90O2ZpbHRlciZxdW90O2AKCiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZWxpZ2libGUgcmVzdWx0cyB0byByZXR1cm4uCiAgICAvLyBJZiB6ZXJvIG9yIG5lZ2F0aXZlLCB0aGUgc2VydmVyIHdpbGwgcmVwb3J0IGEgZGVmYXVsdCBudW1iZXIuCiAgICBNYXhSZXN1bHRzIGludCBganNvbjomcXVvdDttYXhfcmVzdWx0cyZxdW90O2AKCiAgICAvLyBSZXR1cm4gb25seSBpdGVtcyBhZnRlciB0aGlzIGN1cnNvci4gSWYgZW1wdHksIHRoZSBsaW1pdCBpcyBqdXN0CiAgICAvLyBiZWZvcmUgdGhlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGV2ZW50IGxvZy4KICAgIEFmdGVyIHN0cmluZyBganNvbjomcXVvdDthZnRlciZxdW90O2AKCiAgICAvLyBSZXR1cm4gb25seSBpdGVtcyBiZWZvcmUgdGhpcyBjdXJzb3IuICBJZiBlbXB0eSwgdGhlIGxpbWl0IGlzIGp1c3QKICAgIC8vIGFmdGVyIHRoZSBoZWFkIG9mIHRoZSBldmVudCBsb2cuCiAgICBCZWZvcmUgc3RyaW5nIGBqc29uOiZxdW90O2JlZm9yZSZxdW90O2AKCiAgICAvLyBXYWl0IGZvciB1cCB0byB0aGlzIGxvbmcgZm9yIGV2ZW50cyB0byBiZSBhdmFpbGFibGUuCiAgICBXYWl0VGltZSB0aW1lLkR1cmF0aW9uIGBqc29uOiZxdW90O3dhaXRfdGltZSZxdW90O2AKfQoKdHlwZSBGaWx0ZXIgc3RydWN0IHsKICAgIFF1ZXJ5IHN0cmluZyBganNvbjomcXVvdDtxdWVyeSZxdW90O2AKfQo="}}),e._v(" "),i("blockquote",[i("p",[i("strong",[e._v("Discussion point:")]),e._v(" The initial implementation will not cache filter\nqueries for the client. If this turns out to be a performance issue in\nproduction, the service can keep a small shared cache of compiled queries.\nGiven the improvements from #7319 et seq., this should not be necessary.")])]),e._v(" "),i("blockquote",[i("p",[i("strong",[e._v("Discussion point:")]),e._v(" For the initial implementation, the new API will use\nthe existing query language as-is. Future work may extend the Filter message\nwith a more structured and/or expressive query surface, but that is beyond\nthe scope of this design.")])]),e._v(" "),i("p",[e._v("The semantics of the request are as follows: An item in the event log is\n"),i("strong",[e._v("eligible")]),e._v(" for a query if:")]),e._v(" "),i("ul",[i("li",[e._v("It is newer than the "),i("code",[e._v("after")]),e._v(" cursor (if set).")]),e._v(" "),i("li",[e._v("It is older than the "),i("code",[e._v("before")]),e._v(" cursor (if set).")]),e._v(" "),i("li",[e._v("It matches the filter (if set).")])]),e._v(" "),i("p",[e._v("Among the eligible items in the log, the server returns up to "),i("code",[e._v("max_results")]),e._v(" of\nthe newest items, in reverse order of cursor. If "),i("code",[e._v("max_results")]),e._v(" is unset the\nserver chooses a number to return, and will cap "),i("code",[e._v("max_results")]),e._v(" at a sensible\nlimit.")]),e._v(" "),i("p",[e._v("The "),i("code",[e._v("wait_time")]),e._v(" parameter is used to effect polling. If "),i("code",[e._v("before")]),e._v(" is empty and\nno items are available, the server will wait for up to "),i("code",[e._v("wait_time")]),e._v(" for matching\nitems to arrive at the head of the log. If "),i("code",[e._v("wait_time")]),e._v(" is zero or negative, the\nserver will wait for a default (positive) interval.")]),e._v(" "),i("p",[e._v("If "),i("code",[e._v("before")]),e._v(" non-empty, "),i("code",[e._v("wait_time")]),e._v(' is ignored: new results are only added to\nthe head of the log, so there is no need to wait.  This allows the client to\npoll for new data, and "page" backward through matching event items. This is\ndiscussed in more detail below.')]),e._v(" "),i("p",[e._v("The server will set a sensible cap on the maximum "),i("code",[e._v("wait_time")]),e._v(", overriding\nclient-requested intervals longer than that.")]),e._v(" "),i("p",[e._v("A successful reply from the "),i("code",[e._v("events")]),e._v(" request corresponds to the following Go\ntypes:")]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBFdmVudFJlcGx5IHN0cnVjdCB7CiAgICAvLyBUaGUgaXRlbXMgbWF0Y2hpbmcgdGhlIHJlcXVlc3QgcGFyYW1ldGVycywgZnJvbSBuZXdlc3QKICAgIC8vIHRvIG9sZGVzdCwgaWYgYW55IHdlcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGUgdGltZW91dC4KICAgIEl0ZW1zIFtdKkV2ZW50SXRlbSBganNvbjomcXVvdDtpdGVtcyZxdW90O2AKCiAgICAvLyBUaGlzIGlzIHRydWUgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIG9sZGVyIG1hdGNoaW5nIGl0ZW0KICAgIC8vIGF2YWlsYWJsZSBpbiB0aGUgbG9nIHRoYXQgd2FzIG5vdCByZXR1cm5lZC4KICAgIE1vcmUgYm9vbCBganNvbjomcXVvdDttb3JlJnF1b3Q7YAoKICAgIC8vIFRoZSBjdXJzb3Igb2YgdGhlIG9sZGVzdCBpdGVtIGluIHRoZSBsb2cgYXQgdGhlIHRpbWUgb2YgdGhpcyByZXBseSwKICAgIC8vIG9yICZxdW90OyZxdW90OyBpZiB0aGUgbG9nIGlzIGVtcHR5LgogICAgT2xkZXN0IHN0cmluZyBganNvbjomcXVvdDtvbGRlc3QmcXVvdDtgCgogICAgLy8gVGhlIGN1cnNvciBvZiB0aGUgbmV3ZXN0IGl0ZW0gaW4gdGhlIGxvZyBhdCB0aGUgdGltZSBvZiB0aGlzIHJlcGx5LAogICAgLy8gb3IgJnF1b3Q7JnF1b3Q7IGlmIHRoZSBsb2cgaXMgZW1wdHkuCiAgICBOZXdlc3Qgc3RyaW5nIGBqc29uOiZxdW90O25ld2VzdCZxdW90O2AKfQoKdHlwZSBFdmVudEl0ZW0gc3RydWN0IHsKICAgIC8vIFRoZSBjdXJzb3Igb2YgdGhpcyBpdGVtLgogICAgQ3Vyc29yIHN0cmluZyBganNvbjomcXVvdDtjdXJzb3ImcXVvdDtgCgogICAgLy8gVGhlIGVuY29kZWQgZXZlbnQgZGF0YSBmb3IgdGhpcyBpdGVtLgogICAgLy8gVGhlIHR5cGUgaWRlbnRpZmllcyB0aGUgc3RydWN0dXJlIG9mIHRoZSB2YWx1ZS4KICAgIERhdGEgc3RydWN0IHsKICAgICAgICBUeXBlICBzdHJpbmcgICAgICAgICAgYGpzb246JnF1b3Q7dHlwZSZxdW90O2AKICAgICAgICBWYWx1ZSBqc29uLlJhd01lc3NhZ2UgYGpzb246JnF1b3Q7dmFsdWUmcXVvdDtgCiAgICB9IGBqc29uOiZxdW90O2RhdGEmcXVvdDtgCn0K"}}),e._v(" "),i("p",[e._v("The "),i("code",[e._v("oldest")]),e._v(" and "),i("code",[e._v("newest")]),e._v(" fields of the reply report the cursors of the oldest\nand newest items (of any kind) recorded in the event log at the time of the\nreply, or are "),i("code",[e._v('""')]),e._v(" if the log is empty.")]),e._v(" "),i("p",[e._v("The "),i("code",[e._v("data")]),e._v(" field contains the type-specific event datum.  The datum carries any\nABCI events that may have been defined.")]),e._v(" "),i("blockquote",[i("p",[i("strong",[e._v("Discussion point")]),e._v(": Based on "),i("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/7273",target:"_blank",rel:"noopener noreferrer"}},[e._v("issue #7273"),i("OutboundLink")],1),e._v(", I did not include a\nseparate field in the response for the ABCI events, since it duplicates data\nalready stored elsewhere in the event data.")])]),e._v(" "),i("p",[e._v("The semantics of the reply are as follows:")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("If "),i("code",[e._v("items")]),e._v(" is non-empty:")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Items are ordered from newest to oldest.")])]),e._v(" "),i("li",[i("p",[e._v("If "),i("code",[e._v("more")]),e._v(" is true, there is at least one additional, older item in the\nevent log that was not returned (in excess of "),i("code",[e._v("max_results")]),e._v(").")]),e._v(" "),i("p",[e._v("In this case the client can fetch the next page by setting "),i("code",[e._v("before")]),e._v(" in a\nnew request, to the cursor of the oldest item fetched (i.e., the last one\nin "),i("code",[e._v("items")]),e._v(").")])]),e._v(" "),i("li",[i("p",[e._v("Otherwise (if "),i("code",[e._v("more")]),e._v(" is false), all the matching results have been\nreported (pagination is complete).")])]),e._v(" "),i("li",[i("p",[e._v("The first element of "),i("code",[e._v("items")]),e._v(" identifies the newest item considered.\nSubsequent poll requests can set "),i("code",[e._v("after")]),e._v(" to this cursor to skip items\nthat were already retrieved.")])])])]),e._v(" "),i("li",[i("p",[e._v("If "),i("code",[e._v("items")]),e._v(" is empty:")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("If the "),i("code",[e._v("before")]),e._v(" was set in the request, there are no further eligible\nitems for this query in the log (pagination is complete).")]),e._v(" "),i("p",[e._v("This is just a safety case; the client can detect this without issuing\nanother call by consulting the "),i("code",[e._v("more")]),e._v(" field of the previous reply.")])]),e._v(" "),i("li",[i("p",[e._v("If the "),i("code",[e._v("before")]),e._v(" was empty in the request, no eligible items were\navailable before the "),i("code",[e._v("wait_time")]),e._v(" expired. The client may poll again to\nwait for more event items.")])])])])]),e._v(" "),i("p",[e._v("A client can store cursor values to detect data loss and to recover from\ncrashes and connectivity issues:")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("After a crash, the client requests events after the newest cursor it has\nseen.  If the reply indicates that cursor is no longer in range, the client\nmay (conservatively) conclude some event data may have been lost.")])]),e._v(" "),i("li",[i("p",[e._v("On the other hand, if it "),i("em",[e._v("is")]),e._v(" in range, the client can then page back through\nthe results that it missed, and then resume polling. As long as its recovery\ncursor does not age out before it finishes, the client can be sure it has all\nthe relevant results.")])])]),e._v(" "),i("h3",{attrs:{id:"other-notes"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#other-notes"}},[e._v("#")]),e._v(" Other Notes")]),e._v(" "),i("ul",[i("li",[i("p",[e._v('The new API supports two general "modes" of operation:')]),e._v(" "),i("ol",[i("li",[i("p",[e._v("In ordinary operation, clients will "),i("strong",[e._v("long-poll")]),e._v(" the head of the event\nlog for new events matching their criteria (by setting a "),i("code",[e._v("wait_time")]),e._v(" and\nno "),i("code",[e._v("before")]),e._v(").")])]),e._v(" "),i("li",[i("p",[e._v("If there are more events than the client requested, or if the client needs\nto to read older events to recover from a stall or crash, clients will\n"),i("strong",[e._v("page")]),e._v(" backward through the event log (by setting "),i("code",[e._v("before")]),e._v(" and "),i("code",[e._v("after")]),e._v(").")])])])]),e._v(" "),i("li",[i("p",[e._v("While the new API requires explicit polling by the client, it makes better\nuse of the node's existing HTTP infrastructure (e.g., connection pools).\nMoreover, the direct implementation is easier to use from standard tools and\nclient libraries for HTTP and JSON-RPC.")]),e._v(" "),i("p",[e._v("Explicit polling does shift the burden of timeliness to the client.  That is\narguably preferable, however, given that the RPC service is ancillary to the\nnode's primary goal, viz., consensus. The details of polling can be easily\nhidden from client applications with simple libraries.")])]),e._v(" "),i("li",[i("p",[e._v("The format of a cursor is considered opaque to the client. Clients must not\nparse cursor values, but they may rely on their ordering properties.")])]),e._v(" "),i("li",[i("p",[e._v("To maintain the event log, the server must prune items outside the time\nwindow and in excess of the item limit.")]),e._v(" "),i("p",[e._v("The initial implementation will do this by checking the tail of the event log\nafter each new item is published. If the number of items in the log exceeds\nthe item limit, it will delete oldest items until the log is under the limit;\nthen discard any older than the time window before the latest.")]),e._v(" "),i("p",[e._v("To minimize coordination interference between the publisher (the event bus)\nand the subcribers (the "),i("code",[e._v("events")]),e._v(' service handlers), the event log will be\nstored as a persistent linear queue with shared structure (a cons list).  A\nsingle reader-writer mutex will guard the "head" of the queue where new\nitems are published:')]),e._v(" "),i("ul",[i("li",[i("p",[i("strong",[e._v("To publish a new item")]),e._v(", the publisher acquires the write lock, conses a\nnew item to the front of the existing queue, and replaces the head pointer\nwith the new item.")])]),e._v(" "),i("li",[i("p",[i("strong",[e._v("To scan the queue")]),e._v(", a reader acquires the read lock, captures the head\npointer, and then releases the lock. The rest of its request can be served\nwithout holding a lock, since the queue structure will not change.")]),e._v(" "),i("p",[e._v("When a reader wants to wait, it will yield the lock and wait on a condition\nthat is signaled when the publisher swings the pointer.")])]),e._v(" "),i("li",[i("p",[i("strong",[e._v("To prune the queue")]),e._v(", the publisher (who is the sole writer) will track\nthe queue length and the age of the oldest item separately.  When the\nlength and or age exceed the configured bounds, it will construct a new\nqueue spine on the same items, discarding out-of-band values.")]),e._v(" "),i("p",[e._v("Pruning can be done while the publisher already holds the write lock, or\ncould be done outside the lock entirely: Once the new queue is constructed,\nthe lock can be re-acquired to swing the pointer. This costs some extra\nallocations for the cons cells, but avoids duplicating any event items.\nThe pruning step is a simple linear scan down the first (up to) max-items\nelements of the queue, to find the breakpoint of age and length.")]),e._v(" "),i("p",[e._v('Moreover, the publisher can amortize the cost of pruning by item count, if\nnecessary, by pruning length "more aggressively" than the configuration\nrequires (e.g., reducing to 3/4 of the maximum rather than 1/1).')]),e._v(" "),i("p",[e._v("The state of the event log before the publisher acquires the lock:\n"),i("img",{attrs:{src:n(576),alt:"Before publish and pruning"}})]),e._v(" "),i("p",[e._v("After the publisher has added a new item and pruned old ones:\n"),i("img",{attrs:{src:n(577),alt:"After publish and pruning"}})])])])])]),e._v(" "),i("h3",{attrs:{id:"migration-plan"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#migration-plan"}},[e._v("#")]),e._v(" Migration Plan")]),e._v(" "),i("p",[e._v("This design requires that clients eventually migrate to the new event\nsubscription API, but provides a full release cycle with both APIs in place to\nmake this burden more tractable. The migration strategy is broadly:")]),e._v(" "),i("p",[i("strong",[e._v("Phase 1")]),e._v(": Release v0.36.")]),e._v(" "),i("ul",[i("li",[e._v("Implement the new "),i("code",[e._v("events")]),e._v(" endpoint, keeping the existing methods as they are.")]),e._v(" "),i("li",[e._v("Update the Go clients to support the new "),i("code",[e._v("events")]),e._v(" endpoint, and handle polling.")]),e._v(" "),i("li",[e._v("Update the old endpoints to log annoyingly about their own deprecation.")]),e._v(" "),i("li",[e._v("Write tutorials about how to migrate client usage.")])]),e._v(" "),i("p",[e._v("At or shortly after release, we should proactively update the Cosmos SDK to use\nthe new API, to remove a disincentive to upgrading.")]),e._v(" "),i("p",[i("strong",[e._v("Phase 2")]),e._v(": Release v0.37")]),e._v(" "),i("ul",[i("li",[e._v("During development, we should actively seek out any existing users of the\nstreaming event subscription API and help them migrate.")]),e._v(" "),i("li",[e._v("Possibly also: Spend some time writing clients for JS, Rust, et al.")]),e._v(" "),i("li",[e._v("Release: Delete the old implementation and all the websocket support code.")])]),e._v(" "),i("blockquote",[i("p",[i("strong",[e._v("Discussion point")]),e._v(": Even though the plan is to keep the existing service,\nwe might take the opportunity to restrict the websocket endpoint to "),i("em",[e._v("only")]),e._v("\nthe event streaming service, removing the other endpoints. To minimize the\ndisruption for users in the v0.36 cycle, I have decided not to do this for\nthe first phase.")]),e._v(" "),i("p",[e._v("If we wind up pushing this design into v0.37, however, we should re-evaulate\nthis partial turn-down of the websocket.")])]),e._v(" "),i("h3",{attrs:{id:"future-work"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#future-work"}},[e._v("#")]),e._v(" Future Work")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("This design does not immediately address the problem of allowing the client\nto control which data are reported back for event items. That concern is\ndeferred to future work. However, it would be straightforward to extend the\nfilter and/or the request parameters to allow more control.")])]),e._v(" "),i("li",[i("p",[e._v("The node currently stores a subset of event data (specifically the block and\ntransaction events) for use in reindexing. While these data are redundant\nwith the event log described in this document, they are not sufficient to\ncover event subscription, as they omit other event types.")]),e._v(" "),i("p",[e._v("In the future we should investigate consolidating or removing event data from\nthe state store entirely. For now this issue is out of scope for purposes of\nupdating the RPC API. We may be able to piggyback on the database unification\nplans (see "),i("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/rfc/rfc-001-storage-engine.rst",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 001"),i("OutboundLink")],1),e._v(") to store the event log separately, so its\npruning policy does not need to be tied to the block and state stores.")])]),e._v(" "),i("li",[i("p",[e._v("This design reuses the existing filter query language from the old API.  In\nthe future we may want to use a more structured and/or expressive query.  The\nFilter object can be extended with more fields as needed to support this.")])]),e._v(" "),i("li",[i("p",[e._v("Some users have trouble communicating with the RPC service because of\nconfiguration problems like improperly-set CORS policies. While this design\ndoes not address those issues directly, we might want to revisit how we set\npolicies in the RPC service to make it less susceptible to confusing errors\ncaused by misconfiguration.")])])]),e._v(" "),i("hr"),e._v(" "),i("h2",{attrs:{id:"consequences"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#consequences"}},[e._v("#")]),e._v(" Consequences")]),e._v(" "),i("ul",[i("li",[e._v("✅ Reduces the number of transport options for RPC.  Supports "),i("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/rfc/rfc-002-ipc-ecosystem.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 002"),i("OutboundLink")],1),e._v(".")]),e._v(" "),i("li",[e._v("️✅ Removes the primary non-standard use of JSON-RPC.")]),e._v(" "),i("li",[e._v("⛔️ Forces clients to migrate to a different API (eventually).")]),e._v(" "),i("li",[e._v("↕️  API requires clients to poll, but this reduces client state on the server.")]),e._v(" "),i("li",[e._v("↕️  We have to maintain both implementations for a whole release, but this\ngives clients time to migrate.")])]),e._v(" "),i("hr"),e._v(" "),i("h2",{attrs:{id:"alternative-approaches"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#alternative-approaches"}},[e._v("#")]),e._v(" Alternative Approaches")]),e._v(" "),i("p",[e._v("The following alternative approaches were considered:")]),e._v(" "),i("ol",[i("li",[i("p",[i("strong",[e._v("Leave it alone.")]),e._v(" Since existing tools mostly already work with the API as\nit stands today, we could leave it alone and do our best to improve its\nperformance and reliability.")]),e._v(" "),i("p",[e._v("Based on many issues reported by users and node operators (e.g.,\n"),i("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/3380",target:"_blank",rel:"noopener noreferrer"}},[e._v("#3380"),i("OutboundLink")],1),e._v(", "),i("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/6439",target:"_blank",rel:"noopener noreferrer"}},[e._v("#6439"),i("OutboundLink")],1),e._v(", "),i("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/6729",target:"_blank",rel:"noopener noreferrer"}},[e._v("#6729"),i("OutboundLink")],1),e._v(", "),i("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/7247",target:"_blank",rel:"noopener noreferrer"}},[e._v("#7247"),i("OutboundLink")],1),e._v("), the\nproblems described here affect even the existing use that works.  Investing\nfurther incremental effort in the existing API is unlikely to address these\nissues.")])]),e._v(" "),i("li",[i("p",[i("strong",[e._v("Design a better streaming API.")]),e._v(' Instead of polling, we might try to\ndesign a better "streaming" API for event subscription.')]),e._v(" "),i("p",[e._v("A significant advantage of switching away from streaming is to remove the\nneed for persistent connections between the node and subscribers.  A new\nstreaming protocol design would lose that advantage, and would still need a\nway to let clients recover and replay.")]),e._v(" "),i("p",[e._v("This approach might look better if we decided to use a different protocol\nfor event subscription, say gRPC instead of JSON-RPC. That choice, however,\nwould be just as breaking for existing clients, for marginal benefit.\nMoreover, this option increases both the complexity and the resource cost on\nthe node implementation.")]),e._v(" "),i("p",[e._v("Given that resource consumption and complexity are important considerations,\nthis option was not chosen.")])]),e._v(" "),i("li",[i("p",[i("strong",[e._v("Defer to an external event broker.")]),e._v(" We might remove the entire event\nsubscription infrastructure from the node, and define an optional interface\nto allow the node to publish all its events to an external event broker,\nsuch as Apache Kafka.")]),e._v(" "),i("p",[e._v("This has the advantage of greatly simplifying the node, but at a great cost\nto the node operator: To enable event subscription in this design, the\noperator has to stand up and maintain a separate process in communion with\nthe node, and configuration changes would have to be coordinated across\nboth.")]),e._v(" "),i("p",[e._v("Moreover, this approach would be highly disruptive to existing client use,\nand migration would probably require switching to third-party libraries.\nDespite the potential benefits for the node itself, the costs to operators\nand clients seems too large for this to be the best option.")]),e._v(" "),i("p",[e._v("Publishing to an external event broker might be a worthwhile future project,\nif there is any demand for it. That decision is out of scope for this design,\nas it interacts with the design of the indexer as well.")])])]),e._v(" "),i("hr"),e._v(" "),i("h2",{attrs:{id:"references"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/rfc/rfc-006-event-subscription.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 006: Event Subscription"),i("OutboundLink")],1)]),e._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/rpc/openapi/openapi.yaml",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tendermint RPC service"),i("OutboundLink")],1)]),e._v(" "),i("li",[i("a",{attrs:{href:"https://pkg.go.dev/github.com/tendermint/tendermint@master/internal/pubsub/query/syntax",target:"_blank",rel:"noopener noreferrer"}},[e._v("Event query grammar"),i("OutboundLink")],1)]),e._v(" "),i("li",[i("a",{attrs:{href:"https://datatracker.ietf.org/doc/html/rfc6455",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 6455: The WebSocket protocol"),i("OutboundLink")],1)]),e._v(" "),i("li",[i("a",{attrs:{href:"https://www.jsonrpc.org/specification",target:"_blank",rel:"noopener noreferrer"}},[e._v("JSON-RPC 2.0 Specification"),i("OutboundLink")],1)]),e._v(" "),i("li",[i("a",{attrs:{href:"https://nginx.org/en/docs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Nginx proxy server"),i("OutboundLink")],1),e._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"https://nginx.org/en/docs/http/websocket.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Proxying websockets"),i("OutboundLink")],1)]),e._v(" "),i("li",[i("a",{attrs:{href:"https://www.nginx.com/resources/wiki/extending/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Extension modules"),i("OutboundLink")],1)])])]),e._v(" "),i("li",[i("a",{attrs:{href:"http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("FastCGI"),i("OutboundLink")],1)]),e._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/rfc/rfc-001-storage-engine.rst",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 001: Storage Engines & Database Layer"),i("OutboundLink")],1)]),e._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/rfc/rfc-002-ipc-ecosystem.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 002: Interprocess Communication in Tendermint"),i("OutboundLink")],1)]),e._v(" "),i("li",[e._v("Issues:\n"),i("ul",[i("li",[i("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/3380",target:"_blank",rel:"noopener noreferrer"}},[e._v("rpc/client: test that client resubscribes upon disconnect"),i("OutboundLink")],1),e._v(" (#3380)")]),e._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/6439",target:"_blank",rel:"noopener noreferrer"}},[e._v("Too high memory usage when creating many events subscriptions"),i("OutboundLink")],1),e._v(" (#6439)")]),e._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/6729",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tendermint emits events faster than clients can pull them"),i("OutboundLink")],1),e._v(" (#6729)")]),e._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/7247",target:"_blank",rel:"noopener noreferrer"}},[e._v("indexer: unbuffered event subscription slow down the consensus"),i("OutboundLink")],1),e._v(" (#7247)")]),e._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/7273",target:"_blank",rel:"noopener noreferrer"}},[e._v("rpc: remove duplication of events when querying"),i("OutboundLink")],1),e._v(" (#7273)")])])])])],1)}),[],!1,null,null,null);t.default=s.exports}}]);