(window.webpackJsonp=window.webpackJsonp||[]).push([[227],{803:function(e,t,i){"use strict";i.r(t);var a=i(1),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"light-client-verification"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#light-client-verification"}},[e._v("#")]),e._v(" Light Client Verification")]),e._v(" "),i("p",[e._v("The light client implements a read operation of a\n"),i("a",{attrs:{href:"#tmbc-header1"}},[e._v("header")]),e._v(" from the "),i("a",{attrs:{href:"#tmbc-seq1"}},[e._v("blockchain")]),e._v(", by\ncommunicating with full nodes.  As some full nodes may be faulty, this\nfunctionality must be implemented in a fault-tolerant way.")]),e._v(" "),i("p",[e._v("In the Tendermint blockchain, the validator set may change with every\nnew block.  The staking and unbonding mechanism induces a "),i("a",{attrs:{href:"#tmbc-fm-2thirds1"}},[e._v("security\nmodel")]),e._v(": starting at time "),i("em",[e._v("Time")]),e._v(" of the\n"),i("a",{attrs:{href:"#tmbc-header1"}},[e._v("header")]),e._v(",\nmore than two-thirds of the next validators of a new block are correct\nfor the duration of "),i("em",[e._v("TrustedPeriod")]),e._v(". The fault-tolerant read\noperation is designed for this security model.")]),e._v(" "),i("p",[e._v("The challenge addressed here is that the light client might have a\nblock of height "),i("em",[e._v("h1")]),e._v(" and needs to read the block of height "),i("em",[e._v("h2")]),e._v("\ngreater than "),i("em",[e._v("h1")]),e._v(".  Checking all headers of heights from "),i("em",[e._v("h1")]),e._v(" to "),i("em",[e._v("h2")]),e._v("\nmight be too costly (e.g., in terms of energy for mobile devices).\nThis specification tries to reduce the number of intermediate blocks\nthat need to be checked, by exploiting the guarantees provided by the\n"),i("a",{attrs:{href:"#tmbc-fm-2thirds1"}},[e._v("security model")]),e._v(".")]),e._v(" "),i("h1",{attrs:{id:"status"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#status"}},[e._v("#")]),e._v(" Status")]),e._v(" "),i("p",[e._v("This document is thoroughly reviewed, and the protocol has been\nformalized in TLA+ and model checked.")]),e._v(" "),i("h2",{attrs:{id:"issues-that-need-to-be-addressed"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#issues-that-need-to-be-addressed"}},[e._v("#")]),e._v(" Issues that need to be addressed")]),e._v(" "),i("p",[e._v("As it is part of the larger light node, its data structures and\nfunctions interact with the fork dectection functionality of the light\nclient. As a result of the work on\n"),i("a",{attrs:{href:"https://github.com/informalsystems/tendermint-rs/pull/479",target:"_blank",rel:"noopener noreferrer"}},[e._v("Pull Request 479"),i("OutboundLink")],1),e._v(" we\nestablished the need for an update in the data structures in "),i("a",{attrs:{href:"https://github.com/informalsystems/tendermint-rs/issues/499",target:"_blank",rel:"noopener noreferrer"}},[e._v("Issue 499"),i("OutboundLink")],1),e._v(". This\nwill not change the verification logic, but it will record information\nabout verification that can be used in fork detection (in particular\nin computing more efficiently the proof of fork).")]),e._v(" "),i("h1",{attrs:{id:"outline"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#outline"}},[e._v("#")]),e._v(" Outline")]),e._v(" "),i("ul",[i("li",[i("p",[i("a",{attrs:{href:"#part-i---tendermint-blockchain"}},[e._v("Part I")]),e._v(": Introduction of\nrelevant terms of the Tendermint\nblockchain.")])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"#part-ii---sequential-definition-of-the-verification-problem"}},[e._v("Part II")]),e._v(": Introduction\nof the problem addressed by the Lightclient Verification protocol.")]),e._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"#Verification-Informal-Problem-statement"}},[e._v("Verification Informal Problem\nstatement")]),e._v(": For the general\naudience, that is, engineers who want to get an overview over what\nthe component is doing from a bird's eye view.")]),e._v(" "),i("li",[i("a",{attrs:{href:"#Sequential-Problem-statement"}},[e._v("Sequential Problem statement")]),e._v(":\nProvides a mathematical definition of the problem statement in\nits sequential form, that is, ignoring the distributed aspect of\nthe implementation of the blockchain.")])])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"#part-iii---light-client-as-distributed-system"}},[e._v("Part III")]),e._v(": Distributed\naspects of the light client, system assumptions and temporal\nlogic specifications.")]),e._v(" "),i("ul",[i("li",[i("p",[i("a",{attrs:{href:"#incentives"}},[e._v("Incentives")]),e._v(": how faulty full nodes may benefit from\nmisbehaving and how correct full nodes benefit from cooperating.")])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"#Computational-Model"}},[e._v("Computational Model")]),e._v(":\ntiming and correctness assumptions.")])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"#Distributed-Problem-Statement"}},[e._v("Distributed Problem Statement")]),e._v(":\ntemporal properties that formalize safety and liveness\nproperties in the distributed setting.")])])])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"#part-iv---light-client-verification-protocol"}},[e._v("Part IV")]),e._v(":\nSpecification of the protocols.")]),e._v(" "),i("ul",[i("li",[i("p",[i("a",{attrs:{href:"#Definitions"}},[e._v("Definitions")]),e._v(": Describes inputs, outputs,\nvariables used by the protocol, auxiliary functions")])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"#core-verification"}},[e._v("Core Verification")]),e._v(": gives an outline of the solution,\nand details of the functions used (with preconditions,\npostconditions, error conditions).")])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"#liveness-scenarios"}},[e._v("Liveness Scenarios")]),e._v(": when the light\nclient makes progress depends heavily on the changes in the\nvalidator sets of the blockchain. We discuss some typical scenarios.")])])])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"#part-v---supporting-the-ibc-relayer"}},[e._v("Part V")]),e._v(": The above parts\nfocus on a common case where the last verified block has height "),i("em",[e._v("h1")]),e._v("\nand the\nrequested height "),i("em",[e._v("h2")]),e._v(" satisfies "),i("em",[e._v("h2 > h1")]),e._v('. For IBC, there are\nscenarios where this might not be the case. In this part, we provide\nsome preliminaries for supporting this. As not all details of the\nIBC requirements are clear by now, we do not provide a complete\nspecification at this point. We mark with "Open Question" points\nthat need to be addressed in order to finalize this specification.\nIt should be noted that the technically\nmost challenging case is the one specified in Part IV.')])])]),e._v(" "),i("p",[e._v("In this document we quite extensively use tags in order to be able to\nreference assumptions, invariants, etc. in future communication. In\nthese tags we frequently use the following short forms:")]),e._v(" "),i("ul",[i("li",[e._v("TMBC: Tendermint blockchain")]),e._v(" "),i("li",[e._v("SEQ: for sequential specifications")]),e._v(" "),i("li",[e._v("LCV: Lightclient Verification")]),e._v(" "),i("li",[e._v("LIVE: liveness")]),e._v(" "),i("li",[e._v("SAFE: safety")]),e._v(" "),i("li",[e._v("FUNC: function")]),e._v(" "),i("li",[e._v("INV: invariant")]),e._v(" "),i("li",[e._v("A: assumption")])]),e._v(" "),i("h1",{attrs:{id:"part-i-tendermint-blockchain"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#part-i-tendermint-blockchain"}},[e._v("#")]),e._v(" Part I - Tendermint Blockchain")]),e._v(" "),i("h2",{attrs:{id:"header-fields-necessary-for-the-light-client"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#header-fields-necessary-for-the-light-client"}},[e._v("#")]),e._v(" Header Fields necessary for the Light Client")]),e._v(" "),i("h4",{attrs:{id:"tmbc-header-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-header-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-HEADER.1]")])]),e._v(" "),i("p",[e._v("A set of blockchain transactions is stored in a data structure called\n"),i("em",[e._v("block")]),e._v(", which contains a field called "),i("em",[e._v("header")]),e._v(". (The data structure\n"),i("em",[e._v("block")]),e._v(" is defined "),i("a",{attrs:{href:"https://github.com/tendermint/spec/blob/d46cd7f573a2c6a2399fcab2cde981330aa63f37/spec/core/data_structures.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),i("OutboundLink")],1),e._v(").  As the header contains hashes to\nthe relevant fields of the block, for the purpose of this\nspecification, we will assume that the blockchain is a list of\nheaders, rather than a list of blocks.")]),e._v(" "),i("h4",{attrs:{id:"tmbc-hash-uniqueness-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-hash-uniqueness-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-HASH-UNIQUENESS.1]")])]),e._v(" "),i("p",[e._v("We assume that every hash in the header identifies the data it hashes.\nTherefore, in this specification, we do not distinguish between hashes and the\ndata they represent.")]),e._v(" "),i("h4",{attrs:{id:"tmbc-header-fields-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-header-fields-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-HEADER-FIELDS.1]")])]),e._v(" "),i("p",[e._v("A header contains the following fields:")]),e._v(" "),i("ul",[i("li",[i("code",[e._v("Height")]),e._v(": non-negative integer")]),e._v(" "),i("li",[i("code",[e._v("Time")]),e._v(": time (integer)")]),e._v(" "),i("li",[i("code",[e._v("LastBlockID")]),e._v(": Hashvalue")]),e._v(" "),i("li",[i("code",[e._v("LastCommit")]),e._v(" DomainCommit")]),e._v(" "),i("li",[i("code",[e._v("Validators")]),e._v(": DomainVal")]),e._v(" "),i("li",[i("code",[e._v("NextValidators")]),e._v(": DomainVal")]),e._v(" "),i("li",[i("code",[e._v("Data")]),e._v(": DomainTX")]),e._v(" "),i("li",[i("code",[e._v("AppState")]),e._v(": DomainApp")]),e._v(" "),i("li",[i("code",[e._v("LastResults")]),e._v(": DomainRes")])]),e._v(" "),i("h4",{attrs:{id:"tmbc-seq-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-seq-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-SEQ.1]")])]),e._v(" "),i("p",[e._v("The Tendermint blockchain is a list "),i("em",[e._v("chain")]),e._v(" of headers.")]),e._v(" "),i("h4",{attrs:{id:"tmbc-validator-pair-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-validator-pair-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-VALIDATOR-PAIR.1]")])]),e._v(" "),i("p",[e._v("Given a full node, a\n"),i("em",[e._v("validator pair")]),e._v(" is a pair "),i("em",[e._v("(peerID, voting_power)")]),e._v(", where")]),e._v(" "),i("ul",[i("li",[i("em",[e._v("peerID")]),e._v(" is the PeerID (public key) of a full node,")]),e._v(" "),i("li",[i("em",[e._v("voting_power")]),e._v(" is an integer (representing the full node's\nvoting power in a certain consensus instance).")])]),e._v(" "),i("blockquote",[i("p",[e._v("In the Golang implementation the data type for "),i("em",[e._v("validator\npair")]),e._v(" is called "),i("code",[e._v("Validator")])])]),e._v(" "),i("h4",{attrs:{id:"tmbc-validator-set-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-validator-set-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-VALIDATOR-SET.1]")])]),e._v(" "),i("p",[e._v("A "),i("em",[e._v("validator set")]),e._v(" is a set of validator pairs. For a validator set\n"),i("em",[e._v("vs")]),e._v(", we write "),i("em",[e._v("TotalVotingPower(vs)")]),e._v(" for the sum of the voting powers\nof its validator pairs.")]),e._v(" "),i("h4",{attrs:{id:"tmbc-vote-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-vote-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-VOTE.1]")])]),e._v(" "),i("p",[e._v("A "),i("em",[e._v("vote")]),e._v(" contains a "),i("code",[e._v("prevote")]),e._v(" or "),i("code",[e._v("precommit")]),e._v(" message sent and signed by\na validator node during the execution of "),i("a",{attrs:{href:"https://arxiv.org/abs/1807.04938",target:"_blank",rel:"noopener noreferrer"}},[e._v("consensus"),i("OutboundLink")],1),e._v(". Each\nmessage contains the following fields")]),e._v(" "),i("ul",[i("li",[i("code",[e._v("Type")]),e._v(": prevote or precommit")]),e._v(" "),i("li",[i("code",[e._v("Height")]),e._v(": positive integer")]),e._v(" "),i("li",[i("code",[e._v("Round")]),e._v(" a positive integer")]),e._v(" "),i("li",[i("code",[e._v("BlockID")]),e._v(" a Hashvalue of a block (not necessarily a block of the chain)")])]),e._v(" "),i("h4",{attrs:{id:"tmbc-commit-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-commit-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-COMMIT.1]")])]),e._v(" "),i("p",[e._v("A commit is a set of "),i("code",[e._v("precommit")]),e._v(" message.")]),e._v(" "),i("h2",{attrs:{id:"tendermint-failure-model"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tendermint-failure-model"}},[e._v("#")]),e._v(" Tendermint Failure Model")]),e._v(" "),i("h4",{attrs:{id:"tmbc-auth-byz-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-auth-byz-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-AUTH-BYZ.1]")])]),e._v(" "),i("p",[e._v("We assume the authenticated Byzantine fault model in which no node (faulty or\ncorrect) may break digital signatures, but otherwise, no additional\nassumption is made about the internal behavior of faulty\nnodes. That is, faulty nodes are only limited in that they cannot forge\nmessages.")]),e._v(" "),i("h4",{attrs:{id:"tmbc-time-params-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-time-params-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-TIME-PARAMS.1]")])]),e._v(" "),i("p",[e._v("A Tendermint blockchain has the following configuration parameters:")]),e._v(" "),i("ul",[i("li",[i("em",[e._v("unbondingPeriod")]),e._v(": a time duration.")]),e._v(" "),i("li",[i("em",[e._v("trustingPeriod")]),e._v(": a time duration smaller than "),i("em",[e._v("unbondingPeriod")]),e._v(".")])]),e._v(" "),i("h4",{attrs:{id:"tmbc-correct-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-correct-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-CORRECT.1]")])]),e._v(" "),i("p",[e._v("We define a predicate "),i("em",[e._v("correctUntil(n, t)")]),e._v(", where "),i("em",[e._v("n")]),e._v(" is a node and "),i("em",[e._v("t")]),e._v(" is a\ntime point.\nThe predicate "),i("em",[e._v("correctUntil(n, t)")]),e._v(" is true if and only if the node "),i("em",[e._v("n")]),e._v("\nfollows all the protocols (at least) until time "),i("em",[e._v("t")]),e._v(".")]),e._v(" "),i("h4",{attrs:{id:"tmbc-fm-2thirds-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-fm-2thirds-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-FM-2THIRDS.1]")])]),e._v(" "),i("p",[e._v("If a block "),i("em",[e._v("h")]),e._v(" is in the chain,\nthen there exists a subset "),i("em",[e._v("CorrV")]),e._v("\nof "),i("em",[e._v("h.NextValidators")]),e._v(", such that:")]),e._v(" "),i("ul",[i("li",[i("em",[e._v("TotalVotingPower(CorrV) > 2/3\nTotalVotingPower(h.NextValidators)")]),e._v("; cf. [TMBC-VALIDATOR-SET.1]")]),e._v(" "),i("li",[e._v("For every validator pair "),i("em",[e._v("(n,p)")]),e._v(" in "),i("em",[e._v("CorrV")]),e._v(", it holds "),i("em",[e._v("correctUntil(n,\nh.Time + trustingPeriod)")]),e._v("; cf. [TMBC-CORRECT.1]")])]),e._v(" "),i("blockquote",[i("p",[e._v("The definition of correct\n["),i("strong",[e._v("[TMBC-CORRECT.1]")]),e._v("][TMBC-CORRECT-link] refers to realtime, while it\nis used here with "),i("em",[e._v("Time")]),e._v(" and "),i("em",[e._v("trustingPeriod")]),e._v(', which are "hardware\ntimes".  We do not make a distinction here.')])]),e._v(" "),i("h4",{attrs:{id:"tmbc-corr-full-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-corr-full-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-CORR-FULL.1]")])]),e._v(" "),i("p",[e._v("Every correct full node locally stores a prefix of the\ncurrent list of headers from "),i("a",{attrs:{href:"#tmbc-seq1"}},[i("strong",[e._v("[TMBC-SEQ.1]")])]),e._v(".")]),e._v(" "),i("h2",{attrs:{id:"what-the-light-client-checks"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#what-the-light-client-checks"}},[e._v("#")]),e._v(" What the Light Client Checks")]),e._v(" "),i("blockquote",[i("p",[e._v("From [TMBC-FM-2THIRDS.1] we directly derive the following observation:")])]),e._v(" "),i("h4",{attrs:{id:"tmbc-val-contains-corr-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-val-contains-corr-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-VAL-CONTAINS-CORR.1]")])]),e._v(" "),i("p",[e._v("Given a (trusted) block "),i("em",[e._v("tb")]),e._v(" of the blockchain, a given set of full nodes\n"),i("em",[e._v("N")]),e._v(" contains a correct node at a real-time "),i("em",[e._v("t")]),e._v(", if")]),e._v(" "),i("ul",[i("li",[i("em",[e._v("t - trustingPeriod < tb.Time < t")])]),e._v(" "),i("li",[e._v("the voting power in tb.NextValidators of nodes in "),i("em",[e._v("N")]),e._v(" is more\nthan 1/3 of "),i("em",[e._v("TotalVotingPower(tb.NextValidators)")])])]),e._v(" "),i("blockquote",[i("p",[e._v("The following describes how a commit for a given block "),i("em",[e._v("b")]),e._v(" must look\nlike.")])]),e._v(" "),i("h4",{attrs:{id:"tmbc-sound-distr-poss-commit-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-sound-distr-poss-commit-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-SOUND-DISTR-POSS-COMMIT.1]")])]),e._v(" "),i("p",[e._v("For a block "),i("em",[e._v("b")]),e._v(", each element "),i("em",[e._v("pc")]),e._v(" of "),i("em",[e._v("PossibleCommit(b)")]),e._v(" satisfies:")]),e._v(" "),i("ul",[i("li",[i("em",[e._v("pc")]),e._v(" contains only votes (cf. [TMBC-VOTE.1])\nby validators from "),i("em",[e._v("b.Validators")])]),e._v(" "),i("li",[e._v("the sum of the voting powers in "),i("em",[e._v("pc")]),e._v(" is greater than 2/3\n"),i("em",[e._v("TotalVotingPower(b.Validators)")])]),e._v(" "),i("li",[e._v("and there is an "),i("em",[e._v("r")]),e._v(" such that  each vote "),i("em",[e._v("v")]),e._v(" in "),i("em",[e._v("pc")]),e._v(" satisfies\n"),i("ul",[i("li",[e._v("v.Type = precommit")]),e._v(" "),i("li",[e._v("v.Height = b.Height")]),e._v(" "),i("li",[e._v("v.Round = r")]),e._v(" "),i("li",[e._v("v.blockID = hash(b)")])])])]),e._v(" "),i("blockquote",[i("p",[e._v("The following property comes from the validity of the "),i("a",{attrs:{href:"https://arxiv.org/abs/1807.04938",target:"_blank",rel:"noopener noreferrer"}},[e._v("consensus"),i("OutboundLink")],1),e._v(": A\ncorrect validator node only sends "),i("code",[e._v("prevote")]),e._v(" or "),i("code",[e._v("precommit")]),e._v(", if\n"),i("code",[e._v("BlockID")]),e._v(" of the new (to-be-decided) block is equal to the hash of\nthe last block.")])]),e._v(" "),i("h4",{attrs:{id:"tmbc-val-commit-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-val-commit-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[TMBC-VAL-COMMIT.1]")])]),e._v(" "),i("p",[e._v("If for a block "),i("em",[e._v("b")]),e._v(",  a commit "),i("em",[e._v("c")])]),e._v(" "),i("ul",[i("li",[e._v("contains at least one validator pair "),i("em",[e._v("(v,p)")]),e._v(" such that "),i("em",[e._v("v")]),e._v(" is a\n"),i("strong",[e._v("correct")]),e._v(" validator node, and")]),e._v(" "),i("li",[e._v("is contained in "),i("em",[e._v("PossibleCommit(b)")])])]),e._v(" "),i("p",[e._v("then the block "),i("em",[e._v("b")]),e._v(" is on the blockchain.")]),e._v(" "),i("h2",{attrs:{id:"context-of-this-document"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#context-of-this-document"}},[e._v("#")]),e._v(" Context of this document")]),e._v(" "),i("p",[e._v("In this document we specify the light client verification component,\ncalled "),i("em",[e._v("Core Verification")]),e._v(".  The "),i("em",[e._v("Core Verification")]),e._v(" communicates with\na full node.  As full nodes may be faulty, it cannot trust the\nreceived information, but the light client has to check whether the\nheader it receives coincides with the one generated by Tendermint\nconsensus.")]),e._v(" "),i("p",[e._v("The two\nproperties "),i("a",{attrs:{href:"#tmbc-val-contains-corr1"}},[e._v("[TMBC-VAL-CONTAINS-CORR.1]")]),e._v(" and\n"),i("a",{attrs:{href:"#tmbc-val-commit1"}},[e._v("[TMBC-VAL-COMMIT]")]),e._v("  formalize the checks done\nby this specification:\nGiven a trusted block "),i("em",[e._v("tb")]),e._v(" and an untrusted block "),i("em",[e._v("ub")]),e._v(" with a commit "),i("em",[e._v("cub")]),e._v(",\none has to check that "),i("em",[e._v("cub")]),e._v(" is in "),i("em",[e._v("PossibleCommit(ub)")]),e._v(", and that "),i("em",[e._v("cub")]),e._v("\ncontains a correct node using "),i("em",[e._v("tb")]),e._v(".")]),e._v(" "),i("h1",{attrs:{id:"part-ii-sequential-definition-of-the-verification-problem"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#part-ii-sequential-definition-of-the-verification-problem"}},[e._v("#")]),e._v(" Part II - Sequential Definition of the Verification Problem")]),e._v(" "),i("h2",{attrs:{id:"verification-informal-problem-statement"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#verification-informal-problem-statement"}},[e._v("#")]),e._v(" Verification Informal Problem statement")]),e._v(" "),i("p",[e._v("Given a height "),i("em",[e._v("targetHeight")]),e._v(" as an input, the "),i("em",[e._v("Verifier")]),e._v(" eventually\nstores a header "),i("em",[e._v("h")]),e._v(" of height "),i("em",[e._v("targetHeight")]),e._v(" locally.  This header "),i("em",[e._v("h")]),e._v("\nis generated by the Tendermint "),i("a",{attrs:{href:"https://github.com/tendermint/spec/blob/d46cd7f573a2c6a2399fcab2cde981330aa63f37/spec/core/data_structures.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("blockchain"),i("OutboundLink")],1),e._v(". In\nparticular, a header that was not generated by the blockchain should\nnever be stored.")]),e._v(" "),i("h2",{attrs:{id:"sequential-problem-statement"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#sequential-problem-statement"}},[e._v("#")]),e._v(" Sequential Problem statement")]),e._v(" "),i("h4",{attrs:{id:"lcv-seq-live-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-seq-live-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-SEQ-LIVE.1]")])]),e._v(" "),i("p",[e._v("The "),i("em",[e._v("Verifier")]),e._v(" gets as input a height "),i("em",[e._v("targetHeight")]),e._v(", and eventually stores the\nheader of height "),i("em",[e._v("targetHeight")]),e._v(" of the blockchain.")]),e._v(" "),i("h4",{attrs:{id:"lcv-seq-safe-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-seq-safe-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-SEQ-SAFE.1]")])]),e._v(" "),i("p",[e._v("The "),i("em",[e._v("Verifier")]),e._v(" never stores a header which is not in the blockchain.")]),e._v(" "),i("h1",{attrs:{id:"part-iii-light-client-as-distributed-system"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#part-iii-light-client-as-distributed-system"}},[e._v("#")]),e._v(" Part III - Light Client as Distributed System")]),e._v(" "),i("h2",{attrs:{id:"incentives"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#incentives"}},[e._v("#")]),e._v(" Incentives")]),e._v(" "),i("p",[e._v("Faulty full nodes may benefit from lying to the light client, by making the\nlight client accept a block that deviates (e.g., contains additional\ntransactions) from the one generated by Tendermint consensus.\nUsers using the light client might be harmed by accepting a forged header.")]),e._v(" "),i("p",[e._v("The "),i("a",{attrs:{href:"https://github.com/informalsystems/tendermint-rs/blob/master/docs/spec/lightclient/detection.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("fork detector"),i("OutboundLink")],1),e._v(" of the light client may help the\ncorrect full nodes to understand whether their header is a good one.\nHence, in combination with the light client detector, the correct full\nnodes have the incentive to respond.  We can thus base liveness\narguments on the assumption that correct full nodes reliably talk to\nthe light client.")]),e._v(" "),i("h2",{attrs:{id:"computational-model"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#computational-model"}},[e._v("#")]),e._v(" Computational Model")]),e._v(" "),i("h4",{attrs:{id:"lcv-a-peer-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-a-peer-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-A-PEER.1]")])]),e._v(" "),i("p",[e._v("The verifier communicates with a full node called "),i("em",[e._v("primary")]),e._v(". No assumption is made about the full node (it may be correct or faulty).")]),e._v(" "),i("h4",{attrs:{id:"lcv-a-comm-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-a-comm-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-A-COMM.1]")])]),e._v(" "),i("p",[e._v("Communication between the light client and a correct full node is\nreliable and bounded in time. Reliable communication means that\nmessages are not lost, not duplicated, and eventually delivered. There\nis a (known) end-to-end delay "),i("em",[e._v("Delta")]),e._v(", such that if a message is sent\nat time "),i("em",[e._v("t")]),e._v(" then it is received and processes by time "),i("em",[e._v("t + Delta")]),e._v(".\nThis implies that we need a timeout of at least "),i("em",[e._v("2 Delta")]),e._v(" for remote\nprocedure calls to ensure that the response of a correct peer arrives\nbefore the timeout expires.")]),e._v(" "),i("h4",{attrs:{id:"lcv-a-tfm-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-a-tfm-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-A-TFM.1]")])]),e._v(" "),i("p",[e._v("The Tendermint blockchain satisfies the Tendermint failure model "),i("a",{attrs:{href:"#tmbc-fm-2thirds1"}},[i("strong",[e._v("[TMBC-FM-2THIRDS.1]")])]),e._v(".")]),e._v(" "),i("h4",{attrs:{id:"lcv-a-val-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-a-val-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-A-VAL.1]")])]),e._v(" "),i("p",[e._v("The system satisfies "),i("a",{attrs:{href:"#tmbc-auth-byz1"}},[i("strong",[e._v("[TMBC-AUTH-BYZ.1]")])]),e._v(" and\n"),i("a",{attrs:{href:"#tmbc-fm-2thirds1"}},[i("strong",[e._v("[TMBC-FM-2THIRDS.1]")])]),e._v(". Thus, there is a\nblockchain that satisfies the soundness requirements (that is, the\nvalidation rules in ["),i("a",{attrs:{href:"https://github.com/tendermint/spec/blob/d46cd7f573a2c6a2399fcab2cde981330aa63f37/spec/core/data_structures.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("block"),i("OutboundLink")],1),e._v("]).")]),e._v(" "),i("h2",{attrs:{id:"distributed-problem-statement"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#distributed-problem-statement"}},[e._v("#")]),e._v(" Distributed Problem Statement")]),e._v(" "),i("h3",{attrs:{id:"two-kinds-of-termination"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#two-kinds-of-termination"}},[e._v("#")]),e._v(" Two Kinds of Termination")]),e._v(" "),i("p",[e._v("We do not assume that "),i("em",[e._v("primary")]),e._v(" is correct. Under this assumption no\nprotocol can guarantee the combination of the sequential\nproperties. Thus, in the (unreliable) distributed setting, we consider\ntwo kinds of termination (successful and failure) and we will specify\nbelow under what (favorable) conditions "),i("em",[e._v("Core Verification")]),e._v(" ensures to\nterminate successfully, and satisfy the requirements of the sequential\nproblem statement:")]),e._v(" "),i("h4",{attrs:{id:"lcv-dist-term-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-dist-term-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-DIST-TERM.1]")])]),e._v(" "),i("p",[i("em",[e._v("Core Verification")]),e._v(" either "),i("em",[e._v("terminates\nsuccessfully")]),e._v(" or it "),i("em",[e._v("terminates with failure")]),e._v(".")]),e._v(" "),i("h3",{attrs:{id:"design-choices"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#design-choices"}},[e._v("#")]),e._v(" Design choices")]),e._v(" "),i("h4",{attrs:{id:"lcv-dist-store-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-dist-store-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-DIST-STORE.1]")])]),e._v(" "),i("p",[i("em",[e._v("Core Verification")]),e._v(" has a local data structure called "),i("em",[e._v("LightStore")]),e._v(" that\ncontains light blocks (that contain a header). For each light block we\nrecord whether it is verified.")]),e._v(" "),i("h4",{attrs:{id:"lcv-dist-primary-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-dist-primary-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-DIST-PRIMARY.1]")])]),e._v(" "),i("p",[i("em",[e._v("Core Verification")]),e._v(" has a local variable "),i("em",[e._v("primary")]),e._v(" that contains the PeerID of a full node.")]),e._v(" "),i("h4",{attrs:{id:"lcv-dist-init-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-dist-init-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-DIST-INIT.1]")])]),e._v(" "),i("p",[i("em",[e._v("LightStore")]),e._v(" is initialized with a header "),i("em",[e._v("trustedHeader")]),e._v(" that was correctly\ngenerated by the Tendermint consensus. We say "),i("em",[e._v("trustedHeader")]),e._v(" is verified.")]),e._v(" "),i("h3",{attrs:{id:"temporal-properties"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#temporal-properties"}},[e._v("#")]),e._v(" Temporal Properties")]),e._v(" "),i("h4",{attrs:{id:"lcv-dist-safe-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-dist-safe-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-DIST-SAFE.1]")])]),e._v(" "),i("p",[e._v("It is always the case that every verified header in "),i("em",[e._v("LightStore")]),e._v(" was\ngenerated by an instance of Tendermint consensus.")]),e._v(" "),i("h4",{attrs:{id:"lcv-dist-live-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-dist-live-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-DIST-LIVE.1]")])]),e._v(" "),i("p",[e._v("From time to time, a new instance of "),i("em",[e._v("Core Verification")]),e._v(" is called with a\nheight "),i("em",[e._v("targetHeight")]),e._v(" greater than the height of any header in "),i("em",[e._v("LightStore")]),e._v(".\nEach instance must eventually terminate.")]),e._v(" "),i("ul",[i("li",[e._v("If\n"),i("ul",[i("li",[e._v("the  "),i("em",[e._v("primary")]),e._v(" is correct (and locally has the block of\n"),i("em",[e._v("targetHeight")]),e._v("), and")]),e._v(" "),i("li",[i("em",[e._v("LightStore")]),e._v(" always contains a verified header whose age is less than the\ntrusting period,"),i("br"),e._v("\nthen "),i("em",[e._v("Core Verification")]),e._v(" adds a verified header "),i("em",[e._v("hd")]),e._v(" with height\n"),i("em",[e._v("targetHeight")]),e._v(" to "),i("em",[e._v("LightStore")]),e._v(" and it "),i("strong",[e._v("terminates successfully")])])])])]),e._v(" "),i("blockquote",[i("p",[e._v("These definitions imply that if the primary is faulty, a header may or\nmay not be added to "),i("em",[e._v("LightStore")]),e._v(". In any case,\n"),i("a",{attrs:{href:"#lcv-vc-inv"}},[i("strong",[e._v("[LCV-DIST-SAFE.1]")])]),e._v(" must hold.\nThe invariant "),i("a",{attrs:{href:"#lcv-dist-safe"}},[i("strong",[e._v("[LCV-DIST-SAFE.1]")])]),e._v(" and the liveness\nrequirement "),i("a",{attrs:{href:"#lcv-dist-life"}},[i("strong",[e._v("[LCV-DIST-LIVE.1]")])]),e._v("\nallow that verified headers are added to "),i("em",[e._v("LightStore")]),e._v(" whose\nheight was not passed\nto the verifier (e.g., intermediate headers used in bisection; see below).\nNote that for liveness, initially having a "),i("em",[e._v("trustedHeader")]),e._v(" within\nthe "),i("em",[e._v("trustinPeriod")]),e._v(" is not sufficient. However, as this\nspecification will leave some freedom with respect to the strategy\nin which order to download intermediate headers, we do not give a\nmore precise liveness specification here. After giving the\nspecification of the protocol, we will discuss some liveness\nscenarios "),i("a",{attrs:{href:"#liveness-scenarios"}},[e._v("below")]),e._v(".")])]),e._v(" "),i("h3",{attrs:{id:"solving-the-sequential-specification"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#solving-the-sequential-specification"}},[e._v("#")]),e._v(" Solving the sequential specification")]),e._v(" "),i("p",[e._v("This specification provides a partial solution to the sequential specification.\nThe "),i("em",[e._v("Verifier")]),e._v(" solves the invariant of the sequential part")]),e._v(" "),i("p",[i("a",{attrs:{href:"#lcv-vc-inv"}},[i("strong",[e._v("[LCV-DIST-SAFE.1]")])]),e._v(" => "),i("a",{attrs:{href:"#lcv-seq-inv"}},[i("strong",[e._v("[LCV-SEQ-SAFE.1]")])])]),e._v(" "),i("p",[e._v("In the case the primary is correct, and there is a recent header in "),i("em",[e._v("LightStore")]),e._v(", the verifier satisfies the liveness requirements.")]),e._v(" "),i("p",[e._v("⋀ "),i("em",[e._v("primary is correct")]),i("br"),e._v("\n⋀ always ∃ verified header in LightStore. "),i("em",[e._v("header.Time")]),e._v(" > "),i("em",[e._v("now")]),e._v(" - "),i("em",[e._v("trustingPeriod")]),i("br"),e._v("\n⋀ "),i("a",{attrs:{href:"#lcv-a-comm"}},[i("strong",[e._v("[LCV-A-Comm.1]")])]),e._v(" ⋀ (\n( "),i("a",{attrs:{href:"#tmbc-corr-full1"}},[i("strong",[e._v("[TMBC-CorrFull.1]")])]),e._v(" ⋀\n"),i("a",{attrs:{href:"#lcv-vc-live"}},[i("strong",[e._v("[LCV-DIST-LIVE.1]")])]),e._v(" )\n⟹ "),i("a",{attrs:{href:"#lcv-seq-live"}},[i("strong",[e._v("[LCV-SEQ-LIVE.1]")])]),e._v("\n)")]),e._v(" "),i("h1",{attrs:{id:"part-iv-light-client-verification-protocol"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#part-iv-light-client-verification-protocol"}},[e._v("#")]),e._v(" Part IV - Light Client Verification Protocol")]),e._v(" "),i("p",[e._v("We provide a specification for Light Client Verification. The local\ncode for verification is presented by a sequential function\n"),i("code",[e._v("VerifyToTarget")]),e._v(" to highlight the control flow of this functionality.\nWe note that if a different concurrency model is considered for\nan implementation, the sequential flow of the function may be\nimplemented with mutexes, etc. However, the light client verification\nis partitioned into three blocks that can be implemented and tested\nindependently:")]),e._v(" "),i("ul",[i("li",[i("code",[e._v("FetchLightBlock")]),e._v(" is called to download a light block (header) of a\ngiven height from a peer.")]),e._v(" "),i("li",[i("code",[e._v("ValidAndVerified")]),e._v(" is a local code that checks the header.")]),e._v(" "),i("li",[i("code",[e._v("Schedule")]),e._v(" decides which height to try to verify next. We keep this\nunderspecified as different implementations (currently in Goland and\nRust) may implement different optimizations here. We just provide\nnecessary conditions on how the height may evolve.")])]),e._v(" "),i("h2",{attrs:{id:"definitions"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#definitions"}},[e._v("#")]),e._v(" Definitions")]),e._v(" "),i("h3",{attrs:{id:"data-types"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#data-types"}},[e._v("#")]),e._v(" Data Types")]),e._v(" "),i("p",[e._v("The core data structure of the protocol is the LightBlock.")]),e._v(" "),i("h4",{attrs:{id:"lcv-data-lightblock-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-data-lightblock-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-DATA-LIGHTBLOCK.1]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBMaWdodEJsb2NrIHN0cnVjdCB7CiAgSGVhZGVyICAgICAgICAgIEhlYWRlcgogIENvbW1pdCAgICAgICAgICBDb21taXQKICBWYWxpZGF0b3JzICAgICAgVmFsaWRhdG9yU2V0Cn0K"}}),e._v(" "),i("h4",{attrs:{id:"lcv-data-lightstore-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-data-lightstore-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-DATA-LIGHTSTORE.1]")])]),e._v(" "),i("p",[e._v("LightBlocks are stored in a structure which stores all LightBlock from\ninitialization or received from peers.")]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBMaWdodFN0b3JlIHN0cnVjdCB7CiAuLi4KfQoK"}}),e._v(" "),i("p",[e._v("Each LightBlock is in one of the following states:")]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBWZXJpZmllZFN0YXRlIGludAoKY29uc3QgKAogU3RhdGVVbnZlcmlmaWVkID0gaW90YSArIDEKIFN0YXRlVmVyaWZpZWQKIFN0YXRlRmFpbGVkCiBTdGF0ZVRydXN0ZWQKKQo="}}),e._v(" "),i("blockquote",[i("p",[e._v("Only the detector module sets a lightBlock state to "),i("code",[e._v("StateTrusted")]),e._v("\nand only if it was "),i("code",[e._v("StateVerified")]),e._v(" before.")])]),e._v(" "),i("p",[e._v("The LightStore exposes the following functions to query stored LightBlocks.")]),e._v(" "),i("h4",{attrs:{id:"lcv-func-get-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-func-get-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-FUNC-GET.1]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyAobHMgTGlnaHRTdG9yZSkgR2V0KGhlaWdodCBIZWlnaHQpIChMaWdodEJsb2NrLCBib29sKQo="}}),e._v(" "),i("ul",[i("li",[e._v("Expected postcondition\n"),i("ul",[i("li",[e._v("returns a LightBlock at a given height or false in the second argument if\nthe LightStore does not contain the specified LightBlock.")])])])]),e._v(" "),i("h4",{attrs:{id:"lcv-func-latest-verif-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-func-latest-verif-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-FUNC-LATEST-VERIF.1]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyAobHMgTGlnaHRTdG9yZSkgTGF0ZXN0VmVyaWZpZWQoKSBMaWdodEJsb2NrCg=="}}),e._v(" "),i("ul",[i("li",[e._v("Expected postcondition\n"),i("ul",[i("li",[e._v("returns the highest light block whose state is "),i("code",[e._v("StateVerified")]),e._v("\nor "),i("code",[e._v("StateTrusted")])])])])]),e._v(" "),i("h4",{attrs:{id:"lcv-func-update-2"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-func-update-2"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-FUNC-UPDATE.2]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyAobHMgTGlnaHRTdG9yZSkgVXBkYXRlKGxpZ2h0QmxvY2sgTGlnaHRCbG9jaywgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJmaWVkU3RhdGUgVmVyaWZpZWRTdGF0ZQogICAgICAgdmVyaWZpZWRCeSBIZWlnaHQpCg=="}}),e._v(" "),i("ul",[i("li",[e._v("Expected postcondition\n"),i("ul",[i("li",[e._v("The state of the LightBlock is set to "),i("em",[e._v("verifiedState")]),e._v(".")]),e._v(" "),i("li",[e._v("verifiedBy of the Lightblock is set to "),i("em",[e._v("Height")])])])])]),e._v(" "),i("blockquote",[i("p",[e._v("The following function is used only in the detector specification\nlisted here for completeness.")])]),e._v(" "),i("h4",{attrs:{id:"lcv-func-latest-trusted-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-func-latest-trusted-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-FUNC-LATEST-TRUSTED.1]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyAobHMgTGlnaHRTdG9yZSkgTGF0ZXN0VHJ1c3RlZCgpIExpZ2h0QmxvY2sK"}}),e._v(" "),i("ul",[i("li",[e._v("Expected postcondition\n"),i("ul",[i("li",[e._v("returns the highest light block that has been verified and\nchecked by the detector.")])])])]),e._v(" "),i("h4",{attrs:{id:"lcv-func-filter-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-func-filter-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-FUNC-FILTER.1]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyAobHMgTGlnaHRTdG9yZSkgRmlsdGVyVmVyaWZpZWQoKSBMaWdodFNUb3JlCg=="}}),e._v(" "),i("ul",[i("li",[e._v("Expected postcondition\n"),i("ul",[i("li",[e._v("returns only the LightBlocks with state verified.")])])])]),e._v(" "),i("h3",{attrs:{id:"inputs"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#inputs"}},[e._v("#")]),e._v(" Inputs")]),e._v(" "),i("ul",[i("li",[i("em",[e._v("lightStore")]),e._v(": stores light blocks that have been downloaded and that\npassed verification. Initially it contains a light block with\n"),i("em",[e._v("trustedHeader")]),e._v(".")]),e._v(" "),i("li",[i("em",[e._v("primary")]),e._v(": peerID")]),e._v(" "),i("li",[i("em",[e._v("targetHeight")]),e._v(": the height of the needed header")])]),e._v(" "),i("h3",{attrs:{id:"configuration-parameters"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#configuration-parameters"}},[e._v("#")]),e._v(" Configuration Parameters")]),e._v(" "),i("ul",[i("li",[i("em",[e._v("trustThreshold")]),e._v(": a float. Can be used if correctness should not be based on more voting power and 1/3.")]),e._v(" "),i("li",[i("em",[e._v("trustingPeriod")]),e._v(": a time duration "),i("a",{attrs:{href:"#tmbc-time-params1"}},[i("strong",[e._v("[TMBC-TIME_PARAMS.1]")])]),e._v(".")]),e._v(" "),i("li",[i("em",[e._v("clockDrift")]),e._v(": a time duration. Correction parameter dealing with only approximately synchronized clocks.")])]),e._v(" "),i("h3",{attrs:{id:"variables"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#variables"}},[e._v("#")]),e._v(" Variables")]),e._v(" "),i("ul",[i("li",[i("em",[e._v("nextHeight")]),e._v(": initially "),i("em",[e._v("targetHeight")]),e._v(" "),i("blockquote",[i("p",[i("em",[e._v("nextHeight")]),e._v(' should be thought of the "height of the next header we need\nto download and verify"')])])])]),e._v(" "),i("h3",{attrs:{id:"assumptions"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#assumptions"}},[e._v("#")]),e._v(" Assumptions")]),e._v(" "),i("h4",{attrs:{id:"lcv-a-init-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-a-init-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-A-INIT.1]")])]),e._v(" "),i("ul",[i("li",[i("p",[i("em",[e._v("trustedHeader")]),e._v(" is from the blockchain")])]),e._v(" "),i("li",[i("p",[i("em",[e._v("targetHeight > LightStore.LatestVerified.Header.Height")])])])]),e._v(" "),i("h3",{attrs:{id:"invariants"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#invariants"}},[e._v("#")]),e._v(" Invariants")]),e._v(" "),i("h4",{attrs:{id:"lcv-inv-tp-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-inv-tp-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-INV-TP.1]")])]),e._v(" "),i("p",[e._v("It is always the case that "),i("em",[e._v("LightStore.LatestTrusted.Header.Time > now - trustingPeriod")]),e._v(".")]),e._v(" "),i("blockquote",[i("p",[e._v("If the invariant is violated, the light client does not have a\nheader it can trust. A trusted header must be obtained externally,\nits trust can only be based on social consensus.")])]),e._v(" "),i("h3",{attrs:{id:"used-remote-functions"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#used-remote-functions"}},[e._v("#")]),e._v(" Used Remote Functions")]),e._v(" "),i("p",[e._v("We use the functions "),i("code",[e._v("commit")]),e._v(" and "),i("code",[e._v("validators")]),e._v(" that are provided\nby the "),i("a",{attrs:{href:"https://docs.tendermint.com/master/rpc/",target:"_blank",rel:"noopener noreferrer"}},[e._v("RPC client for Tendermint"),i("OutboundLink")],1),e._v(".")]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBDb21taXQoaGVpZ2h0IGludDY0KSAoU2lnbmVkSGVhZGVyLCBlcnJvcikK"}}),e._v(" "),i("ul",[i("li",[e._v("Implementation remark\n"),i("ul",[i("li",[e._v("RPC to full node "),i("em",[e._v("n")])]),e._v(" "),i("li",[e._v("JSON sent:")])])])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"javascript",base64:"Ly8gUE9TVCAvY29tbWl0CnsKICZxdW90O2pzb25ycGMmcXVvdDs6ICZxdW90OzIuMCZxdW90OywKICZxdW90O2lkJnF1b3Q7OiAmcXVvdDtjY2M4NDYzMS1kZmRiLTRhZGMtYjg4Yy01MjkxZWEzYzJjZmImcXVvdDssIC8vIFVVSUQgdjQsIHVuaXF1ZSBwZXIgcmVxdWVzdAogJnF1b3Q7bWV0aG9kJnF1b3Q7OiAmcXVvdDtjb21taXQmcXVvdDssCiAmcXVvdDtwYXJhbXMmcXVvdDs6IHsKICAmcXVvdDtoZWlnaHQmcXVvdDs6IDEyMzQKIH0KfQo="}}),e._v(" "),i("ul",[i("li",[e._v("Expected precondition\n"),i("ul",[i("li",[e._v("header of "),i("code",[e._v("height")]),e._v(" exists on blockchain")])])]),e._v(" "),i("li",[e._v("Expected postcondition\n"),i("ul",[i("li",[e._v("if "),i("em",[e._v("n")]),e._v(" is correct: Returns the signed header of height "),i("code",[e._v("height")]),e._v("\nfrom the blockchain if communication is timely (no timeout)")]),e._v(" "),i("li",[e._v("if "),i("em",[e._v("n")]),e._v(" is faulty: Returns a signed header with arbitrary content")])])]),e._v(" "),i("li",[e._v("Error condition\n"),i("ul",[i("li",[e._v("if "),i("em",[e._v("n")]),e._v(" is correct: precondition violated or timeout")]),e._v(" "),i("li",[e._v("if "),i("em",[e._v("n")]),e._v(" is faulty: arbitrary error")])])])]),e._v(" "),i("hr"),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBWYWxpZGF0b3JzKGhlaWdodCBpbnQ2NCkgKFZhbGlkYXRvclNldCwgZXJyb3IpCg=="}}),e._v(" "),i("ul",[i("li",[e._v("Implementation remark\n"),i("ul",[i("li",[e._v("RPC to full node "),i("em",[e._v("n")])]),e._v(" "),i("li",[e._v("JSON sent:")])])])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"javascript",base64:"Ly8gUE9TVCAvdmFsaWRhdG9ycwp7CiAmcXVvdDtqc29ucnBjJnF1b3Q7OiAmcXVvdDsyLjAmcXVvdDssCiAmcXVvdDtpZCZxdW90OzogJnF1b3Q7Y2NjODQ2MzEtZGZkYi00YWRjLWI4OGMtNTI5MWVhM2MyY2ZiJnF1b3Q7LCAvLyBVVUlEIHY0LCB1bmlxdWUgcGVyIHJlcXVlc3QKICZxdW90O21ldGhvZCZxdW90OzogJnF1b3Q7dmFsaWRhdG9ycyZxdW90OywKICZxdW90O3BhcmFtcyZxdW90OzogewogICZxdW90O2hlaWdodCZxdW90OzogMTIzNAogfQp9Cg=="}}),e._v(" "),i("ul",[i("li",[e._v("Expected precondition\n"),i("ul",[i("li",[e._v("header of "),i("code",[e._v("height")]),e._v(" exists on blockchain")])])]),e._v(" "),i("li",[e._v("Expected postcondition\n"),i("ul",[i("li",[e._v("if "),i("em",[e._v("n")]),e._v(" is correct: Returns the validator set of height "),i("code",[e._v("height")]),e._v("\nfrom the blockchain if communication is timely (no timeout)")]),e._v(" "),i("li",[e._v("if "),i("em",[e._v("n")]),e._v(" is faulty: Returns arbitrary validator set")])])]),e._v(" "),i("li",[e._v("Error condition\n"),i("ul",[i("li",[e._v("if "),i("em",[e._v("n")]),e._v(" is correct: precondition violated or timeout")]),e._v(" "),i("li",[e._v("if "),i("em",[e._v("n")]),e._v(" is faulty: arbitrary error")])])])]),e._v(" "),i("hr"),e._v(" "),i("h3",{attrs:{id:"communicating-function"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#communicating-function"}},[e._v("#")]),e._v(" Communicating Function")]),e._v(" "),i("h4",{attrs:{id:"lcv-func-fetch-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-func-fetch-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-FUNC-FETCH.1]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBGZXRjaExpZ2h0QmxvY2socGVlciBQZWVySUQsIGhlaWdodCBIZWlnaHQpIExpZ2h0QmxvY2sK"}}),e._v(" "),i("ul",[i("li",[e._v("Implementation remark\n"),i("ul",[i("li",[e._v("RPC to peer at "),i("em",[e._v("PeerID")])]),e._v(" "),i("li",[e._v("calls "),i("code",[e._v("Commit")]),e._v(" for "),i("em",[e._v("height")]),e._v(" and "),i("code",[e._v("Validators")]),e._v(" for "),i("em",[e._v("height")]),e._v(" and "),i("em",[e._v("height+1")])])])]),e._v(" "),i("li",[e._v("Expected precondition\n"),i("ul",[i("li",[i("code",[e._v("height")]),e._v(" is less than or equal to height of the peer "),i("strong",[e._v("[LCV-IO-PRE-HEIGHT.1]")])])])]),e._v(" "),i("li",[e._v("Expected postcondition:\n"),i("ul",[i("li",[e._v("if "),i("em",[e._v("node")]),e._v(" is correct:\n"),i("ul",[i("li",[e._v("Returns the LightBlock "),i("em",[e._v("lb")]),e._v(" of height "),i("code",[e._v("height")]),e._v("\nthat is consistent with the blockchain")]),e._v(" "),i("li",[i("em",[e._v("lb.provider = peer")]),e._v(" "),i("strong",[e._v("[LCV-IO-POST-PROVIDER.1]")])]),e._v(" "),i("li",[i("em",[e._v("lb.Header")]),e._v(" is a header consistent with the blockchain")]),e._v(" "),i("li",[i("em",[e._v("lb.Validators")]),e._v(" is the validator set of the blockchain at height "),i("em",[e._v("nextHeight")])]),e._v(" "),i("li",[i("em",[e._v("lb.NextValidators")]),e._v(" is the validator set of the blockchain at height "),i("em",[e._v("nextHeight + 1")])])])]),e._v(" "),i("li",[e._v("if "),i("em",[e._v("node")]),e._v(" is faulty: Returns a LightBlock with arbitrary content\n"),i("a",{attrs:{href:"#tmbc-auth-byz1"}},[i("strong",[e._v("[TMBC-AUTH-BYZ.1]")])])])])]),e._v(" "),i("li",[e._v("Error condition\n"),i("ul",[i("li",[e._v("if "),i("em",[e._v("n")]),e._v(" is correct: precondition violated")]),e._v(" "),i("li",[e._v("if "),i("em",[e._v("n")]),e._v(" is faulty: arbitrary error")]),e._v(" "),i("li",[e._v("if "),i("em",[e._v("lb.provider != peer")])]),e._v(" "),i("li",[e._v("times out after 2 Delta (by assumption "),i("em",[e._v("n")]),e._v(" is faulty)")])])])]),e._v(" "),i("hr"),e._v(" "),i("h2",{attrs:{id:"core-verification"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#core-verification"}},[e._v("#")]),e._v(" Core Verification")]),e._v(" "),i("h3",{attrs:{id:"outline-2"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#outline-2"}},[e._v("#")]),e._v(" Outline")]),e._v(" "),i("p",[e._v("The "),i("code",[e._v("VerifyToTarget")]),e._v(" is the main function and uses the following functions.")]),e._v(" "),i("ul",[i("li",[i("code",[e._v("FetchLightBlock")]),e._v(" is called to download the next light block. It is\nthe only function that communicates with other nodes")]),e._v(" "),i("li",[i("code",[e._v("ValidAndVerified")]),e._v(" checks whether header is valid and checks if a\nnew lightBlock should be trusted\nbased on a previously verified lightBlock.")]),e._v(" "),i("li",[i("code",[e._v("Schedule")]),e._v(" decides which height to try to verify next")])]),e._v(" "),i("p",[e._v("In the following description of "),i("code",[e._v("VerifyToTarget")]),e._v(" we do not deal with error\nhandling. If any of the above function returns an error, VerifyToTarget just\npasses the error on.")]),e._v(" "),i("h4",{attrs:{id:"lcv-func-main-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-func-main-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-FUNC-MAIN.1]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBWZXJpZnlUb1RhcmdldChwcmltYXJ5IFBlZXJJRCwgbGlnaHRTdG9yZSBMaWdodFN0b3JlLAogICAgICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodCBIZWlnaHQpIChMaWdodFN0b3JlLCBSZXN1bHQpIHsKCiAgICBuZXh0SGVpZ2h0IDo9IHRhcmdldEhlaWdodAoKICAgIGZvciBsaWdodFN0b3JlLkxhdGVzdFZlcmlmaWVkLmhlaWdodCAmbHQ7IHRhcmdldEhlaWdodCB7CgogICAgICAgIC8vIEdldCBuZXh0IExpZ2h0QmxvY2sgZm9yIHZlcmlmaWNhdGlvbgogICAgICAgIGN1cnJlbnQsIGZvdW5kIDo9IGxpZ2h0U3RvcmUuR2V0KG5leHRIZWlnaHQpCiAgICAgICAgaWYgIWZvdW5kIHsKICAgICAgICAgICAgY3VycmVudCA9IEZldGNoTGlnaHRCbG9jayhwcmltYXJ5LCBuZXh0SGVpZ2h0KQogICAgICAgICAgICBsaWdodFN0b3JlLlVwZGF0ZShjdXJyZW50LCBTdGF0ZVVudmVyaWZpZWQpCiAgICAgICAgfQoKICAgICAgICAvLyBWZXJpZnkKICAgICAgICB2ZXJkaWN0ID0gVmFsaWRBbmRWZXJpZmllZChsaWdodFN0b3JlLkxhdGVzdFZlcmlmaWVkLCBjdXJyZW50KQoKICAgICAgICAvLyBEZWNpZGUgd2hldGhlci9ob3cgdG8gY29udGludWUKICAgICAgICBpZiB2ZXJkaWN0ID09IFNVQ0NFU1MgewogICAgICAgICAgICBsaWdodFN0b3JlLlVwZGF0ZShjdXJyZW50LCBTdGF0ZVZlcmlmaWVkKQogICAgICAgIH0KICAgICAgICBlbHNlIGlmIHZlcmRpY3QgPT0gTk9UX0VOT1VHSF9UUlVTVCB7CiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcKICAgLy8gdGhlIGxpZ2h0IGJsb2NrIGN1cnJlbnQgcGFzc2VkIHZhbGlkYXRpb24sIGJ1dCB0aGUgdmFsaWRhdG9yCiAgICAgICAgICAgIC8vIHNldCBpcyB0b28gZGlmZmVyZW50IHRvIHZlcmlmeSBpdC4gV2Uga2VlcCB0aGUgc3RhdGUgb2YKICAgLy8gY3VycmVudCBhdCBTdGF0ZVVudmVyaWZpZWQuIEZvciBhIGxhdGVyIGl0ZXJhdGlvbiwgU2NoZWR1bGUKICAgLy8gbWlnaHQgZGVjaWRlIHRvIHRyeSB2ZXJpZmljYXRpb24gb2YgdGhhdCBsaWdodCBibG9jayBhZ2Fpbi4KICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIC8vIHZlcmRpY3QgaXMgc29tZSBlcnJvciBjb2RlCiAgICAgICAgICAgIGxpZ2h0U3RvcmUuVXBkYXRlKGN1cnJlbnQsIFN0YXRlRmFpbGVkKQogICAgICAgICAgICAvLyBwb3NzaWJseSByZW1vdmUgYWxsIExpZ2h0QmxvY2tzIGZyb20gcHJpbWFyeQogICAgICAgICAgICByZXR1cm4gKGxpZ2h0U3RvcmUsIFJlc3VsdEZhaWx1cmUpCiAgICAgICAgfQogICAgICAgIG5leHRIZWlnaHQgPSBTY2hlZHVsZShsaWdodFN0b3JlLCBuZXh0SGVpZ2h0LCB0YXJnZXRIZWlnaHQpCiAgICB9CiAgICByZXR1cm4gKGxpZ2h0U3RvcmUsIFJlc3VsdFN1Y2Nlc3MpCn0K"}}),e._v(" "),i("ul",[i("li",[e._v("Expected precondition\n"),i("ul",[i("li",[i("em",[e._v("lightStore")]),e._v(" contains a LightBlock within the "),i("em",[e._v("trustingPeriod")]),e._v(" "),i("strong",[e._v("[LCV-PRE-TP.1]")])]),e._v(" "),i("li",[i("em",[e._v("targetHeight")]),e._v(" is greater than the height of all the LightBlocks in "),i("em",[e._v("lightStore")])])])]),e._v(" "),i("li",[e._v("Expected postcondition:\n"),i("ul",[i("li",[e._v("returns "),i("em",[e._v("lightStore")]),e._v(" that contains a LightBlock that corresponds to a block\nof the blockchain of height "),i("em",[e._v("targetHeight")]),e._v("\n(that is, the LightBlock has been added to "),i("em",[e._v("lightStore")]),e._v(") "),i("strong",[e._v("[LCV-POST-LS.1]")])])])]),e._v(" "),i("li",[e._v("Error conditions\n"),i("ul",[i("li",[e._v("if the precondition is violated")]),e._v(" "),i("li",[e._v("if "),i("code",[e._v("ValidAndVerified")]),e._v(" or "),i("code",[e._v("FetchLightBlock")]),e._v(" report an error")]),e._v(" "),i("li",[e._v("if "),i("a",{attrs:{href:"#LCV-INV-TP.1"}},[i("strong",[e._v("[LCV-INV-TP.1]")])]),e._v(" is violated")])])])]),e._v(" "),i("h3",{attrs:{id:"details-of-the-functions"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#details-of-the-functions"}},[e._v("#")]),e._v(" Details of the Functions")]),e._v(" "),i("h4",{attrs:{id:"lcv-func-valid-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-func-valid-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-FUNC-VALID.1]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBWYWxpZEFuZFZlcmlmaWVkKHRydXN0ZWQgTGlnaHRCbG9jaywgdW50cnVzdGVkIExpZ2h0QmxvY2spIFJlc3VsdAo="}}),e._v(" "),i("ul",[i("li",[e._v("Expected precondition:\n"),i("ul",[i("li",[i("em",[e._v("untrusted")]),e._v(" is valid, that is, satisfies the soundness "),i("a",{attrs:{href:"https://github.com/tendermint/spec/blob/d46cd7f573a2c6a2399fcab2cde981330aa63f37/spec/core/data_structures.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("checks"),i("OutboundLink")],1)]),e._v(" "),i("li",[i("em",[e._v("untrusted")]),e._v(" is "),i("strong",[e._v("well-formed")]),e._v(", that is,\n"),i("ul",[i("li",[i("em",[e._v("untrusted.Header.Time < now + clockDrift")])]),e._v(" "),i("li",[i("em",[e._v("untrusted.Validators = hash(untrusted.Header.Validators)")])]),e._v(" "),i("li",[i("em",[e._v("untrusted.NextValidators = hash(untrusted.Header.NextValidators)")])])])]),e._v(" "),i("li",[i("em",[e._v("trusted.Header.Time > now - trustingPeriod")])]),e._v(" "),i("li",[i("em",[e._v("trusted.Commit")]),e._v(" is a commit for the header\n"),i("em",[e._v("trusted.Header")]),e._v(", i.e., it contains\nthe correct hash of the header, and +2/3 of signatures")]),e._v(" "),i("li",[e._v("the "),i("code",[e._v("Height")]),e._v(" and "),i("code",[e._v("Time")]),e._v(" of "),i("code",[e._v("trusted")]),e._v(" are smaller than the Height and\n"),i("code",[e._v("Time")]),e._v(" of "),i("code",[e._v("untrusted")]),e._v(", respectively")]),e._v(" "),i("li",[e._v("the "),i("em",[e._v("untrusted.Header")]),e._v(" is well-formed (passes the tests from\n["),i("a",{attrs:{href:"https://github.com/tendermint/spec/blob/d46cd7f573a2c6a2399fcab2cde981330aa63f37/spec/core/data_structures.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("block"),i("OutboundLink")],1),e._v("]), and in particular\n"),i("ul",[i("li",[e._v("if the untrusted header "),i("code",[e._v("unstrusted.Header")]),e._v(" is the immediate\nsuccessor  of  "),i("code",[e._v("trusted.Header")]),e._v(", then it holds that\n"),i("ul",[i("li",[i("em",[e._v("trusted.Header.NextValidators =\nuntrusted.Header.Validators")]),e._v(", and\nmoreover,")]),e._v(" "),i("li",[i("em",[e._v("untrusted.Header.Commit")]),e._v(" "),i("ul",[i("li",[e._v("contains signatures by more than two-thirds of the validators")]),e._v(" "),i("li",[e._v("contains no signature from nodes that are not in "),i("em",[e._v("trusted.Header.NextValidators")])])])])])])])])])]),e._v(" "),i("li",[e._v("Expected postcondition:\n"),i("ul",[i("li",[e._v("Returns "),i("code",[e._v("SUCCESS")]),e._v(":\n"),i("ul",[i("li",[e._v("if "),i("em",[e._v("untrusted")]),e._v(" is the immediate successor of "),i("em",[e._v("trusted")]),e._v(", or otherwise,")]),e._v(" "),i("li",[e._v("if the signatures of a set of validators that have more than\n"),i("em",[e._v("max(1/3,trustThreshold)")]),e._v(" of voting power in\n"),i("em",[e._v("trusted.Nextvalidators")]),e._v(" is contained in\n"),i("em",[e._v("untrusted.Commit")]),e._v(" (that is, header passes the tests\n"),i("a",{attrs:{href:"#tmbc-val-contains-corr1"}},[i("strong",[e._v("[TMBC-VAL-CONTAINS-CORR.1]")])]),e._v("\nand "),i("a",{attrs:{href:"#tmbc-val-commit1"}},[i("strong",[e._v("[TMBC-VAL-COMMIT.1]")])]),e._v(")")])])]),e._v(" "),i("li",[e._v("Returns "),i("code",[e._v("NOT_ENOUGH_TRUST")]),e._v(" if:\n"),i("ul",[i("li",[i("em",[e._v("untrusted")]),e._v(" is "),i("em",[e._v("not")]),e._v(" the immediate successor of\n"),i("em",[e._v("trusted")]),e._v("\nand the  "),i("em",[e._v("max(1/3,trustThreshold)")]),e._v(" threshold is not reached\n(that is, if\n"),i("a",{attrs:{href:"#tmbc-val-contains-corr1"}},[i("strong",[e._v("[TMBC-VAL-CONTAINS-CORR.1]")])]),e._v("\nfails and header is does not violate the soundness\nchecks ["),i("a",{attrs:{href:"https://github.com/tendermint/spec/blob/d46cd7f573a2c6a2399fcab2cde981330aa63f37/spec/core/data_structures.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("block"),i("OutboundLink")],1),e._v("]).")])])])])]),e._v(" "),i("li",[e._v("Error condition:\n"),i("ul",[i("li",[e._v("if precondition violated")])])])]),e._v(" "),i("hr"),e._v(" "),i("h4",{attrs:{id:"lcv-func-schedule-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-func-schedule-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-FUNC-SCHEDULE.1]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBTY2hlZHVsZShsaWdodFN0b3JlLCBuZXh0SGVpZ2h0LCB0YXJnZXRIZWlnaHQpIEhlaWdodAo="}}),e._v(" "),i("ul",[i("li",[e._v("Implementation remark: If picks the next height to be verified.\nWe keep the precise choice of the next header under-specified. It is\nsubject to performance optimizations that do not influence the correctness")]),e._v(" "),i("li",[e._v("Expected postcondition: "),i("strong",[e._v("[LCV-SCHEDULE-POST.1]")]),e._v("\nReturn "),i("em",[e._v("H")]),e._v(" s.t.\n"),i("ol",[i("li",[e._v("if "),i("em",[e._v("lightStore.LatestVerified.Height = nextHeight")]),e._v(" and\n"),i("em",[e._v("lightStore.LatestVerified < targetHeight")]),e._v(" then"),i("br"),e._v(" "),i("em",[e._v("nextHeight < H <= targetHeight")])]),e._v(" "),i("li",[e._v("if "),i("em",[e._v("lightStore.LatestVerified.Height < nextHeight")]),e._v(" and\n"),i("em",[e._v("lightStore.LatestVerified.Height < targetHeight")]),e._v(" then"),i("br"),e._v(" "),i("em",[e._v("lightStore.LatestVerified.Height < H < nextHeight")])]),e._v(" "),i("li",[e._v("if "),i("em",[e._v("lightStore.LatestVerified.Height = targetHeight")]),e._v(" then"),i("br"),e._v(" "),i("em",[e._v("H =  targetHeight")])])])])]),e._v(" "),i("blockquote",[i("p",[e._v("Case i. captures the case where the light block at height "),i("em",[e._v("nextHeight")]),e._v("\nhas been verified, and we can choose a height closer to the "),i("em",[e._v("targetHeight")]),e._v(".\nAs we get the "),i("em",[e._v("lightStore")]),e._v(" as parameter, the choice of the next height can\ndepend on the "),i("em",[e._v("lightStore")]),e._v(", e.g., we can pick a height for which we have\nalready downloaded a light block.\nIn Case ii. the header of "),i("em",[e._v("nextHeight")]),e._v(" could not be verified, and we need to pick a smaller height.\nIn Case iii. is a special case when we have verified the "),i("em",[e._v("targetHeight")]),e._v(".")])]),e._v(" "),i("h3",{attrs:{id:"solving-the-distributed-specification"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#solving-the-distributed-specification"}},[e._v("#")]),e._v(" Solving the distributed specification")]),e._v(" "),i("p",[i("em",[e._v("trustedStore")]),e._v(" is implemented by the light blocks in lightStore that\nhave the state "),i("em",[e._v("StateVerified")]),e._v(".")]),e._v(" "),i("h4",{attrs:{id:"argument-for-lcv-dist-safe-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcv-dist-safe-1"}},[e._v("#")]),e._v(" Argument for "),i("a",{attrs:{href:"#lcv-dist-safe"}},[i("strong",[e._v("[LCV-DIST-SAFE.1]")])])]),e._v(" "),i("ul",[i("li",[i("code",[e._v("ValidAndVerified")]),e._v(" implements the soundness checks and the checks\n"),i("a",{attrs:{href:"#tmbc-val-contains-corr1"}},[i("strong",[e._v("[TMBC-VAL-CONTAINS-CORR.1]")])]),e._v(" and\n"),i("a",{attrs:{href:"#tmbc-val-commit1"}},[i("strong",[e._v("[TMBC-VAL-COMMIT.1]")])]),e._v(" under\nthe assumption "),i("a",{attrs:{href:"#tmbc-fm-2thirds1"}},[i("strong",[e._v("[TMBC-FM-2THIRDS.1]")])])]),e._v(" "),i("li",[e._v("Only if "),i("code",[e._v("ValidAndVerified")]),e._v(" returns with "),i("code",[e._v("SUCCESS")]),e._v(", the state of a light block is\nset to "),i("em",[e._v("StateVerified")]),e._v(".")])]),e._v(" "),i("h4",{attrs:{id:"argument-for-lcv-dist-live-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcv-dist-live-1"}},[e._v("#")]),e._v(" Argument for "),i("a",{attrs:{href:"#lcv-dist-life"}},[i("strong",[e._v("[LCV-DIST-LIVE.1]")])])]),e._v(" "),i("ul",[i("li",[e._v("If "),i("em",[e._v("primary")]),e._v(" is correct,\n"),i("ul",[i("li",[i("code",[e._v("FetchLightBlock")]),e._v(" will always return a light block consistent\nwith the blockchain")]),e._v(" "),i("li",[i("code",[e._v("ValidAndVerified")]),e._v(" either verifies the header using the trusting\nperiod or falls back to sequential\nverification")]),e._v(" "),i("li",[e._v("If "),i("a",{attrs:{href:"#LCV-INV-TP.1"}},[i("strong",[e._v("[LCV-INV-TP.1]")])]),e._v(" holds, eventually every\nheader will be verified and core verification "),i("strong",[e._v("terminates successfully")]),e._v(".")]),e._v(" "),i("li",[e._v("successful termination depends on the age of "),i("em",[e._v("lightStore.LatestVerified")]),e._v("\n(for instance, initially on the age of  "),i("em",[e._v("trustedHeader")]),e._v(") and the\nchanges of the validator sets on the blockchain.\nWe will give some examples "),i("a",{attrs:{href:"#liveness-scenarios"}},[e._v("below")]),e._v(".")])])]),e._v(" "),i("li",[e._v("If "),i("em",[e._v("primary")]),e._v(" is faulty,\n"),i("ul",[i("li",[e._v("it either provides headers that pass all the tests, and we\nreturn with the header")]),e._v(" "),i("li",[e._v("it provides one header that fails a test, core verification\n"),i("strong",[e._v("terminates with failure")]),e._v(".")]),e._v(" "),i("li",[e._v("it times out and core verification\n"),i("strong",[e._v("terminates with failure")]),e._v(".")])])])]),e._v(" "),i("h2",{attrs:{id:"liveness-scenarios"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#liveness-scenarios"}},[e._v("#")]),e._v(" Liveness Scenarios")]),e._v(" "),i("p",[e._v("The liveness argument above assumes "),i("a",{attrs:{href:"#LCV-INV-TP.1"}},[i("strong",[e._v("[LCV-INV-TP.1]")])])]),e._v(" "),i("p",[e._v("which requires that there is a header that does not expire before the\ntarget height is reached. Here we discuss scenarios to ensure this.")]),e._v(" "),i("p",[e._v("Let "),i("em",[e._v("startHeader")]),e._v(" be "),i("em",[e._v("LightStore.LatestVerified")]),e._v(" when core\nverification is called ("),i("em",[e._v("trustedHeader")]),e._v(") and "),i("em",[e._v("startTime")]),e._v(" be the time\ncore verification is invoked.")]),e._v(" "),i("p",[e._v("In order to ensure liveness, "),i("em",[e._v("LightStore")]),e._v(" always needs to contain a\nverified (or initially trusted) header whose time is within the\ntrusting period. To ensure this, core verification needs to add new\nheaders to "),i("em",[e._v("LightStore")]),e._v(" and verify them, before all headers in\n"),i("em",[e._v("LightStore")]),e._v(" expire.")]),e._v(" "),i("h4",{attrs:{id:"many-changes-in-validator-set"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#many-changes-in-validator-set"}},[e._v("#")]),e._v(" Many changes in validator set")]),e._v(" "),i("p",[e._v("Let's consider "),i("code",[e._v("Schedule")]),e._v(" implements\nbisection, that is, it halves the distance.\nAssume the case where the validator set changes completely in each\nblock. Then the\nmethod in this specification needs to\nsequentially verify all headers. That is, for")]),e._v(" "),i("ul",[i("li",[i("em",[e._v("W = log_2 (targetHeight - startHeader.Height)")]),e._v(",")])]),e._v(" "),i("p",[i("em",[e._v("W")]),e._v(" headers need to be downloaded and checked before the\nheader of height "),i("em",[e._v("startHeader.Height + 1")]),e._v(" is added to "),i("em",[e._v("LightStore")]),e._v(".")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Let "),i("em",[e._v("Comp")]),e._v("\nbe the local computation time needed to check headers and signatures\nfor one header.")])]),e._v(" "),i("li",[i("p",[e._v("Then we need in the worst case "),i("em",[e._v("Comp + 2 Delta")]),e._v(" to download and\ncheck one header.")])]),e._v(" "),i("li",[i("p",[e._v("Then the first time a verified header could be added to "),i("em",[e._v("LightStore")]),e._v(" is\nstartTime + W * (Comp + 2 Delta)")])]),e._v(" "),i("li",[i("p",[e._v("[TP.1] However, it can only be added if we still have a header in\n"),i("em",[e._v("LightStore")]),e._v(",\nwhich is not\nexpired, that is only the case if")]),e._v(" "),i("ul",[i("li",[e._v("startHeader.Time > startTime + WCG * (Comp + 2 Delta) -\ntrustingPeriod,")]),e._v(" "),i("li",[e._v("that is, if core verification is started at"),i("br"),e._v("\nstartTime < startHeader.Time + trustingPeriod -  WCG * (Comp + 2 Delta)")])])]),e._v(" "),i("li",[i("p",[e._v("one may then do an inductive argument from this point on, depending\non the implementation of "),i("code",[e._v("Schedule")]),e._v(". We may have to account for the\nheaders that are already\ndownloaded, but they are checked against the new "),i("em",[e._v("LightStore.LatestVerified")]),e._v(".")])])]),e._v(" "),i("blockquote",[i("p",[e._v("We observe that\nthe worst case time it needs to verify the header of height\n"),i("em",[e._v("targetHeight")]),e._v(" depends mainly on how frequent the validator set on the\nblockchain changes. That core verification terminates successfully\ncrucially depends on the check [TP.1], that is, that the headers in\n"),i("em",[e._v("LightStore")]),e._v(" do not expire in the time needed to download more\nheaders, which depends on the creation time of the headers in\n"),i("em",[e._v("LightStore")]),e._v(". That is, termination of core verification is highly\ndepending on the data stored in the blockchain.\nThe current light client core verification protocol exploits that, in\npractice, changes in the validator set are rare. For instance,\nconsider the following scenario.")])]),e._v(" "),i("h4",{attrs:{id:"no-change-in-validator-set"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#no-change-in-validator-set"}},[e._v("#")]),e._v(" No change in validator set")]),e._v(" "),i("p",[e._v("If on the blockchain the validator set of the block at height\n"),i("em",[e._v("targetHeight")]),e._v(" is equal to "),i("em",[e._v("startHeader.NextValidators")]),e._v(":")]),e._v(" "),i("ul",[i("li",[e._v("there is one round trip in "),i("code",[e._v("FetchLightBlock")]),e._v(" to download the light\nblock\nof height\n"),i("em",[e._v("targetHeight")]),e._v(", and "),i("em",[e._v("Comp")]),e._v(" to check it.")]),e._v(" "),i("li",[e._v("as the validator sets are equal, "),i("code",[e._v("Verify")]),e._v(" returns "),i("code",[e._v("SUCCESS")]),e._v(", if\n"),i("em",[e._v("startHeader.Time > now - trustingPeriod")]),e._v(".")]),e._v(" "),i("li",[e._v("that is, if "),i("em",[e._v("startTime < startHeader.Header.Time + trustingPeriod -\n2 Delta - Comp")]),e._v(", then core verification terminates successfully")])]),e._v(" "),i("h1",{attrs:{id:"part-v-supporting-the-ibc-relayer"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#part-v-supporting-the-ibc-relayer"}},[e._v("#")]),e._v(" Part V - Supporting the IBC Relayer")]),e._v(" "),i("p",[e._v("The above specification focuses on the most common case, which also\nconstitutes the most challenging task: using the Tendermint "),i("a",{attrs:{href:"#tmbc-fm-2thirds1"}},[e._v("security\nmodel")]),e._v(" to verify light blocks without\ndownloading all intermediate blocks. To focus on this challenge, above\nwe have restricted ourselves to the case where  "),i("em",[e._v("targetHeight")]),e._v(" is\ngreater than the height of any trusted header. This simplified\npresentation of the algorithm as initially\n"),i("code",[e._v("lightStore.LatestVerified()")]),e._v(" is less than "),i("em",[e._v("targetHeight")]),e._v(", and in the\nprocess of verification "),i("code",[e._v("lightStore.LatestVerified()")]),e._v(" increases until\n"),i("em",[e._v("targetHeight")]),e._v(" is reached.")]),e._v(" "),i("p",[e._v("For "),i("a",{attrs:{href:"https://github.com/informalsystems/ibc-rs",target:"_blank",rel:"noopener noreferrer"}},[e._v("IBC"),i("OutboundLink")],1),e._v(' it might be that some "older" header is\nneeded, that is,  '),i("em",[e._v("targetHeight < lightStore.LatestVerified()")]),e._v(". In this section we present a preliminary design, and we mark some\nremaining open questions.\nIf  "),i("em",[e._v("targetHeight < lightStore.LatestVerified()")]),e._v(" our design separates\nthe following cases:")]),e._v(" "),i("ul",[i("li",[e._v("A previous instance of "),i("code",[e._v("VerifyToTarget")]),e._v(" has already downloaded the\nlight block of "),i("em",[e._v("targetHeight")]),e._v(". There are two cases\n"),i("ul",[i("li",[e._v("the light block has been verified")]),e._v(" "),i("li",[e._v("the light block has not been verified yet")])])]),e._v(" "),i("li",[e._v("No light block of "),i("em",[e._v("targetHeight")]),e._v(" had been downloaded before. There\nare two cases:\n"),i("ul",[i("li",[e._v("there exists a verified light block of height less than  "),i("em",[e._v("targetHeight")])]),e._v(" "),i("li",[e._v('otherwise. In this case we need to do "backwards verification"\nusing the hash of the previous block in the '),i("code",[e._v("LastBlockID")]),e._v(" field\nof a header.")])])])]),e._v(" "),i("p",[i("strong",[e._v("Open Question:")]),e._v(" what are the security assumptions for backward\nverification. Should we check that the light block we verify from\n(and/or the checked light block) is within the trusting period?")]),e._v(" "),i("p",[e._v("The design just presents the above case\ndistinction as a function, and defines some auxiliary functions in the\nsame way the protocol was presented in\n"),i("a",{attrs:{href:"#part-iv---light-client-verification-protocol"}},[e._v("Part IV")]),e._v(".")]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyAobHMgTGlnaHRTdG9yZSkgTGF0ZXN0UHJldmlvdXMoaGVpZ2h0IEhlaWdodCkgKExpZ2h0QmxvY2ssIGJvb2wpCg=="}}),e._v(" "),i("ul",[i("li",[e._v("Expected postcondition\n"),i("ul",[i("li",[e._v("returns a light block "),i("em",[e._v("lb")]),e._v(" that satisfies:\n"),i("ul",[i("li",[i("em",[e._v("lb")]),e._v(" is in lightStore")]),e._v(" "),i("li",[i("em",[e._v("lb")]),e._v(" is verified and not expired")]),e._v(" "),i("li",[i("em",[e._v("lb.Header.Height < height")])]),e._v(" "),i("li",[e._v("for all "),i("em",[e._v("b")]),e._v(" in lightStore s.t. "),i("em",[e._v("b")]),e._v(" is verified and not expired it\nholds "),i("em",[e._v("lb.Header.Height >= b.Header.Height")])])])]),e._v(" "),i("li",[i("em",[e._v("false")]),e._v(" in the second argument if\nthe LightStore does not contain such an "),i("em",[e._v("lb")]),e._v(".")])])])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyAobHMgTGlnaHRTdG9yZSkgTWluVmVyaWZpZWQoKSAoTGlnaHRCbG9jaywgYm9vbCkK"}}),e._v(" "),i("ul",[i("li",[e._v("Expected postcondition\n"),i("ul",[i("li",[e._v("returns a light block "),i("em",[e._v("lb")]),e._v(" that satisfies:\n"),i("ul",[i("li",[i("em",[e._v("lb")]),e._v(" is in lightStore")]),e._v(" "),i("li",[i("em",[e._v("lb")]),e._v(" is verified "),i("strong",[e._v("Open Question:")]),e._v(" replace by trusted?")]),e._v(" "),i("li",[i("em",[e._v("lb.Header.Height")]),e._v(" is minimal in the lightStore")]),e._v(" "),i("li",[i("strong",[e._v("Open Question:")]),e._v(" according to this, it might be expired (outside the\ntrusting period). This approach appears safe. Are there reasons we\nshould not do that?")])])]),e._v(" "),i("li",[i("em",[e._v("false")]),e._v(" in the second argument if\nthe LightStore does not contain such an "),i("em",[e._v("lb")]),e._v(".")])])])]),e._v(" "),i("p",[e._v("If a height that is smaller than the smallest height in the lightstore\nis required, we check the hashes backwards. This is done with the\nfollowing function:")]),e._v(" "),i("h4",{attrs:{id:"lcv-func-backwards-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-func-backwards-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-FUNC-BACKWARDS.1]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBCYWNrd2FyZHMgKHByaW1hcnkgUGVlcklELCBsaWdodFN0b3JlIExpZ2h0U3RvcmUsIHRhcmdldEhlaWdodCBIZWlnaHQpCiAgICAgICAgICAgICAgIChMaWdodFN0b3JlLCBSZXN1bHQpIHsKICAKICAgIGxiLHJlcyA9IGxpZ2h0U3RvcmUuTWluVmVyaWZpZWQoKQogICAgaWYgcmVzID0gZmFsc2UgewogICAgICAgIHJldHVybiAobGlnaHRTdG9yZSwgUmVzdWx0RmFpbHVyZSkKICAgIH0KCiAgICBsYXRlc3QgOj0gbGIuSGVhZGVyCiAgICBmb3IgaSA6PSBsYi5IZWFkZXIuaGVpZ2h0IC0gMTsgaSAmZ3Q7PSB0YXJnZXRIZWlnaHQ7IGktLSB7CiAgICAgICAgLy8gaGVyZSB3ZSBkb3dubG9hZCBoZWlnaHQtYnktaGVpZ2h0LiBXZSBtaWdodCBmaXJzdCBkb3dubG9hZCBhbGwKICAgICAgICAvLyBoZWFkZXJzIGRvd24gdG8gdGFyZ2V0SGVpZ2h0IGFuZCB0aGVuIGNoZWNrIHRoZW0uCiAgICAgICAgY3VycmVudCA6PSBGZXRjaExpZ2h0QmxvY2socHJpbWFyeSxpKQogICAgICAgIGlmIChoYXNoKGN1cnJlbnQpICE9IGxhdGVzdC5IZWFkZXIuTGFzdEJsb2NrSWQpIHsKICAgICAgICAgICAgcmV0dXJuIChsaWdodFN0b3JlLCBSZXN1bHRGYWlsdXJlKQogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgICAgbGlnaHRTdG9yZS5VcGRhdGUoY3VycmVudCwgU3RhdGVWZXJpZmllZCkKICAgICAgICAgICAgLy8gKipPcGVuIFF1ZXN0aW9uOioqIERvIHdlIG5lZWQgYSBuZXcgc3RhdGUgdHlwZSBmb3IKICAgICAgICAgICAgLy8gYmFja3dhcmRzIHZlcmlmaWVkIGxpZ2h0IGJsb2Nrcz8KICAgICAgICB9CiAgICAgICAgbGF0ZXN0ID0gY3VycmVudAogICAgfQogICAgcmV0dXJuIChsaWdodFN0b3JlLCBSZXN1bHRTdWNjZXNzKQp9Cg=="}}),e._v(" "),i("p",[e._v("The following function just decided based on the required height which\nmethod should be used.")]),e._v(" "),i("h4",{attrs:{id:"lcv-func-ibcmain-1"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lcv-func-ibcmain-1"}},[e._v("#")]),e._v(" "),i("strong",[e._v("[LCV-FUNC-IBCMAIN.1]")])]),e._v(" "),i("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBNYWluIChwcmltYXJ5IFBlZXJJRCwgbGlnaHRTdG9yZSBMaWdodFN0b3JlLCB0YXJnZXRIZWlnaHQgSGVpZ2h0KQogICAgICAgICAgKExpZ2h0U3RvcmUsIFJlc3VsdCkgewoKICAgIGIxLCByMSA9IGxpZ2h0U3RvcmUuR2V0KHRhcmdldEhlaWdodCkKICAgIGlmIHIxID0gdHJ1ZSBhbmQgYjEuU3RhdGUgPSBTdGF0ZVZlcmlmaWVkIHsKICAgICAgICAvLyBibG9jayBhbHJlYWR5IHRoZXJlCiAgICAgICAgcmV0dXJuIChsaWdodFN0b3JlLCBSZXN1bHRTdWNjZXNzKQogICAgfQoKICAgIGlmIHRhcmdldEhlaWdodCAmZ3Q7IGxpZ2h0U3RvcmUuTGF0ZXN0VmVyaWZpZWQuaGVpZ2h0IHsKICAgICAvLyBjYXNlIG9mIFBhcnQgSVYKICAgICAgICByZXR1cm4gVmVyaWZ5VG9UYXJnZXQocHJpbWFyeSwgbGlnaHRTdG9yZSwgdGFyZ2V0SGVpZ2h0KQogICAgfQogICAgZWxzZSB7CiAgICAgICAgYjIsIHIyID0gbGlnaHRTdG9yZS5MYXRlc3RQcmV2aW91cyh0YXJnZXRIZWlnaHQpOwogICAgICAgIGlmIHIyID0gdHJ1ZSB7CiAgICAgICAgICAgIC8vIG1ha2UgYXV4aWxpYXJ5IGxpZ2h0U3RvcmUgYXV4TFMgdG8gY2FsbCBWZXJpZnlUb1RhcmdldC4KICAgLy8gVmVyaWZ5VG9UYXJnZXQgdXNlcyBMYXRlc3RWZXJpZmllZCBvZiB0aGUgZ2l2ZW4gbGlnaHRTdG9yZQogICAgICAgICAgICAvLyBGb3IgdGhhdCB3ZSBuZWVkOgogICAgICAgICAgICAvLyBhdXhMUy5MYXRlc3RWZXJpZmllZCA9IGxpZ2h0U3RvcmUuTGF0ZXN0UHJldmlvdXModGFyZ2V0SGVpZ2h0KQogICAgICAgICAgICBhdXhMUy5Jbml0OwogICAgICAgICAgICBhdXhMUy5VcGRhdGUoYjIsU3RhdGVWZXJpZmllZCk7CiAgICAgICAgICAgIGlmIHIxID0gdHJ1ZSB7CiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHZlcmlmeSBhIHByZXZpb3VzbHkgZG93bmxvYWRlZCBsaWdodCBibG9jay4KICAgICAgICAgICAgICAgIC8vIHdlIGFkZCBpdCB0byB0aGUgYXV4aWxpYXJ5IHN0b3JlIHNvIHRoYXQgVmVyaWZ5VG9UYXJnZXQKICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRvd25sb2FkIGl0IGFnYWluCiAgICAgICAgICAgICAgICBhdXhMUy5VcGRhdGUoYjEsYjEuU3RhdGUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGF1eExTLCByZXMyID0gVmVyaWZ5VG9UYXJnZXQocHJpbWFyeSwgYXV4TFMsIHRhcmdldEhlaWdodCkKICAgICAgICAgICAgLy8gbW92ZSBhbGwgbGlnaHRibG9ja3MgZnJvbSBhdXhMUyB0byBsaWdodFN0b3JlLAogICAgICAgICAgICAvLyBtYWludGFpbiBzdGF0ZQogICAvLyB3ZSBkbyB0aGF0IHdoZXRoZXIgVmVyaWZ5VG9UYXJnZXQgd2FzIHN1Y2Nlc3NmdWwgb3Igbm90CiAgICAgICAgICAgIGZvciBpLCBzIHJhbmdlIGF1eExTIHsKICAgICAgICAgICAgICAgIGxpZ2hTdG9yZS5VcGRhdGUocyxzLlN0YXRlKQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAobGlnaHRTdG9yZSwgcmVzMikKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBCYWNrd2FyZHMocHJpbWFyeSwgbGlnaHRTdG9yZSwgdGFyZ2V0SGVpZ2h0KQogICAgICAgIH0KICAgIH0KfQo="}}),e._v(" "),i("h1",{attrs:{id:"references"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),i("p",[e._v("["),i("a",{attrs:{href:"https://github.com/tendermint/spec/blob/d46cd7f573a2c6a2399fcab2cde981330aa63f37/spec/core/data_structures.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("block"),i("OutboundLink")],1),e._v("] Specification of the block data structure.")]),e._v(" "),i("p",[e._v("["),i("a",{attrs:{href:"https://docs.tendermint.com/master/rpc/",target:"_blank",rel:"noopener noreferrer"}},[e._v("RPC"),i("OutboundLink")],1),e._v("] RPC client for Tendermint")]),e._v(" "),i("p",[e._v("["),i("a",{attrs:{href:"https://github.com/informalsystems/tendermint-rs/blob/master/docs/spec/lightclient/detection.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("fork-detector"),i("OutboundLink")],1),e._v("] The specification of the light client fork detector.")]),e._v(" "),i("p",[e._v("["),i("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("fullnode"),i("OutboundLink")],1),e._v("] Specification of the full node API")]),e._v(" "),i("p",[e._v("["),i("a",{attrs:{href:"https://github.com/informalsystems/ibc-rs",target:"_blank",rel:"noopener noreferrer"}},[e._v("ibc-rs"),i("OutboundLink")],1),e._v("] Rust implementation of IBC modules and relayer.")]),e._v(" "),i("p",[e._v("["),i("a",{attrs:{href:"https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("lightclient"),i("OutboundLink")],1),e._v("] The light client ADR [77d2651 on Dec 27, 2019].")])],1)}),[],!1,null,null,null);t.default=r.exports}}]);