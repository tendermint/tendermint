(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{795:function(e,t,a){"use strict";a.r(t);var i=a(1),n=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"this-an-unfinished-draft-comments-are-welcome"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this-an-unfinished-draft-comments-are-welcome"}},[e._v("#")]),e._v(" "),a("em",[a("strong",[e._v("This an unfinished draft. Comments are welcome!")])])]),e._v(" "),a("p",[a("strong",[e._v("TODO:")]),e._v(" We will need to do small adaptations to the verification\nspec to reflect the semantics in the LightStore (verified, trusted,\nuntrusted, etc. not needed anymore). In more detail:")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("The state of the Lightstore needs to go. Functions like "),a("code",[e._v("LatestVerified")]),e._v(" can\nkeep the name but will ignore state as it will not exist anymore.")])]),e._v(" "),a("li",[a("p",[e._v("verification spec should be adapted to the second parameter of\n"),a("code",[e._v("VerifyToTarget")]),e._v("\nbeing a lightblock; new version number of function tag;")])]),e._v(" "),a("li",[a("p",[e._v("We should clarify what is the expectation of VerifyToTarget\nso if it returns TimeoutError it can be assumed faulty. I guess that\nVerifyToTarget with correct full node should never terminate with\nTimeoutError.")])]),e._v(" "),a("li",[a("p",[e._v("We need to introduce a new version number for the new\nspecification. So we should decide how\nto handle that.")])])]),e._v(" "),a("h1",{attrs:{id:"light-client-attack-detector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#light-client-attack-detector"}},[e._v("#")]),e._v(" Light Client Attack Detector")]),e._v(" "),a("p",[e._v("In this specification, we strengthen the light client to be resistant\nagainst so-called light client attacks. In a light client attack, all\nthe correct Tendermint full nodes agree on the sequence of generated\nblocks (no fork), but a set of faulty full nodes attack a light client\nby generating (signing) a block that deviates from the block of the\nsame height on the blockchain. In order to do so, some of these faulty\nfull nodes must have been validators before and violate\n"),a("a",{attrs:{href:"TMBC-FM-2THIRDS-link"}},[e._v("[TMBC-FM-2THIRDS]")]),e._v(", as otherwise, if\n"),a("a",{attrs:{href:"TMBC-FM-2THIRDS-link"}},[e._v("[TMBC-FM-2THIRDS]")]),e._v(" would hold,\n"),a("a",{attrs:{href:"verification"}},[e._v("verification")]),e._v(" would satisfy\n"),a("a",{attrs:{href:"LCV-SEQ-SAFE-link"}},[e._v("[LCV-SEQ-SAFE.1]")]),e._v(".")]),e._v(" "),a("p",[e._v("An attack detector (or detector for short) is a mechanism that is used\nby the light client "),a("a",{attrs:{href:"supervisor"}},[e._v("supervisor")]),e._v(" after\n"),a("a",{attrs:{href:"verification"}},[e._v("verification")]),e._v(" of a new light block\nwith the primary, to cross-check the newly learned light block with\nother peers (secondaries).  It expects as input a light block with some\nheight "),a("em",[e._v("root")]),e._v(" (that serves as a root of trust), and a verification\ntrace (a sequence of lightblocks) that the primary provided.")]),e._v(" "),a("p",[e._v("In case the detector observes a light client attack, it computes\nevidence data that can be used by Tendermint full nodes to isolate a\nset of faulty full nodes that are still within the unbonding period\n(more than 1/3 of the voting power of the validator set at some block of the chain),\nand report them via ABCI to the application of a Tendermint blockchain\nin order to punish faulty nodes.")]),e._v(" "),a("h2",{attrs:{id:"context-of-this-document"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context-of-this-document"}},[e._v("#")]),e._v(" Context of this document")]),e._v(" "),a("p",[e._v("The light client "),a("a",{attrs:{href:"verification"}},[e._v("verification")]),e._v(" specification is\ndesigned for the Tendermint failure model (1/3 assumption)\n"),a("a",{attrs:{href:"TMBC-FM-2THIRDS-link"}},[e._v("[TMBC-FM-2THIRDS]")]),e._v(".  It is safe under this\nassumption, and live if it can reliably (that is, no message loss, no\nduplication, and eventually delivered) and timely communicate with a\ncorrect full node. If "),a("a",{attrs:{href:"TMBC-FM-2THIRDS-link"}},[e._v("[TMBC-FM-2THIRDS]")]),e._v(" assumption is violated, the light client\ncan be fooled to trust a light block that was not generated by\nTendermint consensus.")]),e._v(" "),a("p",[e._v('This specification, the attack detector, is a "second line of\ndefense", in case the 1/3 assumption is violated.  Its goal is to\ndetect a light client attack (conflicting light blocks) and collect\nevidence. However, it is impractical to probe all full nodes. At this\ntime we consider a simple scheme of maintaining an address book of\nknown full nodes from which a small subset (e.g., 4) are chosen\ninitially to communicate with. More involved book keeping with\nprobabilistic guarantees can be considered at later stages of the\nproject.')]),e._v(" "),a("p",[e._v("The light client maintains a simple address book containing addresses\nof full nodes that it can pick as primary and secondaries.  To obtain\na new light block, the light client first does\n"),a("a",{attrs:{href:"verification"}},[e._v("verification")]),e._v(" with the primary, and then cross-checks\nthe light block (and the trace of light blocks that led to it) with\nthe secondaries using this specification.")]),e._v(" "),a("h2",{attrs:{id:"tendermint-consensus-and-light-client-attacks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tendermint-consensus-and-light-client-attacks"}},[e._v("#")]),e._v(" Tendermint Consensus and Light Client Attacks")]),e._v(" "),a("p",[e._v("In this section we will give some mathematical definitions of what we\nmean by light client attacks (that are considered in this\nspecification) and how they differ from main-chain forks. To this end\nwe start by defining some properties of the sequence of blocks that is\ndecided upon by Tendermint consensus in normal operation (if the\nTendermint failure model holds\n"),a("a",{attrs:{href:"TMBC-FM-2THIRDS-link"}},[e._v("[TMBC-FM-2THIRDS]")]),e._v("),\nand then define different\ndeviations that correspond to attack scenarios.")]),e._v(" "),a("h4",{attrs:{id:"tmbc-genesis-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-genesis-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-GENESIS.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("Genesis")]),e._v(" be the agreed-upon initial block (file).")]),e._v(" "),a("h4",{attrs:{id:"tmbc-func-sign-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-func-sign-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-FUNC-SIGN.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(" be two light blocks with "),a("em",[e._v("b.Header.Height + 1 =\nc.Header.Height")]),e._v(". We define the predicate "),a("strong",[e._v("signs(b,c)")]),e._v(" to hold\niff "),a("em",[e._v("c.Header.LastCommit")]),e._v(" is in "),a("em",[e._v("PossibleCommit(b)")]),e._v(".\n"),a("a",{attrs:{href:"TMBC-SOUND-DISTR-POSS-COMMIT-link"}},[e._v("[TMBC-SOUND-DISTR-POSS-COMMIT.1]")]),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("The above encodes sequential verification, that is, intuitively,\nb.Header.NextValidators = c.Header.Validators and 2/3 of\nthese Validators signed c?")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-func-support-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-func-support-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-FUNC-SUPPORT.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(" be two light blocks. We define the predicate\n"),a("strong",[e._v("supports(b,c,t)")]),e._v(" to hold iff")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("t - trustingPeriod < b.Header.Time < t")])]),e._v(" "),a("li",[e._v("the voting power in "),a("em",[e._v("b.NextValidators")]),e._v(" of nodes in "),a("em",[e._v("c.Commit")]),e._v("\nis more than 1/3 of "),a("em",[e._v("TotalVotingPower(b.Header.NextValidators)")])])]),e._v(" "),a("blockquote",[a("p",[e._v("That is, if the "),a("a",{attrs:{href:"TMBC-FM-2THIRDS-link"}},[e._v("Tendermint failure model")]),e._v("\nholds, then "),a("em",[e._v("c")]),e._v(" has been signed by at least one correct full node, cf.\n"),a("a",{attrs:{href:"TMBC-VAL-CONTAINS-CORR-link"}},[e._v("[TMBC-VAL-CONTAINS-CORR.1]")]),e._v(".\nThe following formalizes that "),a("em",[e._v("b")]),e._v(" was properly generated by\nTendermint; "),a("em",[e._v("b")]),e._v(" can be traced back to genesis")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-seq-rooted-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-seq-rooted-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-SEQ-ROOTED.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" be a light block.\nWe define "),a("em",[e._v("sequ-rooted(b)")]),e._v(" iff for all "),a("em",[e._v("i")]),e._v(", "),a("em",[e._v("1 <= i < h = b.Header.Height")]),e._v(",\nthere exist light blocks "),a("em",[e._v("a(i)")]),e._v(" s.t.")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("a(1) = Genesis")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("a(h) = b")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("signs( a(i) , a(i+1) )")]),e._v(".")])]),e._v(" "),a("blockquote",[a("p",[e._v("The following formalizes that "),a("em",[e._v("c")]),e._v(" is trusted based on "),a("em",[e._v("b")]),e._v(" in\nskipping verification. Observe that we do not require here (yet)\nthat "),a("em",[e._v("b")]),e._v(" was properly generated.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-skip-trace-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-skip-trace-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-SKIP-TRACE.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(" be light blocks. We define "),a("em",[e._v("skip-trace(b,c,t)")]),e._v(" if at\ntime t there exists an "),a("em",[e._v("h")]),e._v(" and a sequence "),a("em",[e._v("a(1)")]),e._v(", ... "),a("em",[e._v("a(h)")]),e._v(" s.t.")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("a(1) = b")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("a(h) = c")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("supports( a(i), a(i+1), t)")]),e._v(", for all i, "),a("em",[e._v("1 <= i < h")]),e._v(".")])]),e._v(" "),a("p",[e._v("We call such a sequence "),a("em",[e._v("a(1)")]),e._v(", ... "),a("em",[e._v("a(h)")]),e._v(" a "),a("strong",[e._v("verification trace")]),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("The following formalizes that two light blocks of the same height\nshould agree on the content of the header. Observe that "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v("\nmay disagree on the Commit. This is a special case if the canonical\ncommit has not been decided on, that is, if b.Header.Height is the\nmaximum height of all blocks decided upon by Tendermint at this\nmoment.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-sign-skip-match-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-sign-skip-match-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-SIGN-SKIP-MATCH.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("a")]),e._v(", "),a("em",[e._v("b")]),e._v(", "),a("em",[e._v("c")]),e._v(", be light blocks and "),a("em",[e._v("t")]),e._v(" a time, we define\n"),a("em",[e._v("sign-skip-match(a,b,c,t) = true")]),e._v(" iff the following implication\nevaluates to true:")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("sequ-rooted(a)")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("b.Header.Height = c.Header.Height")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("skip-trace(a,b,t)")])]),e._v(" "),a("li",[a("em",[e._v("skip-trace(a,c,t)")])])]),e._v(" "),a("p",[e._v("implies "),a("em",[e._v("b.Header = c.Header")]),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("Observe that "),a("em",[e._v("sign-skip-match")]),e._v(" is defined via an implication. If it\nevaluates to false this means that the left-hand-side of the\nimplication evaluates to true, and the right-hand-side evaluates to\nfalse. In particular, there are two "),a("strong",[e._v("different")]),e._v(" headers "),a("em",[e._v("b")]),e._v(" and\n"),a("em",[e._v("c")]),e._v(" that both can be verified from a common block "),a("em",[e._v("a")]),e._v(" from the\nchain. Thus, the following describes an attack.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-attack-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-ATTACK.1]")])]),e._v(" "),a("p",[e._v("If there exists three light blocks a, b, and c, with\n"),a("em",[e._v("sign-skip-match(a,b,c,t) = false")]),e._v(" then we have an "),a("em",[e._v("attack")]),e._v(".  We say\nwe have "),a("strong",[e._v("an attack at height")]),e._v(" "),a("em",[e._v("b.Header.Height")]),e._v(" and write\n"),a("em",[e._v("attack(a,b,c,t)")]),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("The lightblock "),a("em",[e._v("a")]),e._v(" need not be unique, that is, there may be\nseveral blocks that satisfy the above requirement for the same\nblocks "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(".")])]),e._v(" "),a("p",[a("a",{attrs:{href:"#TMBC-ATTACK1"}},[e._v("[TMBC-ATTACK.1]")]),e._v(" is a formalization of the violation\nof the agreement property based on the result of consensus, that is,\nthe generated blocks.")]),e._v(" "),a("p",[a("strong",[e._v("Remark.")]),e._v('\nViolation of agreement is only possible if more than 1/3 of the validators (or\nnext validators) of some previous block deviated from the protocol. The\nupcoming "accountability" specification will describe how to compute\na set of at least 1/3 faulty nodes from two conflicting blocks. []')]),e._v(" "),a("p",[e._v('There are different ways to characterize forks\nand attack scenarios. This specification uses the "node-based\ncharacterization of attacks" which focuses on what kinds of nodes are\naffected (light nodes vs. full nodes). For future reference and\ndiscussion we also provide a\n"block-based characterization of attacks" below.')]),e._v(" "),a("h3",{attrs:{id:"node-based-characterization-of-attacks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-based-characterization-of-attacks"}},[e._v("#")]),e._v(" Node-based characterization of attacks")]),e._v(" "),a("h4",{attrs:{id:"tmbc-mc-fork-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-mc-fork-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-MC-FORK.1]")])]),e._v(" "),a("p",[e._v("We say there is a (main chain) fork at time "),a("em",[e._v("t")]),e._v(" if")]),e._v(" "),a("ul",[a("li",[e._v("there are two correct full nodes "),a("em",[e._v("i")]),e._v(" and "),a("em",[e._v("j")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("i")]),e._v(" is different from "),a("em",[e._v("j")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("i")]),e._v(" has decided on "),a("em",[e._v("b")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("j")]),e._v(" has decided on "),a("em",[e._v("c")]),e._v(" and")]),e._v(" "),a("li",[e._v("there exist "),a("em",[e._v("a")]),e._v(" such that "),a("em",[e._v("attack(a,b,c,t)")]),e._v(".")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-lc-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-lc-attack-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-LC-ATTACK.1]")])]),e._v(" "),a("p",[e._v("We say there is a light client attack at time "),a("em",[e._v("t")]),e._v(", if")]),e._v(" "),a("ul",[a("li",[e._v("there is "),a("strong",[e._v("no")]),e._v(" (main chain) fork "),a("a",{attrs:{href:"#TMBC-MC-FORK1"}},[e._v("[TMBC-MC-FORK.1]")]),e._v(", and")]),e._v(" "),a("li",[e._v("there exist nodes that have computed light blocks "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(" and")]),e._v(" "),a("li",[e._v("there exist "),a("em",[e._v("a")]),e._v(" such that "),a("em",[e._v("attack(a,b,c,t)")]),e._v(".")])]),e._v(" "),a("p",[e._v("We say the attack is at height "),a("em",[e._v("a.Header.Height")]),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("In this specification we consider detection of light client\nattacks. Intuitively, the case we consider is that\nlight block "),a("em",[e._v("b")]),e._v(" is the one from the\nblockchain, and some attacker has computed "),a("em",[e._v("c")]),e._v(" and tries to wrongly\nconvince\nthe light client that "),a("em",[e._v("c")]),e._v(" is the block from the chain.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-lc-attack-evidence-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-lc-attack-evidence-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-LC-ATTACK-EVIDENCE.1]")])]),e._v(" "),a("p",[e._v("We consider the following case of a light client attack\n"),a("a",{attrs:{href:"#TMBC-LC-ATTACK1"}},[e._v("[TMBC-LC-ATTACK.1]")]),e._v(":")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("attack(a,b,c,t)")])]),e._v(" "),a("li",[e._v("there is a peer p1 that has a sequence "),a("em",[e._v("chain")]),e._v(" of blocks from "),a("em",[e._v("a")]),e._v(" to "),a("em",[e._v("b")])]),e._v(" "),a("li",[a("em",[e._v("skip-trace(a,c,t)")]),e._v(": by "),a("a",{attrs:{href:"#TMBC-SKIP-TRACE1"}},[e._v("[TMBC-SKIP-TRACE.1]")]),e._v(" there is a\nverification trace "),a("em",[e._v("v")]),e._v(" of the form "),a("em",[e._v("a = v(1)")]),e._v(", ... "),a("em",[e._v("v(h) = c")])])]),e._v(" "),a("p",[e._v("Evidence for p1 (that proves an attack) consists for index i\nof v(i) and v(i+1) such that")]),e._v(" "),a("ul",[a("li",[e._v("E1(i). v(i) is equal to the block of "),a("em",[e._v("chain")]),e._v(" at height v(i).Height, and")]),e._v(" "),a("li",[e._v("E2(i). v(i+1) that is different from  the block of "),a("em",[e._v("chain")]),e._v(" at\nheight v(i+1).height")])]),e._v(" "),a("blockquote",[a("p",[e._v("Observe p1 can")]),e._v(" "),a("ul",[a("li",[e._v("check that v(i+1)  differs from its block at that height, and")]),e._v(" "),a("li",[e._v("verify v(i+1) in one step from v(i) as v is a verification trace.")])])]),e._v(" "),a("p",[a("strong",[e._v("Proposition.")]),e._v(" In the case of attack, evidence exists."),a("br"),e._v(" "),a("em",[e._v("Proof.")]),e._v(" First observe that")]),e._v(" "),a("ul",[a("li",[e._v("(A). (NOT E2(i)) implies E1(i+1)")])]),e._v(" "),a("p",[e._v("Now by contradiction assume there is no evidence. Thus")]),e._v(" "),a("ul",[a("li",[e._v("for all i, we have NOT E1(i) or NOT E2(i)")]),e._v(" "),a("li",[e._v("for i = 1 we have E1(1) and thus NOT E2(1)\nthus by induction on i, by (A) we have for all i that "),a("strong",[e._v("E1(i)")])]),e._v(" "),a("li",[e._v("from attack we have E2(h-1), and as there is no evidence for\ni = h - 1 we get "),a("strong",[e._v("NOT E1(h-1)")]),e._v(". Contradiction.\nQED.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-lc-evidence-data-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-lc-evidence-data-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-LC-EVIDENCE-DATA.1]")])]),e._v(" "),a("p",[e._v("To prove the attack to p1, because of Point E1, it is sufficient to\nsubmit")]),e._v(" "),a("ul",[a("li",[e._v("v(i).Height (rather than v(i)).")]),e._v(" "),a("li",[e._v("v(i+1)")])]),e._v(" "),a("p",[e._v("This information is "),a("em",[e._v("evidence for height v(i).Height")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"block-based-characterization-of-attacks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#block-based-characterization-of-attacks"}},[e._v("#")]),e._v(" Block-based characterization of attacks")]),e._v(" "),a("p",[e._v("In this section we provide a different characterization of attacks. It\nis not defined on the nodes that are affected but purely on the\ncontent of the blocks. In that sense these definitions are less\noperational.")]),e._v(" "),a("blockquote",[a("p",[e._v("They might be relevant for a closer analysis of fork scenarios on the\nchain, which is out of the scope of this specification.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-sign-unique-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-sign-unique-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-SIGN-UNIQUE.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" and "),a("em",[e._v("c")]),e._v(" be  light blocks, we define the predicate\n"),a("em",[e._v("sign-unique(b,c)")]),e._v(" to evaluate to true iff the following implication\nevaluates to true:")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("b.Header.Height =  c.Header.Height")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("sequ-rooted(b)")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("sequ-rooted(c)")])])]),e._v(" "),a("p",[e._v("implies "),a("em",[e._v("b = c")]),e._v(".")]),e._v(" "),a("h4",{attrs:{id:"tmbc-blocks-mcfork-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-blocks-mcfork-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-BLOCKS-MCFORK.1]")])]),e._v(" "),a("p",[e._v("If there exists two light blocks b and c, with "),a("em",[e._v("sign-unique(b,c) =\nfalse")]),e._v(" then we have a "),a("em",[e._v("fork")]),e._v(".")]),e._v(" "),a("blockquote",[a("p",[e._v("The difference of the above definition to\n"),a("a",{attrs:{href:"#TMBC-MC-FORK1"}},[e._v("[TMBC-MC-FORK.1]")]),e._v(" is subtle. The latter requires a\nfull node being affected by a bad block while\n"),a("a",{attrs:{href:"#TMBC-BLOCKS-MCFORK1"}},[e._v("[TMBC-BLOCKS-MCFORK.1]")]),e._v(" just requires that a\nbad block exists, possibly in memory of an attacker.\nThe following captures a light client fork. There is no fork up to\nthe height of block b. However, c is of that height, is different,\nand passes skipping verification. It is a stricter property than\n"),a("a",{attrs:{href:"#TMBC-LC-ATTACK1"}},[e._v("[TMBC-LC-ATTACK.1]")]),e._v(", as\n"),a("a",{attrs:{href:"#TMBC-LC-ATTACK1"}},[e._v("[TMBC-LC-ATTACK.1]")]),e._v(" requires that no correct full\nnode is affected.")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-blocks-lcfork-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-blocks-lcfork-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-BLOCKS-LCFORK.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("a")]),e._v(", "),a("em",[e._v("b")]),e._v(", "),a("em",[e._v("c")]),e._v(", be light blocks and "),a("em",[e._v("t")]),e._v(" a time. We define\n"),a("em",[e._v("light-client-fork(a,b,c,t)")]),e._v(" iff")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("sign-skip-match(a,b,c,t) = false")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("sequ-rooted(b)")]),e._v(" and")]),e._v(" "),a("li",[a("em",[e._v("b")]),e._v(' is "unique", that is, for all '),a("em",[e._v("d")]),e._v(",  "),a("em",[e._v("sequ-rooted(d)")]),e._v(" and\n"),a("em",[e._v("d.Header.Height = b.Header.Height")]),e._v(" implies "),a("em",[e._v("d = b")])])]),e._v(" "),a("blockquote",[a("p",[e._v("Finally, let us also define bogus blocks that have no support.\nObserve that bogus is even defined if there is a fork.\nAlso, for the definition it would be sufficient to restrict "),a("em",[e._v("a")]),e._v(" to\n"),a("em",[e._v("a.height < b.height")]),e._v(" (which is implied by the definitions which\nunfold until "),a("em",[e._v("supports()")]),e._v(").")])]),e._v(" "),a("h4",{attrs:{id:"tmbc-bogus-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tmbc-bogus-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[TMBC-BOGUS.1]")])]),e._v(" "),a("p",[e._v("Let "),a("em",[e._v("b")]),e._v(" be a light block and "),a("em",[e._v("t")]),e._v(" a time. We define "),a("em",[e._v("bogus(b,t)")]),e._v(" iff")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("sequ-rooted(b) = false")]),e._v(" and")]),e._v(" "),a("li",[e._v("for all "),a("em",[e._v("a")]),e._v(", "),a("em",[e._v("sequ-rooted(a)")]),e._v(" implies "),a("em",[e._v("skip-trace(a,b,t) = false")])])]),e._v(" "),a("h3",{attrs:{id:"informal-problem-statement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#informal-problem-statement"}},[e._v("#")]),e._v(" Informal Problem statement")]),e._v(" "),a("p",[e._v("There is no sequential specification: the detector only makes sense\nin a distributed systems where some nodes misbehave.")]),e._v(" "),a("p",[e._v("We work under the assumption that full nodes and validators are\nresponsible for detecting attacks on the main chain, and the evidence\nreactor takes care of broadcasting evidence to communicate\nmisbehaving nodes via ABCI to the application, and halt the chain in\ncase of a fork. The point of this specification is to shield a light\nclients against attacks that cannot be detected by full nodes, and\nare fully addressed at light clients (and consequently IBC relayers,\nwhich use the light client protocols to observe the state of a\nblockchain). In order to provide full nodes the incentive to follow\nthe protocols when communicating with the light client, this\nspecification also considers the generation of evidence that will\nalso be processed by the Tendermint blockchain.")]),e._v(" "),a("h4",{attrs:{id:"lcd-ip-model-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-ip-model-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-IP-MODEL.1]")])]),e._v(" "),a("p",[e._v("The detector is designed under the assumption that")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"TMBC-FM-2THIRDS-link"}},[e._v("[TMBC-FM-2THIRDS]")]),e._v(" may be violated")]),e._v(" "),a("li",[e._v("there is no fork on the main chain.")])]),e._v(" "),a("blockquote",[a("p",[e._v("As a result some faulty full nodes may launch an attack on a light\nclient.")])]),e._v(" "),a("p",[e._v("The following requirements are operational in that they describe how\nthings should be done, rather than what should be done. However, they\ndo not constitute temporal logic verification conditions. For those,\nsee [LCD-DIST-*] below.")]),e._v(" "),a("p",[e._v("The detector is called in the "),a("a",{attrs:{href:"supervisor"}},[e._v("supervisor")]),e._v(" as follows")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"RXZpZGVuY2VzIDo9IEF0dGFja0RldGVjdG9yKHJvb3Rfb2ZfdHJ1c3QsIHZlcmlmaWVkTFMpO2AK"}}),e._v(" "),a("p",[e._v("where")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("root-of-trust")]),e._v(" is a light block that is trusted (that is,\nexcept upon initialization, the primary and the secondaries\nagreed on in the past), and")]),e._v(" "),a("li",[a("code",[e._v("verifiedLS")]),e._v(" is a lightstore that contains a verification trace that\nstarts from a lightblock that can be verified with the\n"),a("code",[e._v("root-of-trust")]),e._v(" in one step and ends with a lightblock of the height\nrequested by the user")]),e._v(" "),a("li",[a("code",[e._v("Evidences")]),e._v(" is a list of evidences for misbehavior")])]),e._v(" "),a("h4",{attrs:{id:"lcd-ip-statement-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-ip-statement-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-IP-STATEMENT.1]")])]),e._v(" "),a("p",[e._v("Whenever AttackDetector is called, the detector should for each\nsecondary try to replay the verification trace "),a("code",[e._v("verifiedLS")]),e._v(" with the\nsecondary")]),e._v(" "),a("ul",[a("li",[e._v("in case replaying leads to detection of a light client attack\n(one of the lightblocks differ from the one in verifiedLS with\nthe same height), we should return evidence")]),e._v(" "),a("li",[e._v("if the secondary cannot provide a verification trace, we have no\nproof for an attack. Block "),a("em",[e._v("b")]),e._v(" may be bogus. In this case the\nsecondary is faulty and it should be replaced.")])]),e._v(" "),a("h2",{attrs:{id:"assumptions-incentives-environment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#assumptions-incentives-environment"}},[e._v("#")]),e._v(" Assumptions/Incentives/Environment")]),e._v(" "),a("p",[e._v("It is not in the interest of faulty full nodes to talk to the\ndetector as long as the  detector is connected to at least one\ncorrect full node. This would only increase the likelihood of\nmisbehavior being detected. Also we cannot punish them easily\n(cheaply). The absence of a response need not be the fault of the full\nnode.")]),e._v(" "),a("p",[e._v("Correct full nodes have the incentive to respond, because the\ndetector may help them to understand whether their header is a good\none. We can thus base liveness arguments of the  detector on\nthe assumptions that correct full nodes reliably talk to the\ndetector.")]),e._v(" "),a("h3",{attrs:{id:"assumptions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#assumptions"}},[e._v("#")]),e._v(" Assumptions")]),e._v(" "),a("h4",{attrs:{id:"lcd-a-corrfull-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-a-corrfull-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-A-CorrFull.1]")])]),e._v(" "),a("p",[e._v("At all times there is at least one correct full\nnode among the primary and the secondaries.")]),e._v(" "),a("blockquote",[a("p",[e._v("For this version of the detection we take this assumption. It\nallows us to establish the invariant that the lightblock\n"),a("code",[e._v("root-of-trust")]),e._v(" is always the one from the blockchain, and we can\nuse it as starting point for the evidence computation. Moreover, it\nallows us to establish the invariant at the supervisor that any\nlightblock in the (top-level) lightstore is from the blockchain."),a("br"),e._v("\nIn the future we might design a lightclient based on the assumption\nthat at least in regular intervals the lightclient is connected to a\ncorrect full node. This will require the detector to reconsider\n"),a("code",[e._v("root-of-trust")]),e._v(", and remove lightblocks from the top-level\nlightstore.")])]),e._v(" "),a("h4",{attrs:{id:"lcd-a-relcomm-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-a-relcomm-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-A-RelComm.1]")])]),e._v(" "),a("p",[e._v("Communication between the  detector and a correct full node is\nreliable and bounded in time. Reliable communication means that\nmessages are not lost, not duplicated, and eventually delivered. There\nis a (known) end-to-end delay "),a("em",[e._v("Delta")]),e._v(", such that if a message is sent\nat time "),a("em",[e._v("t")]),e._v(" then it is received and processed by time "),a("em",[e._v("t + Delta")]),e._v(".\nThis implies that we need a timeout of at least "),a("em",[e._v("2 Delta")]),e._v(" for remote\nprocedure calls to ensure that the response of a correct peer arrives\nbefore the timeout expires.")]),e._v(" "),a("h2",{attrs:{id:"definitions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definitions"}},[e._v("#")]),e._v(" Definitions")]),e._v(" "),a("h3",{attrs:{id:"evidence"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#evidence"}},[e._v("#")]),e._v(" Evidence")]),e._v(" "),a("p",[e._v("Following the definition of\n"),a("a",{attrs:{href:"#TMBC-LC-ATTACK-EVIDENCE1"}},[e._v("[TMBC-LC-ATTACK-EVIDENCE.1]")]),e._v(", by evidence\nwe refer to a variable of the following type")]),e._v(" "),a("h4",{attrs:{id:"lc-data-evidence-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lc-data-evidence-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LC-DATA-EVIDENCE.1]")])]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBMaWdodENsaWVudEF0dGFja0V2aWRlbmNlIHN0cnVjdCB7CiAgICBDb25mbGljdGluZ0Jsb2NrICAgTGlnaHRCbG9jawogICAgQ29tbW9uSGVpZ2h0ICAgICAgIGludDY0Cn0K"}}),e._v(" "),a("p",[e._v("As the above data is computed for a specific peer, the following\ndata structure wraps the evidence and adds the peerID.")]),e._v(" "),a("h4",{attrs:{id:"lc-data-evidence-int-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lc-data-evidence-int-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LC-DATA-EVIDENCE-INT.1]")])]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBJbnRlcm5hbEV2aWRlbmNlIHN0cnVjdCB7CiAgICBFdmlkZW5jZSAgICAgICAgICAgTGlnaHRDbGllbnRBdHRhY2tFdmlkZW5jZQogICAgUGVlciAgICAgICAgICAgICAgIFBlZXJJRAp9Cg=="}}),e._v(" "),a("h4",{attrs:{id:"lc-sumbit-evidence-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lc-sumbit-evidence-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LC-SUMBIT-EVIDENCE.1]")])]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBzdWJtaXRFdmlkZW5jZShFdmlkZW5jZXMgW11JbnRlcm5hbEV2aWRlbmNlKQo="}}),e._v(" "),a("ul",[a("li",[e._v("Expected postcondition\n"),a("ul",[a("li",[e._v("for each "),a("code",[e._v("ev")]),e._v(" in "),a("code",[e._v("Evidences")]),e._v(": submit "),a("code",[e._v("ev.Evidence")]),e._v(" to "),a("code",[e._v("ev.Peer")])])])])]),e._v(" "),a("hr"),e._v(" "),a("h3",{attrs:{id:"lightstore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lightstore"}},[e._v("#")]),e._v(" LightStore")]),e._v(" "),a("p",[e._v("Lightblocks and LightStores are defined in the verification\nspecification [LCV-DATA-LIGHTBLOCK.1] and [LCV-DATA-LIGHTSTORE.1]. See\nthe "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("verification specification"),a("OutboundLink")],1),e._v(" for details.")]),e._v(" "),a("h2",{attrs:{id:"distributed-problem-statement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#distributed-problem-statement"}},[e._v("#")]),e._v(" (Distributed) Problem statement")]),e._v(" "),a("blockquote",[a("p",[e._v("As the attack detector is there to reduce the impact of faulty\nnodes, and faulty nodes imply that there is a distributed system,\nthere is no sequential specification to which this distributed\nproblem statement may refer to.")])]),e._v(" "),a("p",[e._v("The detector gets as input a trusted lightblock called "),a("em",[e._v("root")]),e._v(" and an\nauxiliary lightstore called "),a("em",[e._v("primary_trace")]),e._v(" with lightblocks that have\nbeen verified before, and that were provided by the primary.")]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-inv-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-inv-attack-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-INV-ATTACK.1]")])]),e._v(" "),a("p",[e._v("If the detector returns evidence for height "),a("em",[e._v("h")]),e._v(" "),a("a",{attrs:{href:"#TMBC-LC-EVIDENCE-DATA1"}},[e._v("[TMBC-LC-EVIDENCE-DATA.1]")]),e._v(", then there is an\nattack at height "),a("em",[e._v("h")]),e._v(". "),a("a",{attrs:{href:"#TMBC-LC-ATTACK1"}},[e._v("[TMBC-LC-ATTACK.1]")])]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-inv-store-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-inv-store-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-INV-STORE.1]")])]),e._v(" "),a("p",[e._v("If the detector does not return evidence, then "),a("em",[e._v("primary_trace")]),e._v("\ncontains only blocks from the blockchain.")]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-live-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-live-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-LIVE.1]")])]),e._v(" "),a("p",[e._v("The detector eventually terminates.")]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-term-normal-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-term-normal-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-TERM-NORMAL.1]")])]),e._v(" "),a("p",[e._v("If")]),e._v(" "),a("ul",[a("li",[e._v("the "),a("em",[e._v("primary_trace")]),e._v(" contains only blocks from the blockchain, and")]),e._v(" "),a("li",[e._v("there is no attack, and")]),e._v(" "),a("li",[a("em",[e._v("Secondaries")]),e._v(" is always non-empty, and")]),e._v(" "),a("li",[e._v("the age of "),a("em",[e._v("root")]),e._v(" is always less than the trusting period,")])]),e._v(" "),a("p",[e._v("then the detector does not return evidence.")]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-term-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-term-attack-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-TERM-ATTACK.1]")])]),e._v(" "),a("p",[e._v("If")]),e._v(" "),a("ul",[a("li",[e._v("there is an attack, and")]),e._v(" "),a("li",[e._v("a secondary reports a block that conflicts\nwith one of the blocks in "),a("em",[e._v("primary_trace")]),e._v(", and")]),e._v(" "),a("li",[a("em",[e._v("Secondaries")]),e._v(" is always non-empty, and")]),e._v(" "),a("li",[e._v("the age of "),a("em",[e._v("root")]),e._v(" is always less than the trusting period,")])]),e._v(" "),a("p",[e._v("then the detector returns evidence.")]),e._v(" "),a("blockquote",[a("p",[e._v('Observe that above we require that "a secondary reports a block that\nconflicts". If there is an attack, but no secondary tries to launch\nit against the detector (or the message from the secondary is lost\nby the network), then there is nothing to detect for us.')])]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-safe-secondary-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-safe-secondary-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-SAFE-SECONDARY.1]")])]),e._v(" "),a("p",[e._v("No correct secondary is ever replaced.")]),e._v(" "),a("h4",{attrs:{id:"lcd-dist-safe-bogus-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-dist-safe-bogus-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-DIST-SAFE-BOGUS.1]")])]),e._v(" "),a("p",[e._v("If")]),e._v(" "),a("ul",[a("li",[e._v("a secondary reports a bogus lightblock,")]),e._v(" "),a("li",[e._v("the age of "),a("em",[e._v("root")]),e._v(" is always less than the trusting period,")])]),e._v(" "),a("p",[e._v("then the secondary is replaced before the detector terminates.")]),e._v(" "),a("blockquote",[a("p",[e._v('The above property is quite operational ("reports"), but it captures\nquite closely the requirement. As the\ndetector only makes sense in a distributed setting, and does\nnot have a sequential specification, less "pure"\nspecification are acceptable.')])]),e._v(" "),a("h1",{attrs:{id:"protocol"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#protocol"}},[e._v("#")]),e._v(" Protocol")]),e._v(" "),a("h2",{attrs:{id:"functions-and-data-defined-in-other-specifications"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#functions-and-data-defined-in-other-specifications"}},[e._v("#")]),e._v(" Functions and Data defined in other Specifications")]),e._v(" "),a("h3",{attrs:{id:"from-the-supervisor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#from-the-supervisor"}},[e._v("#")]),e._v(" From the supervisor")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"UmVwbGFjZV9TZWNvbmRhcnkoYWRkciBBZGRyZXNzLCByb290LW9mLXRydXN0IExpZ2h0QmxvY2spCg=="}}),e._v(" "),a("h3",{attrs:{id:"from-the-verifier"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#from-the-verifier"}},[e._v("#")]),e._v(" From the verifier")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBWZXJpZnlUb1RhcmdldChwcmltYXJ5IFBlZXJJRCwgcm9vdCBMaWdodEJsb2NrLAogICAgICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodCBIZWlnaHQpIChMaWdodFN0b3JlLCBSZXN1bHQpCg=="}}),e._v(" "),a("blockquote",[a("p",[e._v("Note: the above differs from the current version in the second\nparameter. verification will be revised.")])]),e._v(" "),a("p",[e._v("Observe that "),a("code",[e._v("VerifyToTarget")]),e._v(" does communication with the secondaries\nvia the function "),a("a",{attrs:{href:"fetch"}},[e._v("FetchLightBlock")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"shared-data-of-the-light-client"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shared-data-of-the-light-client"}},[e._v("#")]),e._v(" Shared data of the light client")]),e._v(" "),a("ul",[a("li",[e._v("a pool of full nodes "),a("em",[e._v("FullNodes")]),e._v(" that have not been contacted before")]),e._v(" "),a("li",[e._v("peer set called "),a("em",[e._v("Secondaries")])]),e._v(" "),a("li",[e._v("primary")])]),e._v(" "),a("blockquote",[a("p",[e._v("Note that the lightStore is not needed to be shared.")])]),e._v(" "),a("h2",{attrs:{id:"outline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#outline"}},[e._v("#")]),e._v(" Outline")]),e._v(" "),a("p",[e._v("The problem laid out is solved by calling the function "),a("code",[e._v("AttackDetector")]),e._v("\nwith a lightstore that contains a light block that has just been\nverified by the verifier.")]),e._v(" "),a("p",[e._v("Then "),a("code",[e._v("AttackDetector")]),e._v(" downloads headers from the secondaries. In case\na conflicting header is downloaded from a secondary,\n"),a("code",[e._v("CreateEvidenceForPeer")]),e._v(" which computes evidence in the case that\nindeed an attack is confirmed. It could be that the secondary reports\na bogus block, which means that there need not be an attack, and the\nsecondary is replaced.")]),e._v(" "),a("h2",{attrs:{id:"details-of-the-functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#details-of-the-functions"}},[e._v("#")]),e._v(" Details of the functions")]),e._v(" "),a("h4",{attrs:{id:"lcd-func-detector-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-func-detector-1"}},[e._v("#")]),e._v(" "),a("strong",[e._v("[LCD-FUNC-DETECTOR.1]:")])]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBBdHRhY2tEZXRlY3Rvcihyb290IExpZ2h0QmxvY2ssIHByaW1hcnlfdHJhY2UgW11MaWdodEJsb2NrKQogICAgICAgICAgICAgICAgICAgKFtdSW50ZXJuYWxFdmlkZW5jZSkgewoKICAgIEV2aWRlbmNlcyA6PSBuZXcgW11JbnRlcm5hbEV2aWRlbmNlOwoKICAgIGZvciBlYWNoIHNlY29uZGFyeSBpbiBTZWNvbmRhcmllcyB7CiAgICAgICAgLy8gd2UgcmVwbGF5IHRoZSBwcmltYXJ5IHRyYWNlIHdpdGggdGhlIHNlY29uZGFyeSwgaW4KICAgICAgICAvLyBvcmRlciB0byBnZW5lcmF0ZSBldmlkZW5jZSB0aGF0IHdlIGNhbiBzdWJtaXQgdG8gdGhlCiAgICAgICAgLy8gc2Vjb2RhcnkuIFdlIHJldHVybiB0aGUgZXZpZGVuY2UgKyB0aGUgdHJhY2UgdGhlCiAgICAgICAgLy8gc2Vjb25kYXJ5IHRvbGQgdXMgdGhhdCBzcGFucyB0aGUgZXZpZGVuY2UgYXQgaXRzIGxvY2FsIHN0b3JlCgogICAgICAgIEV2aWRlbmNlRm9yU2Vjb25kYXJ5LCBuZXdyb290LCBzZWNvbmRhcnlfdHJhY2UsIHJlc3VsdCA6PQogICAgICAgICAgICAgICAgQ3JlYXRlRXZpZGVuY2VGb3JQZWVyKHNlY29uZGFyeSwKICAgICAgICAgICAgICAgICAgICAgICAgICByb290LAogICAgICAgICAgIHByaW1hcnlfdHJhY2UpOwogICAgICAgIGlmIHJlc3VsdCA9PSBGYXVsdHlQZWVyIHsKICAgICAgICAgICAgUmVwbGFjZV9TZWNvbmRhcnkocm9vdCk7CiAgICAgICAgfQogICAgICAgIGVsc2UgaWYgcmVzdWx0ID09IEZvdW5kRXZpZGVuY2UgewogICAgICAgICAgICAvLyB0aGUgY29uZmxpY3QgaXMgbm90IGJvZ3VzCiAgICAgICAgICAgIEV2aWRlbmNlcy5BZGQoRXZpZGVuY2VGb3JTZWNvbmRhcnkpOwogICAgICAgICAgICAvLyB3ZSByZXBsYXkgdGhlIHNlY29uZGFyeSB0cmFjZSB3aXRoIHRoZSBwcmltYXJ5LCAuLi4KICAgICAgICAgICAgRXZpZGVuY2VGb3JQcmltYXJ5LCBfLCByZXN1bHQgOj0KICAgICAgICBDcmVhdGVFdmlkZW5jZUZvclBlZXIocHJpbWFyeSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3cm9vdCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5X3RyYWNlKTsKICAgICAgICAgICAgaWYgcmVzdWx0ID09IEZvdW5kRXZpZGVuY2UgewogICAgICAgICAgICAgICAgRXZpZGVuY2VzLkFkZChFdmlkZW5jZUZvclByaW1hcnkpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgZG8gbm90IGNhcmUgYWJvdXQgdGhlIG90aGVyIGVycm9yCiAgICAgICAgICAgIC8vIGNvZGVzLiBXZSBhbHJlYWR5IGhhdmUgZ2VuZXJhdGVkIGV2aWRlbmNlIGZvciBhbgogICAgICAgICAgICAvLyBhdHRhY2sgYW5kIG5lZWQgdG8gc3RvcCB0aGUgbGlnaHRjbGllbnQuIEl0IGRvZXMgbm90CiAgICAgICAgICAgIC8vIGhlbHAgdG8gY2FsbCByZXBsYWNlX3ByaW1hcnkuIEFsc28gd2Ugd2lsbCB1c2UgdGhlCiAgICAgICAgICAgIC8vIHNhbWUgcHJpbWFyeSB0byBjaGVjayB3aXRoIG90aGVyIHNlY29uZGFyaWVzIGluCiAgICAgICAgICAgIC8vIGxhdGVyIGl0ZXJhdGlvbnMgb2YgdGhlIGxvb3AKICAgICAgICAgfQogICAgICAgICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgc2Vjb25kYXJ5IHJlcG9ydHMgTm9FdmlkZW5jZQogICAgICAgICAvLyB3ZSBkbyBub3RoaW5nCiAgICB9CiAgICByZXR1cm4gRXZpZGVuY2VzOwp9Cg=="}}),e._v(" "),a("ul",[a("li",[e._v("Expected precondition\n"),a("ul",[a("li",[e._v("root and primary trace are a verification trace")])])]),e._v(" "),a("li",[e._v("Expected postcondition\n"),a("ul",[a("li",[e._v("solves the problem statement (if attack found, then evidence is reported)")])])]),e._v(" "),a("li",[e._v("Error condition\n"),a("ul",[a("li",[a("code",[e._v("ErrorTrustExpired")]),e._v(": fails if root expires (outside trusting\nperiod) "),a("a",{attrs:{href:"LCV-INV-TP1-link"}},[e._v("[LCV-INV-TP.1]")])]),e._v(" "),a("li",[a("code",[e._v("ErrorNoPeers")]),e._v(": if no peers are left to replace secondaries, and\nno evidence was found before that happened")])])])]),e._v(" "),a("hr"),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBDcmVhdGVFdmlkZW5jZUZvclBlZXIocGVlciBQZWVySUQsIHJvb3QgTGlnaHRCbG9jaywgdHJhY2UgTGlnaHRTdG9yZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAoRXZpZGVuY2UsIExpZ2h0QmxvY2ssIExpZ2h0U3RvcmUsIHJlc3VsdCkgewoKICAgIGNvbW1vbiA6PSByb290OwoKICAgIGZvciBpIGluIDEgLi4gbGVuKHRyYWNlKSB7CiAgICAgICAgYXV4TFMsIHJlc3VsdCA6PSBWZXJpZnlUb1RhcmdldChwZWVyLCBjb21tb24sIHRyYWNlW2ldLkhlYWRlci5IZWlnaHQpCiAgCiAgICAgICAgaWYgcmVzdWx0ICE9IFJlc3VsdFN1Y2Nlc3MgewogICAgICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZzsgcGVlciBkaWQgbm90IHByb3ZpZGUgYSB2ZXJpZnlhYmxlIGJsb2NrCiAgICAgICAgICAgIHJldHVybiAobmlsLCBuaWwsIG5pbCwgRmF1bHR5UGVlcikKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGlmIGF1eExTLkxhdGVzdFZlcmlmaWVkKCkuSGVhZGVyICE9IHRyYWNlW2ldLkhlYWRlciB7CiAgICAgICAgICAgICAgICAvLyB0aGUgaGVhZGVyIHJlcG9ydGVkIGJ5IHRoZSBwZWVyIGRpZmZlcnMgZnJvbSB0aGUKICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZSBoZWFkZXIgaW4gdHJhY2UgYnV0IGJvdGggY291bGQgYmUKICAgICAgICAgICAgICAgIC8vIHZlcmlmaWVkIGZyb20gY29tbW9uIGluIG9uZSBzdGVwLgogICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNyZWF0ZSBldmlkZW5jZSBmb3Igc3VibWlzc2lvbiB0byB0aGUgc2Vjb25kYXJ5CiAgICAgICAgICAgICAgICBldiA6PSBuZXcgSW50ZXJuYWxFdmlkZW5jZTsKICAgICAgICAgICAgICAgIGV2LkV2aWRlbmNlLkNvbmZsaWN0aW5nQmxvY2sgOj0gdHJhY2VbaV07CiAgICAgICAgICAgICAgICBldi5FdmlkZW5jZS5Db21tb25IZWlnaHQgOj0gY29tbW9uLkhlaWdodDsKICAgICAgICAgICAgICAgIGV2LlBlZXIgOj0gcGVlcgogICAgICAgICAgICAgICAgcmV0dXJuIChldiwgY29tbW9uLCBhdXhMUywgRm91bmRFdmlkZW5jZSkKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIC8vIHRoZSBwZWVyIGFncmVlcyB3aXRoIHRoZSB0cmFjZSwgd2UgbW92ZSBjb21tb24gZm9yd2FyZAogICAgICAgICAgICAgICAgLy8gd2UgY291bGQgZGVsZXRlIGF1eExTIGFzIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gaW4KICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IGl0ZXJhdGlvbgogICAgICAgICAgICAgICAgY29tbW9uIDo9IHRyYWNlW2ldCiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CiAgICByZXR1cm4gKG5pbCwgbmlsLCBuaWwsIE5vRXZpZGVuY2UpCn0K"}}),e._v(" "),a("ul",[a("li",[e._v("Expected precondition\n"),a("ul",[a("li",[e._v("root and trace are a verification trace")])])]),e._v(" "),a("li",[e._v("Expected postcondition\n"),a("ul",[a("li",[e._v("finds evidence where trace and peer diverge")])])]),e._v(" "),a("li",[e._v("Error condition\n"),a("ul",[a("li",[a("code",[e._v("ErrorTrustExpired")]),e._v(": fails if root expires (outside trusting\nperiod) "),a("a",{attrs:{href:"LCV-INV-TP1-link"}},[e._v("[LCV-INV-TP.1]")])]),e._v(" "),a("li",[e._v("If "),a("code",[e._v("VerifyToTarget")]),e._v(" returns error but root is not expired then return\n"),a("code",[e._v("FaultyPeer")])])])])]),e._v(" "),a("hr"),e._v(" "),a("h2",{attrs:{id:"correctness-arguments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#correctness-arguments"}},[e._v("#")]),e._v(" Correctness arguments")]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-inv-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-inv-attack-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-INV-ATTACK1"}},[e._v("[LCD-DIST-INV-ATTACK.1]")])]),e._v(" "),a("p",[e._v("Under the assumption that root and trace are a verification trace,\nwhen in "),a("code",[e._v("CreateEvidenceForPeer")]),e._v(" the detector the detector creates\nevidence, then the lightclient has seen two different headers (one via\n"),a("code",[e._v("trace")]),e._v(" and one via "),a("code",[e._v("VerifyToTarget")]),e._v(" for the same height that can both\nbe verified in one step.")]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-inv-store-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-inv-store-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-INV-STORE1"}},[e._v("[LCD-DIST-INV-STORE.1]")])]),e._v(" "),a("p",[e._v("We assume that there is at least one correct peer, and there is no\nfork. As a result the correct peer has the correct sequence of\nblocks. Since the primary_trace is checked block-by-block also against\neach secondary, and at no point evidence was generated that means at\nno point there were conflicting blocks.")]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-live-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-live-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-LIVE1"}},[e._v("[LCD-DIST-LIVE.1]")])]),e._v(" "),a("p",[e._v("At the latest when "),a("a",{attrs:{href:"LCV-INV-TP1-link"}},[e._v("[LCV-INV-TP.1]")]),e._v(" is violated,\n"),a("code",[e._v("AttackDetector")]),e._v(" terminates.")]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-term-normal-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-term-normal-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-TERM-NORMAL1"}},[e._v("[LCD-DIST-TERM-NORMAL.1]")])]),e._v(" "),a("p",[e._v("As there are finitely many peers, eventually the main loop\nterminates. As there is no attack no evidence can be generated.")]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-term-attack-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-term-attack-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-TERM-ATTACK1"}},[e._v("[LCD-DIST-TERM-ATTACK.1]")])]),e._v(" "),a("p",[e._v("Argument similar to  "),a("a",{attrs:{href:"#LCD-DIST-TERM-NORMAL1"}},[e._v("[LCD-DIST-TERM-NORMAL.1]")])]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-safe-secondary-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-safe-secondary-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-SAFE-SECONDARY1"}},[e._v("[LCD-DIST-SAFE-SECONDARY.1]")])]),e._v(" "),a("p",[e._v("Secondaries are only replaced if they time-out or if they report bogus\nblocks. The former is ruled out by the timing assumption, the latter\nby correct peers only reporting blocks from the chain.")]),e._v(" "),a("h4",{attrs:{id:"argument-for-lcd-dist-safe-bogus-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#argument-for-lcd-dist-safe-bogus-1"}},[e._v("#")]),e._v(" Argument for "),a("a",{attrs:{href:"#LCD-DIST-SAFE-BOGUS1"}},[e._v("[LCD-DIST-SAFE-BOGUS.1]")])]),e._v(" "),a("p",[e._v("Once a bogus block is recognized as such the secondary is removed.")]),e._v(" "),a("h1",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("blockquote",[a("p",[e._v("links to other specifications/ADRs this document refers to")])]),e._v(" "),a("p",[e._v("["),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/verification/verification.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("verification"),a("OutboundLink")],1),e._v("] The specification of the light client verification.")]),e._v(" "),a("p",[e._v("["),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/rust-spec/lightclient/supervisor/supervisor.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("supervisor"),a("OutboundLink")],1),e._v("] The specification of the light client supervisor.")])],1)}),[],!1,null,null,null);t.default=n.exports}}]);