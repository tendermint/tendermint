(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{742:function(e,t,n){"use strict";n.r(t);var o=n(1),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"rfc-019-configuration-file-versioning"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rfc-019-configuration-file-versioning"}},[e._v("#")]),e._v(" RFC 019: Configuration File Versioning")]),e._v(" "),n("h2",{attrs:{id:"changelog"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#changelog"}},[e._v("#")]),e._v(" Changelog")]),e._v(" "),n("ul",[n("li",[e._v("19-Apr-2022: Initial draft (@creachadair)")]),e._v(" "),n("li",[e._v("20-Apr-2022: Updates from review feedback (@creachadair)")])]),e._v(" "),n("h2",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("Updating configuration settings is an essential part of upgrading an existing\nnode to a new version of the Tendermint software.  Unfortunately, it is also\ncurrently a very manual process. This document discusses some of the history of\nchanges to the config format, actions we've taken to improve the tooling for\nconfiguration upgrades, and additional steps we may want to consider.")]),e._v(" "),n("h2",{attrs:{id:"background"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),n("p",[e._v("A Tendermint node reads configuration settings at startup from a TOML formatted\ntext file, typically named "),n("code",[e._v("config.toml")]),e._v(". The contents of this file are defined\nby the "),n("a",{attrs:{href:"https://godoc.org/github.com/tendermint/tendermint/config",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("github.com/tendermint/tendermint/config")]),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("p",[e._v("Although many settings in this file remain valid from one version of Tendermint\nto the next, new versions of Tendermint often add, update, and remove settings.\nThese changes often require manual intervention by operators who are upgrading\ntheir nodes.")]),e._v(" "),n("p",[e._v("I propose we should provide better tools and documentation to help operators\nmake configuration changes correctly during version upgrades.  Ideally, as much\nas possible of any configuration file update should be automated, and where\nthat is not possible or practical, we should provide clear, explicit directions\nfor what steps need to be taken manually. Moreover, when the node discovers\nincorrect or invalid configuration, we should improve the diagnostics it emits\nso that the operator can quickly and easily find the relevant documentation,\nwithout having to grep through source code.")]),e._v(" "),n("h2",{attrs:{id:"discussion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#discussion"}},[e._v("#")]),e._v(" Discussion")]),e._v(" "),n("p",[e._v("By convention, we are supposed to document required changes to the config file\nin the "),n("code",[e._v("UPGRADING.md")]),e._v(" file for the release that introduces them.  Although we\nhave mostly done this, the level of detail in the upgrading instructions is\noften insufficient for an operator to correctly update their file.")]),e._v(" "),n("p",[e._v("The updates vary widely in complexity: Operators may need to add new required\nsettings, update obsolete values for existing settings, move or rename existing\nsettings within the file, or remove obsolete settings (which are thus invalid).\nHere are a few examples of each of these cases:")]),e._v(" "),n("ul",[n("li",[n("p",[n("strong",[e._v("New required settings:")]),e._v(" Tendermint v0.35 added a new top-level "),n("code",[e._v("mode")]),e._v("\nsetting that determines whether a node runs as a validator, a full node, or a\nseed node.  The default value is "),n("code",[e._v('"full"')]),e._v(", which means the operator of a\nvalidator must manually add "),n("code",[e._v('mode = "validator"')]),e._v(" (or set the "),n("code",[e._v("--mode")]),e._v(" flag on\nthe command line) for their node to come up in the correct mode.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Updated obsolete values:")]),e._v(" Tendermint v0.35 removed support for versions\n"),n("code",[e._v('"v1"')]),e._v(" and "),n("code",[e._v('"v2"')]),e._v(' of the blocksync (formerly "fastsync") protocol, requiring\nany node using either of those values to update to '),n("code",[e._v('"v0"')]),e._v(".")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Moved/renamed settings:")]),e._v(" Version v0.34 moved the top-level "),n("code",[e._v("pprof_laddr")]),e._v("\nsetting under the "),n("code",[e._v("[rpc]")]),e._v(" section.")]),e._v(" "),n("p",[e._v("Version v0.35 renamed every setting in the file from "),n("code",[e._v("snake_case")]),e._v(" to\n"),n("code",[e._v("kebab-case")]),e._v(", moved the top-level "),n("code",[e._v("fast_sync")]),e._v(" setting into the "),n("code",[e._v("[blocksync]")]),e._v("\nsection as (itself renamed from "),n("code",[e._v("[fastsync]")]),e._v("), and moved all the top-level\n"),n("code",[e._v("priv-validator-*")]),e._v(" settings under a new "),n("code",[e._v("[priv-validator]")]),e._v(" section with their\nprefix trimmed off.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Removed obsolete settings:")]),e._v(" Version v0.34 removed the "),n("code",[e._v("index_all_keys")]),e._v(" and\n"),n("code",[e._v("index_keys")]),e._v(" settings from the "),n("code",[e._v("[tx_index]")]),e._v(" section; version v0.35 removed\nthe "),n("code",[e._v("wal-dir")]),e._v(" setting from the "),n("code",[e._v("[mempool]")]),e._v(" section, and version v0.36 removed\nthe "),n("code",[e._v("[blocksync]")]),e._v(" section entirely.")])])]),e._v(" "),n("p",[e._v("While many of these changes are mentioned in the config section of the upgrade\ninstructions, some are not mentioned at all, or are hidden in other parts of\nthe doc. For instance, the v0.34 "),n("code",[e._v("pprof_laddr")]),e._v(" change was documented only as an\nRPC flag change. (A savvy reader might realize that the flag "),n("code",[e._v("--rpc.pprof_laddr")]),e._v("\nimplies a corresponding config section, but it omits the related detail that\nthere was a top-level setting that's been renamed).  The lesson here is not\nthat the docs are bad, but to point out that prose is not the most efficient\nformat to convey detailed changes like this. The upgrading instructions are\nstill valuable for the human reader to understand what to expect.")]),e._v(" "),n("h3",{attrs:{id:"concrete-steps"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#concrete-steps"}},[e._v("#")]),e._v(" Concrete Steps")]),e._v(" "),n("p",[e._v("As part of the v0.36 development cycle, we spent some time reverse-engineering\nthe configuration changes since the v0.34 release and built an experimental\ncommand-line tool called "),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/scripts/confix",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("confix")]),n("OutboundLink")],1),e._v(", whose job it is to automatically\nupdate the settings in a "),n("code",[e._v("config.toml")]),e._v(" file to the latest version.  We also\nbackported a version of this tool into the v0.35.x branch at release v0.35.4.")]),e._v(" "),n("p",[e._v("This tool should work fine for configuration files created by Tendermint v0.34\nand later, but does not (yet) know how to handle changes from prior versions of\nTendermint. Part of the difficulty for older versions is simply logistical: To\nfigure out which changes to apply, we need to understand something about the\nversion that made the file, as well as the version we're converting it to.")]),e._v(" "),n("blockquote",[n("p",[n("strong",[e._v("Discussion point:")]),e._v(" In the future we might want to consider incorporating\nthis into the node CLI directly, but we're keeping it separate for now until\nwe can get some feedback from operators.")])]),e._v(" "),n("p",[e._v("For the experiment, we handled this by carefully searching the history of\nconfig format changes for shibboleths to bound the version: For example, the\n"),n("code",[e._v("[fastsync]")]),e._v(" section was added in Tendermint v0.32 and renamed "),n("code",[e._v("[blocksync]")]),e._v(" in\nTendermint v0.35. So if we see a "),n("code",[e._v("[fastsync]")]),e._v(" section, we have some confidence\nthat the file was created by v0.32, v0.33, or v0.34.")]),e._v(" "),n("p",[e._v("But such signals are delicate: The "),n("code",[e._v("[blocksync]")]),e._v(" section was removed in v0.36,\nso if we do not find "),n("code",[e._v("[fastsync]")]),e._v(', we cannot conclude from that alone that the\nfile is from v0.31 or earlier -- we have to look for corroborating details.\nWhile such "sniffing" tactics are fine for an experiment, they aren\'t as robust\nas we might like.')]),e._v(" "),n("p",[e._v("This is especially relevant for configuration files that may have already been\nmanually upgraded across several versions by the time we are asked to update\nthem again.  Another related concern is that we'd like to make sure conversion\nis idempotent, so that it would be safe to rerun the tool over an\nalready-converted file without breaking anything.")]),e._v(" "),n("h3",{attrs:{id:"config-versioning"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#config-versioning"}},[e._v("#")]),e._v(" Config Versioning")]),e._v(" "),n("p",[e._v("One obvious tactic we could use for future releases is add a version marker to\nthe config file. This would give tools like "),n("code",[e._v("confix")]),e._v(" (and the node itself) a\nway to calibrate their expectations. Rather than being a version for the file\nitself, however, this version marker would indicate which version of Tendermint\nis needed to read the file.")]),e._v(" "),n("p",[e._v("Provisionally, this might look something like:")]),e._v(" "),n("tm-code-block",{staticClass:"codeblock",attrs:{language:"toml",base64:"IyBUSGUgbWluaW11bSB2ZXJzaW9uIG9mIFRlbmRlcm1pbnQgY29tcGF0aWJsZSB3aXRoIHRoZSBjb250ZW50cyBvZgojIHRoaXMgY29uZmlndXJhdGlvbiBmaWxlLgpjb25maWctdmVyc2lvbiA9ICd2MC4zNScK"}}),e._v(" "),n("p",[e._v("When initializing a new node, Tendermint would populate this field with its own\nversion (e.g., "),n("code",[e._v("v0.36")]),e._v("). When conducting an upgrade, tools like "),n("code",[e._v("confix")]),e._v(" can\nthen use this to decide which conversions are valid, and then update the value\naccordingly. After converting a file marked "),n("code",[e._v("'v0.35'")]),e._v(" to"),n("code",[e._v("'v0.37'")]),e._v(", the\nconversion tool sets the file's "),n("code",[e._v("config-version")]),e._v(" to reflect its compatibility.")]),e._v(" "),n("blockquote",[n("p",[n("strong",[e._v("Discussion point:")]),e._v(" This example presumes we would keep config files\ncompatible within a given release cycle, e.g., all of v0.36.x. We could also\nuse patch numbers here, if we think there's some reason to permit changes\nthat would require config file edits at that granularity. I don't think we\nshould, but that's a design question to consider.")])]),e._v(" "),n("p",[e._v('Upon seeing an up-to-date version marker, the conversion tool can simply exit\nwith a diagnostic like "this file is already up-to-date", rather than sniffing\nthe keyspace and potentially introducing errors. In addition, this would let a\ntool detect config files that are '),n("em",[e._v("newer")]),e._v(" than the one it understands, and\nissue a safe diagnostic rather than doing something wrong.  Plus, besides\navoiding potentially unsafe conversions, this would also serve as\nhuman-readable documentation that the file is up-to-date for a given version.")]),e._v(" "),n("p",[e._v("Adding a config version would not address the problem of how to convert files\ncreated by older versions of Tendermint, but it would at least help us build\nmore robust config tooling going forward.")]),e._v(" "),n("h3",{attrs:{id:"stability-and-change"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#stability-and-change"}},[e._v("#")]),e._v(" Stability and Change")]),e._v(" "),n("p",[e._v("In light of the discussion so far, it is natural to examine why we make so many\nchanges to the configuration file from one version to the next, and whether we\ncould reduce friction by being more conservative about what we make\nconfigurable, what config changes we make over time, and how we roll them out.")]),e._v(" "),n("p",[e._v("Some changes, like renaming everything from snake case to kebab case, are\nentirely gratuitous. We could safely agree not to make those kinds of changes.\nApart from that obvious case, however, many other configuration settings\nprovide value to node operators in cases where there is no simple, universal\nsetting that matches every application.")]),e._v(" "),n("p",[e._v("Taking a high-level view, there are several broad reasons why we might want to\nmake changes to configuration settings:")]),e._v(" "),n("ul",[n("li",[n("p",[n("strong",[e._v("Lessons learned:")]),e._v(" Configuration settings are a good way to try things out\nin production, before making more invasive changes to the consensus protocol.")]),e._v(" "),n("p",[e._v("For example, up until Tendermint v0.35, consensus timeouts were specified as\nper-node configuration settings (e.g., "),n("code",[e._v("timeout-precommit")]),e._v(" et al.).  This\nallowed operators to tune these values for the needs of their network, but\nhad the downside that individually-misconfigured nodes could stall consensus.")]),e._v(" "),n("p",[e._v("Based on that experience, these timeouts have been deprecated in Tendermint\nv0.36 and converted to consensus parameters, to be consistent across all\nnodes in the network.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Migration & experimentation:")]),e._v(' Introducing new features and updating old\nfeatures can complicate migration for existing users of the software.\nTemporary or "experimental" configuration settings can be a valuable way to\nmitigate that friction.')]),e._v(" "),n("p",[e._v("For example, Tendermint v0.36 introduces a new RPC event subscription\nendpoint (see "),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-075-rpc-subscription.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ADR 075"),n("OutboundLink")],1),e._v(") that will eventually replace the existing\nwebwocket-based interface. To give users time to migrate, v0.36 adds an\n"),n("code",[e._v("experimental-disable-websocket")]),e._v(" setting, defaulted to "),n("code",[e._v("false")]),e._v(", that allows\noperators to selectively disable the websocket API for testing purposes\nduring the conversion. This setting is designed to be removed in v0.37, when\nthe old interface is no longer supported.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Ongoing maintenance:")]),e._v(" Sometimes configuration settings become obsolete,\nand the cost of removing them trades off against the potential risks of\nleaving a non-functional or deprecated knob hooked up indefinitely.")]),e._v(" "),n("p",[e._v("For example, Tendermint v0.35 deprecated two alternate implementations of the\nblocksync protocol, one of which was deleted entirely ("),n("code",[e._v("v1")]),e._v(") and one of which\nwas scheduled for removal ("),n("code",[e._v("v2")]),e._v("). The "),n("code",[e._v("blocksync.version")]),e._v(" setting, which had\nbeen added as a migration aid, became obsolete and needed to be updated.")]),e._v(" "),n("p",[e._v("Despite our best intentions, sometimes engineering designs do not work out.\nIt's just as important to leave room to back out of changes we have since\nreconsidered, as it is to support migrations forward onto new and improved\ncode.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Clarity and legibility:")]),e._v(" Besides configuring the software, another\nimportant purpose of a config file is to document intent for the humans who\noperate and maintain the software. Operators need adjust settings to keep the\nnode running, and developers need to know what options were in use when\nsomething goes wrong so they can diagnose and fix bugs.  The legibility of a\nconfig file as a "),n("em",[e._v("human")]),e._v(" artifact is also thus important.")]),e._v(" "),n("p",[e._v("For example, Tendermint v0.35 moved settings related to validator private\nkeys from the top-level section of the configuration file to their own\ndesignated "),n("code",[e._v("[priv-validator]")]),e._v(" section. Although this change did not make any\ndifference to the meaning of those settings, it made the organization of the\nfile easier to understand, and allowed the names of the individual settings\nto be simplified (e.g., "),n("code",[e._v("priv-validator-key-file")]),e._v(" became simply "),n("code",[e._v("key-file")]),e._v(" in\nthe new section).")]),e._v(" "),n("p",[e._v('Although such changes are "gratuitous" with respect to the software, there is\noften value in making things more legible for the humans. While there is no\nsimple rule to define the line, the Potter Stewart principle can be used with\ndue care.')])])]),e._v(" "),n("p",[e._v("Keeping these examples in mind, we can and should take reasonable steps to\navoid churn in the configuration file across versions where we can. However, we\nmust also accept that part of the reason for "),n("em",[e._v("having")]),e._v(" a config file is to allow\nus flexibility elsewhere in the design.  On that basis, we should not attempt\nto be too dogmatic about config changes either. Unlike changes in the block\nprotocol, for example, which affect every user of every network that adopts\nthem, config changes are relatively self-contained.")]),e._v(" "),n("p",[e._v("There are few guiding principles I think we can use to strike a sensible\nbalance:")]),e._v(" "),n("ol",[n("li",[n("p",[n("strong",[e._v("No gratuitous changes.")]),e._v(" Aesthetic changes that do not enhance legibility,\navert confusion, or clarity documentation, should be entirely avoided.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Prefer mechanical changes.")]),e._v(" Whenever it is practical, change settings in\na way that can be updated by a tool without operator judgement. This implies\nfinding safe, universal defaults for new settings, and not changing the\ndefault values of existing settings.")]),e._v(" "),n("p",[e._v("Even if that means we have to make multiple changes (e.g., add a new setting\nin the current version, deprecate the old one, and remove the old one in the\nnext version) it's preferable if we can mechanize each step.")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Clearly signal intent.")]),e._v(" When adding temporary or experimental settings,\nthey should be clearly named and documented as such. Use long names and\nsuggestive prefixes (e.g., "),n("code",[e._v("experimental-*")]),e._v(") so that they stand out when\nread in the config file or printed in logs.")]),e._v(" "),n("p",[e._v("Relatedly, using temporary or experimental settings should cause the\nsoftware to emit diagnostic logs at runtime. These log messages should be\neasy to grep for, and should contain pointers to more complete documentation\n(say, issue numbers or URLs) that the operator can read, as well as a hint\nabout when the setting is expected to become invalid. For example:")]),e._v(" "),n("tm-code-block",{staticClass:"codeblock",attrs:{language:"",base64:"V0FSTklORzogV2Vic29ja2V0IFJQQyBhY2Nlc3MgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluClRlbmRlcm1pbnQgdjAuMzcuIFNlZSBodHRwczovL3Rpbnl1cmwuY29tL2FkcjA3NSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4K"}})],1),e._v(" "),n("li",[n("p",[n("strong",[e._v("Consider both directions.")]),e._v(" When adding a configuration setting, take some\ntime during the implementation process to think about how the setting could\nbe removed, as well as how it will be rolled out. This applies even for\nsettings we imagine should be permanent. Experience may cause is to rethink\nour original design intent more broadly than we expected.")]),e._v(" "),n("p",[e._v("This does not mean we have to spend a long time picking nits over the design\nof every setting; merely that we should convince ourselves we "),n("em",[e._v("could")]),e._v(" undo\nit without making too big a mess later. Even a little extra effort up front\ncan sometimes save a lot.")])])]),e._v(" "),n("h2",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://godoc.org/github.com/tendermint/tendermint/config",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tendermint "),n("code",[e._v("config")]),e._v(" package"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/scripts/confix",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("confix")]),e._v(" command-line tool"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/scripts/confix/condiff",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("condiff")]),e._v(" command-line tool"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/scripts/confix/plan.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("Configuration update plan"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-075-rpc-subscription.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ADR 075: RPC Event Subscription Interface"),n("OutboundLink")],1)])]),e._v(" "),n("h2",{attrs:{id:"appendix-research-notes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#appendix-research-notes"}},[e._v("#")]),e._v(" Appendix: Research Notes")]),e._v(" "),n("p",[e._v("Discovering when various configuration settings were added, updated, and\nremoved turns out to be surprisingly tedious.  To solve this puzzle, we had to\nanswer the following questions:")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("What changes were made between v0.x and v0.y? This is further complicated by\ncases where we have backported config changes into the middle of an earlier\nrelease cycle (e.g., "),n("code",[e._v("psql-conn")]),e._v(" from v0.35.x into v0.34.13).")])]),e._v(" "),n("li",[n("p",[e._v("When during the development cycle were those changes made? This allows us to\nrecognize features that were backported into a previous release.")])]),e._v(" "),n("li",[n("p",[e._v("What were the default values of the changed settings, and did they change at\nall during or across the release boundary?")])])]),e._v(" "),n("p",[e._v("Each step of the "),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/scripts/confix/plan.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("configuration update plan"),n("OutboundLink")],1),e._v(" is commented with a link to\none or more PRs where that change was made. The sections below discuss how we\nfound these references.")]),e._v(" "),n("h3",{attrs:{id:"tracking-changes-across-releases"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tracking-changes-across-releases"}},[e._v("#")]),e._v(" Tracking Changes Across Releases")]),e._v(" "),n("p",[e._v("To figure out what changed between two releases, we built a tool called\n"),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/scripts/confix/condiff",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("condiff")]),n("OutboundLink")],1),e._v(', which performs a "keyspace" diff of two TOML documents.\nThis diff respects the structure of the TOML file, but ignores comments, blank\nlines, and configuration values, so that we can see what was added and removed.')]),e._v(" "),n("p",[e._v("To use it, run:")]),e._v(" "),n("tm-code-block",{staticClass:"codeblock",attrs:{language:"shell",base64:"Z28gcnVuIC4vc2NyaXB0cy9jb25maXgvY29uZGlmZiBvbGQudG9tbCBuZXcudG9tbAo="}}),e._v(" "),n("p",[e._v("This tool works on any TOML documents, but for our purposes we needed\nTendermint "),n("code",[e._v("config.toml")]),e._v(" files. The easiest way to get these is to build the\nnode binary for your version of interest, run "),n("code",[e._v("tendermint init")]),e._v(" on a clean home\ndirectory, and copy the generated config file out. The "),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/scripts/confix/testdata",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("testdata")]),n("OutboundLink")],1),e._v("\ndirectory for the "),n("code",[e._v("confix")]),e._v(" tool has configs generated from the heads of each\nrelease branch from v0.31 through v0.35.")]),e._v(" "),n("p",[e._v("If you want to reproduce this yourself, it looks something like this:")]),e._v(" "),n("tm-code-block",{staticClass:"codeblock",attrs:{language:"shell",base64:"IyBFeGFtcGxlIGZvciBUZW5kZXJtaW50IHYwLjMyLgpnaXQgY2hlY2tvdXQgLS10cmFjayBvcmlnaW4vdjAuMzIueApnbyBnZXQgZ29sYW5nLm9yZy94L3N5cy91bml4CmdvIG1vZCB0aWR5Cm1ha2UgYnVpbGQKcm0gLWZyIC0tIHRtaG9tZQouL2J1aWxkL3RlbmRlcm1pbnQgLS1ob21lPXRtaG9tZSBpbml0CmNwIHRtaG9tZS9jb25maWcvY29uZmlnLnRvbWwgY29uZmlnLXYzMi50b21sCg=="}}),e._v(" "),n("p",[e._v("Be advised that the further back you go, the more idiosyncrasies you will\nencounter. For example, Tendermint v0.31 and earlier predate Go modules (v0.31\nused dep), and lack backport branches. And you may need to do some editing of\nMakefile rules once you get back into the 20s.")]),e._v(" "),n("p",[e._v("Note that when diffing config files across the v0.34/v0.35 gap, the swap from\n"),n("code",[e._v("snake_case")]),e._v(" to "),n("code",[e._v("kebab-case")]),e._v(" makes it look like everything changed. The\n"),n("code",[e._v("condiff")]),e._v(" tool has a "),n("code",[e._v("-desnake")]),e._v(" flag that normalizes all the keys to kebab case\nin both inputs before comparison.")]),e._v(" "),n("h3",{attrs:{id:"locating-additions-and-deletions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#locating-additions-and-deletions"}},[e._v("#")]),e._v(" Locating Additions and Deletions")]),e._v(" "),n("p",[e._v("To figure out when a configuration setting was added or removed, your tool of\nchoice is "),n("code",[e._v("git bisect")]),e._v(". The only tricky part is finding the endpoints for the\nsearch.  If the transition happened within a release, you can use that\nrelease's backport branch as the endpoint (if it has one, e.g., "),n("code",[e._v("v0.35.x")]),e._v(").")]),e._v(" "),n("p",[e._v("However, the start point can be more problematic. The backport branches are not\nancestors of "),n("code",[e._v("master")]),e._v(" or of each other, which means you need to find some point\nin history "),n("em",[e._v("prior")]),e._v(" to the change but still attached to the mainline. For recent\nreleases there is a dev root (e.g., "),n("code",[e._v("v0.35.0-dev")]),e._v(", "),n("code",[e._v("v0.34.0-dev1")]),e._v(", etc.). These\nare not named consistently, but you can usually grep the output of "),n("code",[e._v("git tag")]),e._v(" to\nfind them.")]),e._v(" "),n("p",[e._v("In the worst case you could try starting from the root commit of the repo, but\nthat turns out not to work in all cases. We've done some branching shenanigans\nover the years that mean the root is not a direct ancestor of all our release\nbranches. When you find this you will probably swear a lot. I did.")]),e._v(" "),n("p",[e._v("Once you have a start and end point (say, "),n("code",[e._v("v0.35.0-dev")]),e._v(" and "),n("code",[e._v("master")]),e._v("), you can\nbisect in the usual way. I use "),n("code",[e._v("git grep")]),e._v(" on the "),n("code",[e._v("config")]),e._v(" directory to check\nwhether the case I am looking for is present. For example, to find when the\n"),n("code",[e._v("[fastsync]")]),e._v(" section was removed:")]),e._v(" "),n("tm-code-block",{staticClass:"codeblock",attrs:{language:"shell",base64:"IyBTZXR1cDoKZ2l0IGNoZWNrb3V0IG1hc3RlcgpnaXQgYmlzZWN0IHN0YXJ0CmdpdCBiaXNlY3QgYmFkICAgICAgICAgICAgICAgICAjIGl0J3Mgbm90IHByZXNlbnQgb24gdGlwIG9mIG1hc3Rlci4KZ2l0IGJpc2VjdCBnb29kIHYwLjM0LjAtZGV2MSAgICMgaXQgd2FzIHByZXNlbnQgYXQgdGhlIHN0YXJ0IG9mIHYwLjM0Lgo="}}),e._v(" "),n("tm-code-block",{staticClass:"codeblock",attrs:{language:"shell",base64:"IyBOb3cgcmVwZWF0IHRoaXMgdW50aWwgaXQgZ2l2ZXMgeW91IGEgc3BlY2lmaWMgY29tbWl0OgppZiBnaXQgZ3JlcCAtcSAnXFtmYXN0c3luY1xdJyBjb25maWcgOyB0aGVuIGdpdCBiaXNlY3QgZ29vZCA7IGVsc2UgZ2l0IGJpc2VjdCBiYWQgOyBmaQo="}}),e._v(" "),n("p",[e._v("The above example finds where a config was removed: To find where a setting was\nadded, do the same thing except reverse the sense of the test ("),n("code",[e._v("if ! git grep -q ...")]),e._v(").")])],1)}),[],!1,null,null,null);t.default=a.exports}}]);