(window.webpackJsonp=window.webpackJsonp||[]).push([[226],{802:function(e,t,g){"use strict";g.r(t);var d=g(1),i=Object(d.a)({},(function(){var e=this,t=e.$createElement,g=e._self._c||t;return g("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[g("h1",{attrs:{id:"core-verification"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#core-verification"}},[e._v("#")]),e._v(" Core Verification")]),e._v(" "),g("h2",{attrs:{id:"problem-statement"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#problem-statement"}},[e._v("#")]),e._v(" Problem statement")]),e._v(" "),g("p",[e._v("We assume that the light client knows a (base) header "),g("code",[e._v("inithead")]),e._v(" it trusts (by social consensus or because\nthe light client has decided to trust the header before). The goal is to check whether another header\n"),g("code",[e._v("newhead")]),e._v(" can be trusted based on the data in "),g("code",[e._v("inithead")]),e._v(".")]),e._v(" "),g("p",[e._v("The correctness of the protocol is based on the assumption that "),g("code",[e._v("inithead")]),e._v(" was generated by an instance of\nTendermint consensus.")]),e._v(" "),g("h3",{attrs:{id:"failure-model"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#failure-model"}},[e._v("#")]),e._v(" Failure Model")]),e._v(" "),g("p",[e._v("For the purpose of the following definitions we assume that there exists a function\n"),g("code",[e._v("validators")]),e._v(" that returns the corresponding validator set for the given hash.")]),e._v(" "),g("p",[e._v("The light client protocol is defined with respect to the following failure model:")]),e._v(" "),g("p",[e._v("Given a known bound "),g("code",[e._v("TRUSTED_PERIOD")]),e._v(", and a block "),g("code",[e._v("b")]),e._v(" with header "),g("code",[e._v("h")]),e._v(" generated at time "),g("code",[e._v("Time")]),e._v("\n(i.e. "),g("code",[e._v("h.Time = Time")]),e._v("), a set of validators that hold more than 2/3 of the voting power\nin "),g("code",[e._v("validators(b.Header.NextValidatorsHash)")]),e._v(" is correct until time "),g("code",[e._v("b.Header.Time + TRUSTED_PERIOD")]),e._v(".")]),e._v(" "),g("p",[g("em",[e._v("Assumption")]),e._v(': "correct" is defined w.r.t. realtime (some Newtonian global notion of time, i.e., wall time),\nwhile '),g("code",[e._v("Header.Time")]),e._v(" corresponds to the "),g("RouterLink",{attrs:{to:"/spec/consensus/bft-time.html"}},[e._v("BFT time")]),e._v(". In this note, we assume that clocks of correct processes\nare synchronized (for example using NTP), and therefore there is bounded clock drift ("),g("code",[e._v("CLOCK_DRIFT")]),e._v(") between local clocks and\nBFT time. More precisely, for every correct light client process and every "),g("code",[e._v("header.Time")]),e._v(" (i.e. BFT Time, for a header correctly\ngenerated by the Tendermint consensus), the following inequality holds: "),g("code",[e._v("Header.Time < now + CLOCK_DRIFT")]),e._v(",\nwhere "),g("code",[e._v("now")]),e._v(" corresponds to the system clock at the light client process.")],1),e._v(" "),g("p",[e._v("Furthermore, we assume that "),g("code",[e._v("TRUSTED_PERIOD")]),e._v(" is (several) order of magnitude bigger than "),g("code",[e._v("CLOCK_DRIFT")]),e._v(" ("),g("code",[e._v("TRUSTED_PERIOD >> CLOCK_DRIFT")]),e._v("),\nas "),g("code",[e._v("CLOCK_DRIFT")]),e._v(" (using NTP) is in the order of milliseconds and "),g("code",[e._v("TRUSTED_PERIOD")]),e._v(" is in the order of weeks.")]),e._v(" "),g("p",[e._v("We expect a light client process defined in this document to be used in the context in which there is some\nlarger period during which misbehaving validators can be detected and punished (we normally refer to it as "),g("code",[e._v("UNBONDING_PERIOD")]),e._v('\ndue to the "bonding" mechanism in modern proof of stake systems). Furthermore, we assume that\n'),g("code",[e._v("TRUSTED_PERIOD < UNBONDING_PERIOD")]),e._v(" and that they are normally of the same order of magnitude, for example\n"),g("code",[e._v("TRUSTED_PERIOD = UNBONDING_PERIOD / 2")]),e._v(".")]),e._v(" "),g("p",[e._v("The specification in this document considers an implementation of the light client under the Failure Model defined above.\nMechanisms like "),g("code",[e._v("fork accountability")]),e._v(" and "),g("code",[e._v("evidence submission")]),e._v(" are defined in the context of "),g("code",[e._v("UNBONDING_PERIOD")]),e._v(" and\nthey incentivize validators to follow the protocol specification defined in this document. If they don't,\nand we have 1/3 (or more) faulty validators, safety may be violated. Our approach then is\nto "),g("em",[e._v("detect")]),e._v(" these cases (after the fact), and take suitable repair actions (automatic and social).\nThis is discussed in document on "),g("RouterLink",{attrs:{to:"/spec/light-client/accountability/"}},[e._v("Fork accountability")]),e._v(".")],1),e._v(" "),g("p",[e._v('The term "trusted" above indicates that the correctness of the protocol depends on\nthis assumption. It is in the responsibility of the user that runs the light client to make sure that the risk\nof trusting a corrupted/forged '),g("code",[e._v("inithead")]),e._v(" is negligible.")]),e._v(" "),g("p",[g("em",[e._v("Remark")]),e._v(": This failure model might change to a hybrid version that takes heights into account in the future.")]),e._v(" "),g("h3",{attrs:{id:"high-level-solution"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#high-level-solution"}},[e._v("#")]),e._v(" High Level Solution")]),e._v(" "),g("p",[e._v("Upon initialization, the light client is given a header "),g("code",[e._v("inithead")]),e._v(" it trusts (by\nsocial consensus). When a light clients sees a new signed header "),g("code",[e._v("snh")]),e._v(", it has to decide whether to trust the new\nheader. Trust can be obtained by (possibly) the combination of three methods.")]),e._v(" "),g("ol",[g("li",[g("p",[g("strong",[e._v("Uninterrupted sequence of headers.")]),e._v(" Given a trusted header "),g("code",[e._v("h")]),e._v(" and an untrusted header "),g("code",[e._v("h1")]),e._v(",\nthe light client trusts a header "),g("code",[e._v("h1")]),e._v(" if it trusts all headers in between "),g("code",[e._v("h")]),e._v(" and "),g("code",[e._v("h1")]),e._v(".")])]),e._v(" "),g("li",[g("p",[g("strong",[e._v("Trusted period.")]),e._v(" Given a trusted header "),g("code",[e._v("h")]),e._v(", an untrusted header "),g("code",[e._v("h1 > h")]),e._v(" and "),g("code",[e._v("TRUSTED_PERIOD")]),e._v(" during which\nthe failure model holds, we can check whether at least one validator, that has been continuously correct\nfrom "),g("code",[e._v("h.Time")]),e._v(" until now, has signed "),g("code",[e._v("h1")]),e._v(". If this is the case, we can trust "),g("code",[e._v("h1")]),e._v(".")])]),e._v(" "),g("li",[g("p",[g("strong",[e._v("Bisection.")]),e._v(" If a check according to 2. (trusted period) fails, the light client can try to\nobtain a header "),g("code",[e._v("hp")]),e._v(" whose height lies between "),g("code",[e._v("h")]),e._v(" and "),g("code",[e._v("h1")]),e._v(" in order to check whether "),g("code",[e._v("h")]),e._v(" can be used to\nget trust for "),g("code",[e._v("hp")]),e._v(", and "),g("code",[e._v("hp")]),e._v(" can be used to get trust for "),g("code",[e._v("snh")]),e._v(". If this is the case we can trust "),g("code",[e._v("h1")]),e._v(";\nif not, we continue recursively until either we found set of headers that can build (transitively) trust relation\nbetween "),g("code",[e._v("h")]),e._v(" and "),g("code",[e._v("h1")]),e._v(", or we failed as two consecutive headers don't verify against each other.")])])]),e._v(" "),g("h2",{attrs:{id:"definitions"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#definitions"}},[e._v("#")]),e._v(" Definitions")]),e._v(" "),g("h3",{attrs:{id:"data-structures"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#data-structures"}},[e._v("#")]),e._v(" Data structures")]),e._v(" "),g("p",[e._v("In the following, only the details of the data structures needed for this specification are given.")]),e._v(" "),g("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ICB0eXBlIEhlYWRlciBzdHJ1Y3QgewogICAgICAgSGVpZ2h0ICAgICAgICAgICAgICAgaW50NjQKICAgICAgIFRpbWUgICAgICAgICAgICAgICAgIFRpbWUgICAgICAgICAgLy8gdGhlIGNoYWluIHRpbWUgd2hlbiB0aGUgaGVhZGVyIChibG9jaykgd2FzIGdlbmVyYXRlZAoKICAgICAgIExhc3RCbG9ja0lEICAgICAgICAgIEJsb2NrSUQgICAgICAgLy8gcHJldiBibG9jayBpbmZvCiAgICAgICBWYWxpZGF0b3JzSGFzaCAgICAgICBbXWJ5dGUgICAgICAgIC8vIGhhc2ggb2YgdGhlIHZhbGlkYXRvcnMgZm9yIHRoZSBjdXJyZW50IGJsb2NrCiAgICAgICBOZXh0VmFsaWRhdG9yc0hhc2ggICBbXWJ5dGUgICAgICAgIC8vIGhhc2ggb2YgdGhlIHZhbGlkYXRvcnMgZm9yIHRoZSBuZXh0IGJsb2NrCiAgfQoKICB0eXBlIFNpZ25lZEhlYWRlciBzdHJ1Y3QgewogICAgICAgSGVhZGVyICAgICAgICBIZWFkZXIKICAgICAgIENvbW1pdCAgICAgICAgQ29tbWl0ICAgICAgICAgICAgLy8gY29tbWl0IGZvciB0aGUgZ2l2ZW4gaGVhZGVyCiAgfQoKICB0eXBlIFZhbGlkYXRvclNldCBzdHJ1Y3QgewogICAgICAgVmFsaWRhdG9ycyAgICAgICAgIFtdVmFsaWRhdG9yCiAgICAgICBUb3RhbFZvdGluZ1Bvd2VyICAgaW50NjQKICB9CgogIHR5cGUgVmFsaWRhdG9yIHN0cnVjdCB7CiAgICAgICBBZGRyZXNzICAgICAgIEFkZHJlc3MgICAgICAgICAgIC8vIHZhbGlkYXRvciBhZGRyZXNzICh3ZSBhc3N1bWUgdmFsaWRhdG9yJ3MgYWRkcmVzc2VzIGFyZSB1bmlxdWUpCiAgICAgICBWb3RpbmdQb3dlciAgIGludDY0ICAgICAgICAgICAgIC8vIHZhbGlkYXRvcidzIHZvdGluZyBwb3dlcgogIH0KCiAgdHlwZSBUcnVzdGVkU3RhdGUgewogICAgICAgU2lnbmVkSGVhZGVyICAgU2lnbmVkSGVhZGVyCiAgICAgICBWYWxpZGF0b3JTZXQgICBWYWxpZGF0b3JTZXQKICB9Cg=="}}),e._v(" "),g("h3",{attrs:{id:"functions"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#functions"}},[e._v("#")]),e._v(" Functions")]),e._v(" "),g("p",[e._v("For the purpose of this light client specification, we assume that the Tendermint Full Node\nexposes the following functions over Tendermint RPC:")]),e._v(" "),g("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ICAgIC8vIHJldHVybnMgc2lnbmVkIGhlYWRlcjogSGVhZGVyIHdpdGggQ29tbWl0LCBmb3IgdGhlIGdpdmVuIGhlaWdodAogICAgZnVuYyBDb21taXQoaGVpZ2h0IGludDY0KSAoU2lnbmVkSGVhZGVyLCBlcnJvcikKCiAgICAvLyByZXR1cm5zIHZhbGlkYXRvciBzZXQgZm9yIHRoZSBnaXZlbiBoZWlnaHQKICAgIGZ1bmMgVmFsaWRhdG9ycyhoZWlnaHQgaW50NjQpIChWYWxpZGF0b3JTZXQsIGVycm9yKQo="}}),e._v(" "),g("p",[e._v("Furthermore, we assume the following auxiliary functions:")]),e._v(" "),g("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ICAgIC8vIHJldHVybnMgdHJ1ZSBpZiB0aGUgY29tbWl0IGlzIGZvciB0aGUgaGVhZGVyLCBpZS4gaWYgaXQgY29udGFpbnMKICAgIC8vIHRoZSBjb3JyZWN0IGhhc2ggb2YgdGhlIGhlYWRlcjsgb3RoZXJ3aXNlIGZhbHNlCiAgICBmdW5jIG1hdGNoaW5nQ29tbWl0KGhlYWRlciBIZWFkZXIsIGNvbW1pdCBDb21taXQpIGJvb2wKCiAgICAvLyByZXR1cm5zIHRoZSBzZXQgb2YgdmFsaWRhdG9ycyBmcm9tIHRoZSBnaXZlbiB2YWxpZGF0b3Igc2V0IHRoYXQKICAgIC8vIGNvbW1pdHRlZCB0aGUgYmxvY2sgKHRoYXQgY29ycmVjdGx5IHNpZ25lZCB0aGUgYmxvY2spCiAgICAvLyBpdCBhc3N1bWVzIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gc28gaXQgY2FuIGJlIGNvbXB1dGF0aW9uYWxseSBleHBlbnNpdmUKICAgIGZ1bmMgc2lnbmVycyhjb21taXQgQ29tbWl0LCB2YWxpZGF0b3JTZXQgVmFsaWRhdG9yU2V0KSBbXVZhbGlkYXRvcgoKICAgIC8vIHJldHVybnMgdGhlIHZvdGluZyBwb3dlciB0aGUgdmFsaWRhdG9ycyBpbiB2MSBoYXZlIGFjY29yZGluZyB0byB0aGVpciB2b3RpbmcgcG93ZXIgaW4gc2V0IHYyCiAgICAvLyBpdCBkb2VzIG5vdCBhc3N1bWUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbgogICAgZnVuYyB2b3RpbmdQb3dlckluKHYxIFtdVmFsaWRhdG9yLCB2MiBWYWxpZGF0b3JTZXQpIGludDY0CgogICAgLy8gcmV0dXJucyBoYXNoIG9mIHRoZSBnaXZlbiB2YWxpZGF0b3Igc2V0CiAgICBmdW5jIGhhc2godjIgVmFsaWRhdG9yU2V0KSBbXWJ5dGUK"}}),e._v(" "),g("p",[e._v("In the functions below we will be using "),g("code",[e._v("trustThreshold")]),e._v(" as a parameter. For simplicity\nwe assume that "),g("code",[e._v("trustThreshold")]),e._v(" is a float between "),g("code",[e._v("1/3")]),e._v(" and "),g("code",[e._v("2/3")]),e._v(" and we will not be checking it\nin the pseudo-code.")]),e._v(" "),g("p",[g("strong",[e._v("VerifySingle.")]),e._v(" The function "),g("code",[e._v("VerifySingle")]),e._v(" attempts to validate given untrusted header and the corresponding validator sets\nbased on a given trusted state. It ensures that the trusted state is still within its trusted period,\nand that the untrusted header is within assumed "),g("code",[e._v("clockDrift")]),e._v(" bound of the passed time "),g("code",[e._v("now")]),e._v(".\nNote that this function is not making external (RPC) calls to the full node; the whole logic is\nbased on the local (given) state. This function is supposed to be used by the IBC handlers.")]),e._v(" "),g("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBWZXJpZnlTaW5nbGUodW50cnVzdGVkU2ggU2lnbmVkSGVhZGVyLAogICAgICAgICAgICAgICAgICB1bnRydXN0ZWRWcyBWYWxpZGF0b3JTZXQsCiAgICAgICAgICAgICAgICAgIHVudHJ1c3RlZE5leHRWcyBWYWxpZGF0b3JTZXQsCiAgICAgICAgICAgICAgICAgIHRydXN0ZWRTdGF0ZSBUcnVzdGVkU3RhdGUsCiAgICAgICAgICAgICAgICAgIHRydXN0VGhyZXNob2xkIGZsb2F0LAogICAgICAgICAgICAgICAgICB0cnVzdGluZ1BlcmlvZCBEdXJhdGlvbiwKICAgICAgICAgICAgICAgICAgY2xvY2tEcmlmdCBEdXJhdGlvbiwKICAgICAgICAgICAgICAgICAgbm93IFRpbWUpIChUcnVzdGVkU3RhdGUsIGVycm9yKSB7CgogICAgaWYgdW50cnVzdGVkU2guSGVhZGVyLlRpbWUgJmd0OyBub3cgKyBjbG9ja0RyaWZ0IHsKICAgICAgICByZXR1cm4gKHRydXN0ZWRTdGF0ZSwgRXJySW52YWxpZEhlYWRlclRpbWUpCiAgICB9CgogICAgdHJ1c3RlZEhlYWRlciA9IHRydXN0ZWRTdGF0ZS5TaWduZWRIZWFkZXIuSGVhZGVyCiAgICBpZiAhaXNXaXRoaW5UcnVzdGVkUGVyaW9kKHRydXN0ZWRIZWFkZXIsIHRydXN0aW5nUGVyaW9kLCBub3cpIHsKICAgICAgICByZXR1cm4gKHN0YXRlLCBFcnJIZWFkZXJOb3RXaXRoaW5UcnVzdGVkUGVyaW9kKQogICAgfQoKICAgIC8vIHdlIGFzc3VtZSB0aGF0IHRpbWUgaXQgdGFrZXMgdG8gZXhlY3V0ZSB2ZXJpZnlTaW5nbGUgZnVuY3Rpb24KICAgIC8vIGlzIHNldmVyYWwgb3JkZXIgb2YgbWFnbml0dWRlcyBzbWFsbGVyIHRoYW4gdHJ1c3RpbmdQZXJpb2QKICAgIGVycm9yID0gdmVyaWZ5U2luZ2xlKAogICAgICAgICAgICAgICAgdHJ1c3RlZFN0YXRlLAogICAgICAgICAgICAgICAgdW50cnVzdGVkU2gsCiAgICAgICAgICAgICAgICB1bnRydXN0ZWRWcywKICAgICAgICAgICAgICAgIHVudHJ1c3RlZE5leHRWcywKICAgICAgICAgICAgICAgIHRydXN0VGhyZXNob2xkKQoKICAgIGlmIGVycm9yICE9IG5pbCByZXR1cm4gKHN0YXRlLCBlcnJvcikKCiAgICAvLyB0aGUgdW50cnVzdGVkIGhlYWRlciBpcyBub3cgdHJ1c3RlZAogICAgbmV3VHJ1c3RlZFN0YXRlID0gVHJ1c3RlZFN0YXRlKHVudHJ1c3RlZFNoLCB1bnRydXN0ZWROZXh0VnMpCiAgICByZXR1cm4gKG5ld1RydXN0ZWRTdGF0ZSwgbmlsKQp9CgovLyByZXR1cm4gdHJ1ZSBpZiBoZWFkZXIgaXMgd2l0aGluIGl0cyBsaWdodCBjbGllbnQgdHJ1c3RlZCBwZXJpb2Q7IG90aGVyd2lzZSByZXR1cm5zIGZhbHNlCmZ1bmMgaXNXaXRoaW5UcnVzdGVkUGVyaW9kKGhlYWRlciBIZWFkZXIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydXN0aW5nUGVyaW9kIER1cmF0aW9uLAogICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgVGltZSkgYm9vbCB7CgogICAgcmV0dXJuIGhlYWRlci5UaW1lICsgdHJ1c3RlZFBlcmlvZCAmZ3Q7IG5vdwp9Cg=="}}),e._v(" "),g("p",[e._v("Note that in case "),g("code",[e._v("VerifySingle")]),e._v(" returns without an error (untrusted header\nis successfully verified) then we have a guarantee that the transition of the trust\nfrom "),g("code",[e._v("trustedState")]),e._v(" to "),g("code",[e._v("newTrustedState")]),e._v(" happened during the trusted period of\n"),g("code",[e._v("trustedState.SignedHeader.Header")]),e._v(".")]),e._v(" "),g("p",[e._v("TODO: Explain what happens in case "),g("code",[e._v("VerifySingle")]),e._v(" returns with an error.")]),e._v(" "),g("p",[g("strong",[e._v("verifySingle.")]),e._v(" The function "),g("code",[e._v("verifySingle")]),e._v(" verifies a single untrusted header\nagainst a given trusted state. It includes all validations and signature verification.\nIt is not publicly exposed since it does not check for header expiry (time constraints)\nand hence it's possible to use it incorrectly.")]),e._v(" "),g("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyB2ZXJpZnlTaW5nbGUodHJ1c3RlZFN0YXRlIFRydXN0ZWRTdGF0ZSwKICAgICAgICAgICAgICAgICAgdW50cnVzdGVkU2ggU2lnbmVkSGVhZGVyLAogICAgICAgICAgICAgICAgICB1bnRydXN0ZWRWcyBWYWxpZGF0b3JTZXQsCiAgICAgICAgICAgICAgICAgIHVudHJ1c3RlZE5leHRWcyBWYWxpZGF0b3JTZXQsCiAgICAgICAgICAgICAgICAgIHRydXN0VGhyZXNob2xkIGZsb2F0KSBlcnJvciB7CgogICAgdW50cnVzdGVkSGVhZGVyID0gdW50cnVzdGVkU2guSGVhZGVyCiAgICB1bnRydXN0ZWRDb21taXQgPSB1bnRydXN0ZWRTaC5Db21taXQKCiAgICB0cnVzdGVkSGVhZGVyID0gdHJ1c3RlZFN0YXRlLlNpZ25lZEhlYWRlci5IZWFkZXIKICAgIHRydXN0ZWRWcyA9IHRydXN0ZWRTdGF0ZS5WYWxpZGF0b3JTZXQKCiAgICBpZiB0cnVzdGVkSGVhZGVyLkhlaWdodCAmZ3Q7PSB1bnRydXN0ZWRIZWFkZXIuSGVpZ2h0IHJldHVybiBFcnJOb25JbmNyZWFzaW5nSGVpZ2h0CiAgICBpZiB0cnVzdGVkSGVhZGVyLlRpbWUgJmd0Oz0gdW50cnVzdGVkSGVhZGVyLlRpbWUgcmV0dXJuIEVyck5vbkluY3JlYXNpbmdUaW1lCgogICAgLy8gdmFsaWRhdGUgdGhlIHVudHJ1c3RlZCBoZWFkZXIgYWdhaW5zdCBpdHMgY29tbWl0LCB2YWxzLCBhbmQgbmV4dF92YWxzCiAgICBlcnJvciA9IHZhbGlkYXRlU2lnbmVkSGVhZGVyQW5kVmFscyh1bnRydXN0ZWRTaCwgdW50cnVzdGVkVnMsIHVudHJ1c3RlZE5leHRWcykKICAgIGlmIGVycm9yICE9IG5pbCByZXR1cm4gZXJyb3IKCiAgICAvLyBjaGVjayBmb3IgYWRqYWNlbnQgaGVhZGVycwogICAgaWYgdW50cnVzdGVkSGVhZGVyLkhlaWdodCA9PSB0cnVzdGVkSGVhZGVyLkhlaWdodCArIDEgewogICAgICAgIGlmIHRydXN0ZWRIZWFkZXIuTmV4dFZhbGlkYXRvcnNIYXNoICE9IHVudHJ1c3RlZEhlYWRlci5WYWxpZGF0b3JzSGFzaCB7CiAgICAgICAgICAgIHJldHVybiBFcnJJbnZhbGlkQWRqYWNlbnRIZWFkZXJzCiAgICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgICBlcnJvciA9IHZlcmlmeUNvbW1pdFRydXN0aW5nKHRydXN0ZWRWcywgdW50cnVzdGVkQ29tbWl0LCB1bnRydXN0ZWRWcywgdHJ1c3RUaHJlc2hvbGQpCiAgICAgICAgaWYgZXJyb3IgIT0gbmlsIHJldHVybiBlcnJvcgogICAgfQoKICAgIC8vIHZlcmlmeSB0aGUgdW50cnVzdGVkIGNvbW1pdAogICAgcmV0dXJuIHZlcmlmeUNvbW1pdEZ1bGwodW50cnVzdGVkVnMsIHVudHJ1c3RlZENvbW1pdCkKfQoKLy8gcmV0dXJucyBuaWwgaWYgaGVhZGVyIGFuZCB2YWxpZGF0b3Igc2V0cyBhcmUgY29uc2lzdGVudDsgb3RoZXJ3aXNlIHJldHVybnMgZXJyb3IKZnVuYyB2YWxpZGF0ZVNpZ25lZEhlYWRlckFuZFZhbHMoc2lnbmVkSGVhZGVyIFNpZ25lZEhlYWRlciwgdnMgVmFsaWRhdG9yU2V0LCBuZXh0VnMgVmFsaWRhdG9yU2V0KSBlcnJvciB7CiAgICBoZWFkZXIgPSBzaWduZWRIZWFkZXIuSGVhZGVyCiAgICBpZiBoYXNoKHZzKSAhPSBoZWFkZXIuVmFsaWRhdG9yc0hhc2ggcmV0dXJuIEVyckludmFsaWRWYWxpZGF0b3JTZXQKICAgIGlmIGhhc2gobmV4dFZzKSAhPSBoZWFkZXIuTmV4dFZhbGlkYXRvcnNIYXNoIHJldHVybiBFcnJJbnZhbGlkTmV4dFZhbGlkYXRvclNldAogICAgaWYgIW1hdGNoaW5nQ29tbWl0KGhlYWRlciwgc2lnbmVkSGVhZGVyLkNvbW1pdCkgcmV0dXJuIEVyckludmFsaWRDb21taXRWYWx1ZQogICAgcmV0dXJuIG5pbAp9CgovLyByZXR1cm5zIG5pbCBpZiBhdCBsZWFzdCBzaW5nbGUgY29ycmVzdCBzaWduZXIgc2lnbmVkIHRoZSBjb21taXQ7IG90aGVyd2lzZSByZXR1cm5zIGVycm9yCmZ1bmMgdmVyaWZ5Q29tbWl0VHJ1c3RpbmcodHJ1c3RlZFZzIFZhbGlkYXRvclNldCwKICAgICAgICAgICAgICAgICAgICAgICAgICBjb21taXQgQ29tbWl0LAogICAgICAgICAgICAgICAgICAgICAgICAgIHVudHJ1c3RlZFZzIFZhbGlkYXRvclNldCwKICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVzdExldmVsIGZsb2F0KSBlcnJvciB7CgogICAgdG90YWxQb3dlciA6PSB0cnVzdGVkVnMuVG90YWxWb3RpbmdQb3dlcgogICAgc2lnbmVkUG93ZXIgOj0gdm90aW5nUG93ZXJJbihzaWduZXJzKGNvbW1pdCwgdW50cnVzdGVkVnMpLCB0cnVzdGVkVnMpCgogICAgLy8gY2hlY2sgdGhhdCB0aGUgc2lnbmVycyBhY2NvdW50IGZvciBtb3JlIHRoYW4gbWF4KDEvMywgdHJ1c3RMZXZlbCkgb2YgdGhlIHZvdGluZyBwb3dlcgogICAgLy8gdGhpcyBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3Qgc2luZ2xlIGNvcnJlY3QgdmFsaWRhdG9yIGluIHRoZSBzZXQgb2Ygc2lnbmVycwogICAgaWYgc2lnbmVkUG93ZXIgJmx0OyBtYXgoMS8zLCB0cnVzdExldmVsKSAqIHRvdGFsUG93ZXIgcmV0dXJuIEVyckluc3VmZmljaWVudFZvdGluZ1Bvd2VyCiAgICByZXR1cm4gbmlsCn0KCi8vIHJldHVybnMgbmlsIGlmIGNvbW1pdCBpcyBzaWduZWQgYnkgbW9yZSB0aGFuIDIvMyBvZiB2b3RpbmcgcG93ZXIgb2YgdGhlIGdpdmVuIHZhbGlkYXRvciBzZXQKLy8gcmV0dXJuIGVycm9yIG90aGVyd2lzZQpmdW5jIHZlcmlmeUNvbW1pdEZ1bGwodnMgVmFsaWRhdG9yU2V0LCBjb21taXQgQ29tbWl0KSBlcnJvciB7CiAgICB0b3RhbFBvd2VyIDo9IHZzLlRvdGFsVm90aW5nUG93ZXI7CiAgICBzaWduZWRQb3dlciA6PSB2b3RpbmdQb3dlckluKHNpZ25lcnMoY29tbWl0LCB2cyksIHZzKQoKICAgIC8vIGNoZWNrIHRoZSBzaWduZXJzIGFjY291bnQgZm9yICsyLzMgb2YgdGhlIHZvdGluZyBwb3dlcgogICAgaWYgc2lnbmVkUG93ZXIgKiAzICZsdDs9IHRvdGFsUG93ZXIgKiAyIHJldHVybiBFcnJJbnZhbGlkQ29tbWl0CiAgICByZXR1cm4gbmlsCn0K"}}),e._v(" "),g("p",[g("strong",[e._v("VerifyHeaderAtHeight.")]),e._v(" The function "),g("code",[e._v("VerifyHeaderAtHeight")]),e._v(" captures high level\nlogic, i.e., application call to the light client module to download and verify header\nfor some height.")]),e._v(" "),g("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBWZXJpZnlIZWFkZXJBdEhlaWdodCh1bnRydXN0ZWRIZWlnaHQgaW50NjQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1c3RlZFN0YXRlIFRydXN0ZWRTdGF0ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVzdFRocmVzaG9sZCBmbG9hdCwKICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVzdGluZ1BlcmlvZCBEdXJhdGlvbiwKICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9ja0RyaWZ0IER1cmF0aW9uKSAoVHJ1c3RlZFN0YXRlLCBlcnJvcikpIHsKCiAgICB0cnVzdGVkSGVhZGVyIDo9IHRydXN0ZWRTdGF0ZS5TaWduZWRIZWFkZXIuSGVhZGVyCgogICAgbm93IDo9IFN5c3RlbS5UaW1lKCkKICAgIGlmICFpc1dpdGhpblRydXN0ZWRQZXJpb2QodHJ1c3RlZEhlYWRlciwgdHJ1c3RpbmdQZXJpb2QsIG5vdykgewogICAgICAgIHJldHVybiAodHJ1c3RlZFN0YXRlLCBFcnJIZWFkZXJOb3RXaXRoaW5UcnVzdGVkUGVyaW9kKQogICAgfQoKICAgIG5ld1RydXN0ZWRTdGF0ZSwgZXJyIDo9IFZlcmlmeUJpc2VjdGlvbih1bnRydXN0ZWRIZWlnaHQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1c3RlZFN0YXRlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydXN0VGhyZXNob2xkLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydXN0aW5nUGVyaW9kLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb2NrRHJpZnQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93KQoKICAgIGlmIGVyciAhPSBuaWwgcmV0dXJuICh0cnVzdGVkU3RhdGUsIGVycikKCiAgICBub3cgPSBTeXN0ZW0uVGltZSgpCiAgICBpZiAhaXNXaXRoaW5UcnVzdGVkUGVyaW9kKHRydXN0ZWRIZWFkZXIsIHRydXN0aW5nUGVyaW9kLCBub3cpIHsKICAgICAgICByZXR1cm4gKHRydXN0ZWRTdGF0ZSwgRXJySGVhZGVyTm90V2l0aGluVHJ1c3RlZFBlcmlvZCkKICAgIH0KCiAgICByZXR1cm4gKG5ld1RydXN0ZWRTdGF0ZSwgZXJyKQp9Cg=="}}),e._v(" "),g("p",[e._v("Note that in case "),g("code",[e._v("VerifyHeaderAtHeight")]),e._v(" returns without an error (untrusted header\nis successfully verified) then we have a guarantee that the transition of the trust\nfrom "),g("code",[e._v("trustedState")]),e._v(" to "),g("code",[e._v("newTrustedState")]),e._v(" happened during the trusted period of\n"),g("code",[e._v("trustedState.SignedHeader.Header")]),e._v(".")]),e._v(" "),g("p",[e._v("In case "),g("code",[e._v("VerifyHeaderAtHeight")]),e._v(" returns with an error, then either (i) the full node we are talking to is faulty\nor (ii) the trusted header has expired (it is outside its trusted period). In case (i) the full node is faulty so\nlight client should disconnect and reinitialise with new peer. In the case (ii) as the trusted header has expired,\nwe need to reinitialise light client with a new trusted header (that is within its trusted period),\nbut we don't necessarily need to disconnect from the full node we are talking to (as we haven't observed full node misbehavior in this case).")]),e._v(" "),g("p",[g("strong",[e._v("VerifyBisection.")]),e._v(" The function "),g("code",[e._v("VerifyBisection")]),e._v(" implements\nrecursive logic for checking if it is possible building trust\nrelationship between "),g("code",[e._v("trustedState")]),e._v(" and untrusted header at the given height over\nfinite set of (downloaded and verified) headers.")]),e._v(" "),g("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBWZXJpZnlCaXNlY3Rpb24odW50cnVzdGVkSGVpZ2h0IGludDY0LAogICAgICAgICAgICAgICAgICAgICB0cnVzdGVkU3RhdGUgVHJ1c3RlZFN0YXRlLAogICAgICAgICAgICAgICAgICAgICB0cnVzdFRocmVzaG9sZCBmbG9hdCwKICAgICAgICAgICAgICAgICAgICAgdHJ1c3RpbmdQZXJpb2QgRHVyYXRpb24sCiAgICAgICAgICAgICAgICAgICAgIGNsb2NrRHJpZnQgRHVyYXRpb24sCiAgICAgICAgICAgICAgICAgICAgIG5vdyBUaW1lKSAoVHJ1c3RlZFN0YXRlLCBlcnJvcikgewoKICAgIHVudHJ1c3RlZFNoLCBlcnJvciA6PSBDb21taXQodW50cnVzdGVkSGVpZ2h0KQogICAgaWYgZXJyb3IgIT0gbmlsIHJldHVybiAodHJ1c3RlZFN0YXRlLCBFcnJSZXF1ZXN0RmFpbGVkKQoKICAgIHVudHJ1c3RlZEhlYWRlciA9IHVudHJ1c3RlZFNoLkhlYWRlcgoKICAgIC8vIG5vdGUgdGhhdCB3ZSBwYXNzIG5vdyBkdXJpbmcgdGhlIHJlY3Vyc2l2ZSBjYWxscy4gVGhpcyBpcyBmaW5lIGFzCiAgICAvLyBhbGwgb3RoZXIgdW50cnVzdGVkIGhlYWRlcnMgd2UgZG93bmxvYWQgZHVyaW5nIHJlY3Vyc2lvbiB3aWxsIGJlCiAgICAvLyBmb3IgYSBzbWFsbGVyIGhlaWdodHMsIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGhhcHBlbiBiZWZvcmUuCiAgICBpZiB1bnRydXN0ZWRIZWFkZXIuVGltZSAmZ3Q7IG5vdyArIGNsb2NrRHJpZnQgewogICAgICAgIHJldHVybiAodHJ1c3RlZFN0YXRlLCBFcnJJbnZhbGlkSGVhZGVyVGltZSkKICAgIH0KCiAgICB1bnRydXN0ZWRWcywgZXJyb3IgOj0gVmFsaWRhdG9ycyh1bnRydXN0ZWRIZWlnaHQpCiAgICBpZiBlcnJvciAhPSBuaWwgcmV0dXJuICh0cnVzdGVkU3RhdGUsIEVyclJlcXVlc3RGYWlsZWQpCgogICAgdW50cnVzdGVkTmV4dFZzLCBlcnJvciA6PSBWYWxpZGF0b3JzKHVudHJ1c3RlZEhlaWdodCArIDEpCiAgICBpZiBlcnJvciAhPSBuaWwgcmV0dXJuICh0cnVzdGVkU3RhdGUsIEVyclJlcXVlc3RGYWlsZWQpCgogICAgZXJyb3IgPSB2ZXJpZnlTaW5nbGUoCiAgICAgICAgICAgICB0cnVzdGVkU3RhdGUsCiAgICAgICAgICAgICB1bnRydXN0ZWRTaCwKICAgICAgICAgICAgIHVudHJ1c3RlZFZzLAogICAgICAgICAgICAgdW50cnVzdGVkTmV4dFZzLAogICAgICAgICAgICAgdHJ1c3RUaHJlc2hvbGQpCgogICAgaWYgZmF0YWxFcnJvcihlcnJvcikgcmV0dXJuICh0cnVzdGVkU3RhdGUsIGVycm9yKQoKICAgIGlmIGVycm9yID09IG5pbCB7CiAgICAgICAgLy8gdGhlIHVudHJ1c3RlZCBoZWFkZXIgaXMgbm93IHRydXN0ZWQuCiAgICAgICAgbmV3VHJ1c3RlZFN0YXRlID0gVHJ1c3RlZFN0YXRlKHVudHJ1c3RlZFNoLCB1bnRydXN0ZWROZXh0VnMpCiAgICAgICAgcmV0dXJuIChuZXdUcnVzdGVkU3RhdGUsIG5pbCkKICAgIH0KCiAgICAvLyBhdCB0aGlzIHBvaW50IGluIHRpbWUgd2UgbmVlZCB0byBkbyBiaXNlY3Rpb24KICAgIHBpdm90SGVpZ2h0IDo9IGNlaWwoKHRydXN0ZWRIZWFkZXIuSGVpZ2h0ICsgdW50cnVzdGVkSGVpZ2h0KSAvIDIpCgogICAgZXJyb3IsIG5ld1RydXN0ZWRTdGF0ZSA9IFZlcmlmeUJpc2VjdGlvbihwaXZvdEhlaWdodCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1c3RlZFN0YXRlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVzdFRocmVzaG9sZCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1c3RpbmdQZXJpb2QsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb2NrRHJpZnQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdykKICAgIGlmIGVycm9yICE9IG5pbCByZXR1cm4gKG5ld1RydXN0ZWRTdGF0ZSwgZXJyb3IpCgogICAgcmV0dXJuIFZlcmlmeUJpc2VjdGlvbih1bnRydXN0ZWRIZWlnaHQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RydXN0ZWRTdGF0ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1c3RUaHJlc2hvbGQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydXN0aW5nUGVyaW9kLAogICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9ja0RyaWZ0LAogICAgICAgICAgICAgICAgICAgICAgICAgICBub3cpCn0KCmZ1bmMgZmF0YWxFcnJvcihlcnIpIGJvb2wgewogICAgcmV0dXJuIGVyciA9PSBFcnJIZWFkZXJOb3RXaXRoaW5UcnVzdGVkUGVyaW9kIE9SCiAgICAgICAgICAgZXJyID09IEVyckludmFsaWRBZGphY2VudEhlYWRlcnMgT1IKICAgICAgICAgICBlcnIgPT0gRXJyTm9uSW5jcmVhc2luZ0hlaWdodCBPUgogICAgICAgICAgIGVyciA9PSBFcnJOb25JbmNyZWFzaW5nVGltZSBPUgogICAgICAgICAgIGVyciA9PSBFcnJJbnZhbGlkVmFsaWRhdG9yU2V0IE9SCiAgICAgICAgICAgZXJyID09IEVyckludmFsaWROZXh0VmFsaWRhdG9yU2V0IE9SCiAgICAgICAgICAgZXJyID09IEVyckludmFsaWRDb21taXRWYWx1ZSBPUgogICAgICAgICAgIGVyciA9PSBFcnJJbnZhbGlkQ29tbWl0Cn0K"}}),e._v(" "),g("h3",{attrs:{id:"the-case-untrustedheader-height-trustedheader-height"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#the-case-untrustedheader-height-trustedheader-height"}},[e._v("#")]),e._v(" The case "),g("code",[e._v("untrustedHeader.Height < trustedHeader.Height")])]),e._v(" "),g("p",[e._v("In the use case where someone tells the light client that application data that is relevant for it\ncan be read in the block of height "),g("code",[e._v("k")]),e._v(' and the light client trusts a more recent header, we can use the\nhashes to verify headers "down the chain." That is, we iterate down the heights and check the hashes in each step.')]),e._v(" "),g("p",[g("em",[e._v("Remark.")]),e._v(" For the case were the light client trusts two headers "),g("code",[e._v("i")]),e._v(" and "),g("code",[e._v("j")]),e._v(" with "),g("code",[e._v("i < k < j")]),e._v(", we should\ndiscuss/experiment whether the forward or the backward method is more effective.")]),e._v(" "),g("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBWZXJpZnlIZWFkZXJCYWNrd2FyZHModHJ1c3RlZEhlYWRlciBIZWFkZXIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgIHVudHJ1c3RlZEhlYWRlciBIZWFkZXIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydXN0aW5nUGVyaW9kIER1cmF0aW9uLAogICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9ja0RyaWZ0IER1cmF0aW9uKSBlcnJvciB7CgogIGlmIHVudHJ1c3RlZEhlYWRlci5IZWlnaHQgJmd0Oz0gdHJ1c3RlZEhlYWRlci5IZWlnaHQgcmV0dXJuIEVyckVyck5vbkRlY3JlYXNpbmdIZWlnaHQKICBpZiB1bnRydXN0ZWRIZWFkZXIuVGltZSAmZ3Q7PSB0cnVzdGVkSGVhZGVyLlRpbWUgcmV0dXJuIEVyck5vbkRlY3JlYXNpbmdUaW1lCgogIG5vdyA6PSBTeXN0ZW0uVGltZSgpCiAgaWYgIWlzV2l0aGluVHJ1c3RlZFBlcmlvZCh0cnVzdGVkSGVhZGVyLCB0cnVzdGluZ1BlcmlvZCwgbm93KSB7CiAgICByZXR1cm4gRXJySGVhZGVyTm90V2l0aGluVHJ1c3RlZFBlcmlvZAogIH0KCiAgb2xkIDo9IHRydXN0ZWRIZWFkZXIKICBmb3IgaSA6PSB0cnVzdGVkSGVhZGVyLkhlaWdodCAtIDE7IGkgJmd0OyB1bnRydXN0ZWRIZWFkZXIuSGVpZ2h0OyBpLS0gewogICAgdW50cnVzdGVkU2gsIGVycm9yIDo9IENvbW1pdChpKQogICAgaWYgZXJyb3IgIT0gbmlsIHJldHVybiBFcnJSZXF1ZXN0RmFpbGVkCgogICAgaWYgKGhhc2godW50cnVzdGVkU2guSGVhZGVyKSAhPSBvbGQuTGFzdEJsb2NrSUQuSGFzaCkgewogICAgICByZXR1cm4gRXJySW52YWxpZEFkamFjZW50SGVhZGVycwogICAgfQoKICAgIG9sZCA6PSB1bnRydXN0ZWRTaC5IZWFkZXIKICB9CgogIGlmIGhhc2godW50cnVzdGVkSGVhZGVyKSAhPSBvbGQuTGFzdEJsb2NrSUQuSGFzaCB7CiAgICByZXR1cm4gRXJySW52YWxpZEFkamFjZW50SGVhZGVycwogIH0KCiAgbm93IDo9IFN5c3RlbS5UaW1lKCkKICBpZiAhaXNXaXRoaW5UcnVzdGVkUGVyaW9kKHRydXN0ZWRIZWFkZXIsIHRydXN0aW5nUGVyaW9kLCBub3cpIHsKICAgIHJldHVybiBFcnJIZWFkZXJOb3RXaXRoaW5UcnVzdGVkUGVyaW9kCiAgfQoKICByZXR1cm4gbmlsCiB9Cg=="}}),e._v(" "),g("p",[g("em",[e._v("Assumption")]),e._v(": In the following, we assume that "),g("em",[e._v("untrusted_h.Header.height > trusted_h.Header.height")]),e._v(". We will quickly discuss the other case in the next section.")]),e._v(" "),g("p",[e._v("We consider the following set-up:")]),e._v(" "),g("ul",[g("li",[e._v("the light client communicates with one full node")]),e._v(" "),g("li",[e._v("the light client locally stores all the headers that has passed basic verification and that are within light client trust period. In the pseudo code below we\nwrite "),g("em",[e._v("Store.Add(header)")]),e._v(" for this. If a header failed to verify, then\nthe full node we are talking to is faulty and we should disconnect from it and reinitialise with new peer.")]),e._v(" "),g("li",[e._v("If "),g("code",[e._v("CanTrust")]),e._v(" returns "),g("em",[e._v("error")]),e._v(", then the light client has seen a forged header or the trusted header has expired (it is outside its trusted period).\n"),g("ul",[g("li",[e._v("In case of forged header, the full node is faulty so light client should disconnect and reinitialise with new peer. If the trusted header has expired,\nwe need to reinitialise light client with new trusted header (that is within its trusted period), but we don't necessarily need to disconnect from the full node\nwe are talking to (as we haven't observed full node misbehavior in this case).")])])])]),e._v(" "),g("h2",{attrs:{id:"correctness-of-the-light-client-protocols"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#correctness-of-the-light-client-protocols"}},[e._v("#")]),e._v(" Correctness of the Light Client Protocols")]),e._v(" "),g("h3",{attrs:{id:"definitions-2"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#definitions-2"}},[e._v("#")]),e._v(" Definitions")]),e._v(" "),g("ul",[g("li",[g("code",[e._v("TRUSTED_PERIOD")]),e._v(": trusted period")]),e._v(" "),g("li",[e._v("for realtime "),g("code",[e._v("t")]),e._v(", the predicate "),g("code",[e._v("correct(v,t)")]),e._v(" is true if the validator "),g("code",[e._v("v")]),e._v("\nfollows the protocol until time "),g("code",[e._v("t")]),e._v(" (we will see about recovery later).")]),e._v(" "),g("li",[e._v("Validator fields. We will write a validator as a tuple "),g("code",[e._v("(v,p)")]),e._v(" such that\n"),g("ul",[g("li",[g("code",[e._v("v")]),e._v(" is the identifier (i.e., validator address; we assume identifiers are unique in each validator set)")]),e._v(" "),g("li",[g("code",[e._v("p")]),e._v(" is its voting power")])])]),e._v(" "),g("li",[e._v("For each header "),g("code",[e._v("h")]),e._v(", we write "),g("code",[e._v("trust(h) = true")]),e._v(" if the light client trusts "),g("code",[e._v("h")]),e._v(".")])]),e._v(" "),g("h3",{attrs:{id:"failure-model-2"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#failure-model-2"}},[e._v("#")]),e._v(" Failure Model")]),e._v(" "),g("p",[e._v("If a block "),g("code",[e._v("b")]),e._v(" with a header "),g("code",[e._v("h")]),e._v(" is generated at time "),g("code",[e._v("Time")]),e._v(" (i.e. "),g("code",[e._v("h.Time = Time")]),e._v("), then a set of validators that\nhold more than "),g("code",[e._v("2/3")]),e._v(" of the voting power in "),g("code",[e._v("validators(h.NextValidatorsHash)")]),e._v(" is correct until time\n"),g("code",[e._v("h.Time + TRUSTED_PERIOD")]),e._v(".")]),e._v(" "),g("p",[e._v("Formally,\n[\n\\sum_{(v,p) \\in validators(h.NextValidatorsHash) \\wedge correct(v,h.Time + TRUSTED_PERIOD)} p >\n2/3 \\sum_{(v,p) \\in validators(h.NextValidatorsHash)} p\n]")]),e._v(" "),g("p",[e._v("The light client communicates with a full node and learns new headers. The goal is to locally decide whether to trust a header. Our implementation needs to ensure the following two properties:")]),e._v(" "),g("ul",[g("li",[g("p",[g("em",[e._v("Light Client Completeness")]),e._v(": If a header "),g("code",[e._v("h")]),e._v(" was correctly generated by an instance of Tendermint consensus (and its age is less than the trusted period),\nthen the light client should eventually set "),g("code",[e._v("trust(h)")]),e._v(" to "),g("code",[e._v("true")]),e._v(".")])]),e._v(" "),g("li",[g("p",[g("em",[e._v("Light Client Accuracy")]),e._v(": If a header "),g("code",[e._v("h")]),e._v(" was "),g("em",[e._v("not generated")]),e._v(" by an instance of Tendermint consensus, then the light client should never set "),g("code",[e._v("trust(h)")]),e._v(" to true.")])])]),e._v(" "),g("p",[g("em",[e._v("Remark")]),e._v(": If in the course of the computation, the light client obtains certainty that some headers were forged by adversaries\n(that is were not generated by an instance of Tendermint consensus), it may submit (a subset of) the headers it has seen as evidence of misbehavior.")]),e._v(" "),g("p",[g("em",[e._v("Remark")]),e._v(': In Completeness we use "eventually", while in practice '),g("code",[e._v("trust(h)")]),e._v(" should be set to true before "),g("code",[e._v("h.Time + TRUSTED_PERIOD")]),e._v(". If not, the header\ncannot be trusted because it is too old.")]),e._v(" "),g("p",[g("em",[e._v("Remark")]),e._v(": If a header "),g("code",[e._v("h")]),e._v(" is marked with "),g("code",[e._v("trust(h)")]),e._v(", but it is too old at some point in time we denote with "),g("code",[e._v("now")]),e._v(" ("),g("code",[e._v("h.Time + TRUSTED_PERIOD < now")]),e._v("),\nthen the light client should set "),g("code",[e._v("trust(h)")]),e._v(" to "),g("code",[e._v("false")]),e._v(" again at time "),g("code",[e._v("now")]),e._v(".")]),e._v(" "),g("p",[g("em",[e._v("Assumption")]),e._v(": Initially, the light client has a header "),g("code",[e._v("inithead")]),e._v(" that it trusts, that is, "),g("code",[e._v("inithead")]),e._v(" was correctly generated by the Tendermint consensus.")]),e._v(" "),g("p",[e._v("To reason about the correctness, we may prove the following invariant.")]),e._v(" "),g("p",[g("em",[e._v("Verification Condition: light Client Invariant.")]),e._v("\nFor each light client "),g("code",[e._v("l")]),e._v(" and each header "),g("code",[e._v("h")]),e._v(":\nif "),g("code",[e._v("l")]),e._v(" has set "),g("code",[e._v("trust(h) = true")]),e._v(",\nthen validators that are correct until time "),g("code",[e._v("h.Time + TRUSTED_PERIOD")]),e._v(" have more than two thirds of the voting power in "),g("code",[e._v("validators(h.NextValidatorsHash)")]),e._v(".")]),e._v(" "),g("p",[e._v("Formally,\n[\n\\sum_{(v,p) \\in validators(h.NextValidatorsHash) \\wedge correct(v,h.Time + TRUSTED_PERIOD)} p >\n2/3 \\sum_{(v,p) \\in validators(h.NextValidatorsHash)} p\n]")]),e._v(" "),g("p",[g("em",[e._v("Remark.")]),e._v(" To prove the invariant, we will have to prove that the light client only trusts headers that were correctly generated by Tendermint consensus.\nThen the formula above follows from the failure model.")]),e._v(" "),g("h2",{attrs:{id:"details"}},[g("a",{staticClass:"header-anchor",attrs:{href:"#details"}},[e._v("#")]),e._v(" Details")]),e._v(" "),g("p",[g("strong",[e._v("Observation 1.")]),e._v(" If "),g("code",[e._v("h.Time + TRUSTED_PERIOD > now")]),e._v(", we trust the validator set "),g("code",[e._v("validators(h.NextValidatorsHash)")]),e._v(".")]),e._v(" "),g("p",[e._v("When we say we trust "),g("code",[e._v("validators(h.NextValidatorsHash)")]),e._v(" we do "),g("code",[e._v("not")]),e._v(" trust that each individual validator in "),g("code",[e._v("validators(h.NextValidatorsHash)")]),e._v("\nis correct, but we only trust the fact that less than "),g("code",[e._v("1/3")]),e._v(" of them are faulty (more precisely, the faulty ones have less than "),g("code",[e._v("1/3")]),e._v(" of the total voting power).")]),e._v(" "),g("p",[g("em",[g("code",[e._v("VerifySingle")]),e._v(" correctness arguments")])]),e._v(" "),g("p",[e._v("Light Client Accuracy:")]),e._v(" "),g("ul",[g("li",[e._v("Assume by contradiction that "),g("code",[e._v("untrustedHeader")]),e._v(" was not generated correctly and the light client sets trust to true because "),g("code",[e._v("verifySingle")]),e._v(" returns without error.")]),e._v(" "),g("li",[g("code",[e._v("trustedState")]),e._v(" is trusted and sufficiently new")]),e._v(" "),g("li",[e._v("by the Failure Model, less than "),g("code",[e._v("1/3")]),e._v(" of the voting power held by faulty validators => at least one correct validator "),g("code",[e._v("v")]),e._v(" has signed "),g("code",[e._v("untrustedHeader")]),e._v(".")]),e._v(" "),g("li",[e._v("as "),g("code",[e._v("v")]),e._v(" is correct up to now, it followed the Tendermint consensus protocol at least up to signing "),g("code",[e._v("untrustedHeader")]),e._v(" => "),g("code",[e._v("untrustedHeader")]),e._v(" was correctly generated.\nWe arrive at the required contradiction.")])]),e._v(" "),g("p",[e._v("Light Client Completeness:")]),e._v(" "),g("ul",[g("li",[e._v("The check is successful if sufficiently many validators of "),g("code",[e._v("trustedState")]),e._v(" are still validators in the height "),g("code",[e._v("untrustedHeader.Height")]),e._v(" and signed "),g("code",[e._v("untrustedHeader")]),e._v(".")]),e._v(" "),g("li",[e._v("If "),g("code",[e._v("untrustedHeader.Height = trustedHeader.Height + 1")]),e._v(", and both headers were generated correctly, the test passes.")])]),e._v(" "),g("p",[g("em",[e._v("Verification Condition:")]),e._v(" We may need a Tendermint invariant stating that if "),g("code",[e._v("untrustedSignedHeader.Header.Height = trustedHeader.Height + 1")]),e._v(" then\n"),g("code",[e._v("signers(untrustedSignedHeader.Commit) \\subseteq validators(trustedHeader.NextValidatorsHash)")]),e._v(".")]),e._v(" "),g("p",[g("em",[e._v("Remark")]),e._v(": The variable "),g("code",[e._v("trustThreshold")]),e._v(" can be used if the user believes that relying on one correct validator is not sufficient.\nHowever, in case of (frequent) changes in the validator set, the higher the "),g("code",[e._v("trustThreshold")]),e._v(" is chosen, the more unlikely it becomes that\n"),g("code",[e._v("verifySingle")]),e._v(" returns with an error for non-adjacent headers.")]),e._v(" "),g("ul",[g("li",[g("code",[e._v("VerifyBisection")]),e._v(" correctness arguments (sketch)*")])]),e._v(" "),g("p",[e._v("Light Client Accuracy:")]),e._v(" "),g("ul",[g("li",[e._v("Assume by contradiction that the header at "),g("code",[e._v("untrustedHeight")]),e._v(" obtained from the full node was not generated correctly and\nthe light client sets trust to true because "),g("code",[e._v("VerifyBisection")]),e._v(" returns without an error.")]),e._v(" "),g("li",[g("code",[e._v("VerifyBisection")]),e._v(" returns without error only if all calls to "),g("code",[e._v("verifySingle")]),e._v(" in the recursion return without error (return "),g("code",[e._v("nil")]),e._v(").")]),e._v(" "),g("li",[e._v("Thus we have a sequence of headers that all satisfied the "),g("code",[e._v("verifySingle")])]),e._v(" "),g("li",[e._v("again a contradiction")])]),e._v(" "),g("p",[e._v("light Client Completeness:")]),e._v(" "),g("p",[e._v("This is only ensured if upon "),g("code",[e._v("Commit(pivot)")]),e._v(" the light client is always provided with a correctly generated header.")]),e._v(" "),g("p",[g("em",[e._v("Stalling")])]),e._v(" "),g("p",[e._v("With "),g("code",[e._v("VerifyBisection")]),e._v(", a faulty full node could stall a light client by creating a long sequence of headers that are queried one-by-one by the light client and look OK,\nbefore the light client eventually detects a problem. There are several ways to address this:")]),e._v(" "),g("ul",[g("li",[e._v("Each call to "),g("code",[e._v("Commit")]),e._v(" could be issued to a different full node")]),e._v(" "),g("li",[e._v("Instead of querying header by header, the light client tells a full node which header it trusts, and the height of the header it needs. The full node responds with\nthe header along with a proof consisting of intermediate headers that the light client can use to verify. Roughly, "),g("code",[e._v("VerifyBisection")]),e._v(" would then be executed at the full node.")]),e._v(" "),g("li",[e._v("We may set a timeout how long "),g("code",[e._v("VerifyBisection")]),e._v(" may take.")])])],1)}),[],!1,null,null,null);t.default=i.exports}}]);